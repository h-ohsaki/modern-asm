# -*- Org -*-
# 
# Copyright (c) 2021, Hiroyuki Ohsaki.
# All rights reserved.
# 

# This document is licensed under a Creative Commons
# Attribution-NonCommercial-ShareAlike 4.0 International License (CC
# BY-NC-SA 4.0).

# This document is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# Creative Commons License for more details.

# You should have received a copy of the license along with this work.
# If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

* x86 命令セット (算術演算・論理演算)
<<ch:x86arith>>

本章では、
IA-32 アーキテクチャにおける算術演算と論理演算に関する命令の中でも、
特に重要度が高いものを紹介します。

** 2 進算術命令
<<sec:x86arith/arithmetic>>

[[ch:x86regs]] 章で説明したように、
IA-32 アーキテクチャにおける汎用命令のうち、
算術演算に関する命令は以下のように分類されます。

- 2 進算術命令
  - 加算命令と減算命令 ★
  - インクリメント命令とデクリメント命令 ★
  - 比較命令と符号変更命令 ★
  - 乗算命令と除算命令 ★
- 10 進算術命令
  -パックド BCD 調整命令
  - アンパックド BCD 調整命令

以下では、
★印を付けた命令の中でも特に重要な命令を説明します。

2 進算術命令は以下の 12 命令です (文献 \cite{Intel04:IA32J-1} から抜粋)。

| ADD  | Integer add          |
|      | 整数の加算           |
| ADC  | Add with carry       |
|      | キャリーあり加算     |
| SUB  | Subtract             |
|      | 減算                 |
| SBB  | Subtract with borrow |
|      | ボローあり減算       |
| IMUL | Signed multiply      |
|      | 符号付き乗算         |
| MUL  | Unsigned multiply    |
|      | 符号なし乗算         |
| IDIV | Signed divide        |
|      | 符号付き除算         |
| DIV  | Unsigned divide      |
|      | 符号なし除算         |
| INC  | Increment            |
|      | インクリメント       |
| DEC  | Decrement            |
|      | デクリメント         |
| NEG  | Negate               |
|      | 符号変更             |
| CMP  | Compare              |
|      | 比較                 |

コンピュータは「計算機」と呼ばれるくらいであり、
2 進算術命令はどれも重要な命令ばかりです。
以下では NEG 命令以外の命令をそれぞれ順番に説明します。

*** 加算命令: ADD (Add)、ADC (Add with Carry)

まず、
最も基本的な算術演算である *加算命令* です。

*ADD --- Add* [3-23]

*ADC --- Add with Carry* [3-21]

ADD 命令および ADC 命令は、
出所オペランドの値を宛先オペランドに加算します。

出所オペランドには、
即値、
汎用レジスタ、
メモリロケーションが指定できます。
宛先オペランドには汎用レジスタまたはメモリロケーションが指定できます。
MOV 命令と同じように出所オペランドと宛先オペランドの両方にメモリロケーションを指定することはできません。
つまり、
メモリに格納されている値を、
メモリに格納されている別の値に加算したり、
減算したりすることはできません。

ADD 命令も ADC 命令も算術演算命令なので、
実行結果によってフラグレジスタ (EFLAGS) 中のフラグ OF/SF/ZF/AF/CF/PF が結果に応じて変化します。

ADD 命令も ADC 命令も、
どちらも符号なし整数および符号付き整数のどちらにも利用できます。
つまり、
ADD 命令および ADC 命令の 2 つのオペランドは、
符号なし整数であっても符号付き整数であってもかまいません。
これは、
[[sec:number/binary]] 節で説明したように、
負数を 2 の補数表現で表しているからです。
2 の補数表現が持つ、
「2 の補数によって減算が加算になる」という、
非常に強力で、
美しい性質のおかげです。

符号なし整数として *桁あふれ* が起きれば CF フラグがセットされます。
符号付き整数として *オーバーフロー* が起きれば OF フラグがセットされます。
計算結果が符号付き整数で *負の数* であれば SF フラグがセットされます。

ADD 命令および ADC 命令の動作を、
CPU の抽象モデルで記述すると以下のようになります。

- レジスタ \r{i} に即値 $c$ を加える
  #+begin_quote
  \r{i} ← <+> $c$
  #+end_quote

- レジスタ \r{i} にレジスタ \r{j} の値を加える
  #+begin_quote
  \r{i} ← <+> \r{j}
  #+end_quote

- レジスタ \r{i} にメモリの値を加える
  #+begin_quote
  \r{i} ← <+> [$m$]
  #+end_quote

- メモリの値に即値 $c$ を加える
  #+begin_quote
  [$m$] ← <+> $c$
  #+end_quote

- メモリの値にレジスタ \r{i} の値を加える
  #+begin_quote
  [$m$] ← <+> \r{i}
  #+end_quote

計算結果に応じて、
[[sec:x86regs/register]] 節で説明した、
プログラム・ステータス・制御レジスタ EFLAGS の中の、
ステータスフラグの値が自動的に設定されます。
例えば、
桁あふれが発生したかに応じて *CF フラグ (キャリーフラグ)* が設定され、
結果がゼロかどうかに応じて *ZF フラグ (ゼロフラグ)* が設定され、
結果が負であったかどうかに応じて *SF フラグ (符号フラグ)* が設定されます。

ADD 命令と ADC 命令はほとんど同じ処理ですが、
CF フラグの扱いだけが異なります。
ADC 命令では、
命令の実行直前に CF フラグがセットされていれば、
計算結果に 1 を加えます。

例えば、
2 つのオペランドがどちらもレジスタの場合、
ADD 命令の動作は
#+begin_quote
\r{i} ← <+> \r{j}
#+end_quote
ですが、
ADC 命令の動作は
#+begin_quote
\r{i} ← <+> (\r{j} + \cf)
#+end_quote
となります。

ここで \cf は CF フラグの値 (0 または 1) を意味します。
CF フラグの値を加算に反映させることで、
桁数の多い整数どうしの加算が可能になります。

なぜこれが可能になるのか、
簡単な例を挙げて説明しましょう (図 [[fig:x86arith/add]])。

例えば、
レジスタ \r{1} 〜 \r{4} の大きさがすべて 8 ビットであるとします。
ここで、
2 つの 16 ビット整数 $x$ と $y$ を考えます。
$x$ の下位 8 ビットと上位 8 ビットを、
それぞれレジスタ \r{1} および \r{2} に格納しておきます。
同様に、
$y$ の下位 8 ビットと上位 8 ビットを、
それぞれレジスタ \r{3} および \r{4} に格納しておきます。

#+caption: 8 ビットのレジスタを用いた 16 ビットの加算
#+label: fig:x86arith/add
[[./figure/x86arith/add.png]]

ADC 命令を利用すれば、
8 ビットのレジスタを利用して、
16 ビットの加算が可能になります。
具体的には、
以下のようにします。
#+begin_quote
\r{1} ← <+> \r{3} \\
\r{2} ← <+> (\r{4} + \cf)
#+end_quote

まず、
下位 8 ビットの和 (レジスタ \r{1} とレジスタ \r{3} の和) を計算し、
結果をレジスタ \r{1} に格納します。
このとき、
桁あふれが発生すれば CF フラグがセットされます。
次に、
上位 8 ビットの和 (レジスタ \r{2} とレジスタ \r{4} の和) を計算しますが、
先ほど桁あふれが発生していたら結果が +1 されます。
これにより、
下位 8 ビットの桁上がりが上位 8 ビットに正しく反映され、
8 ビットレジスタしか利用できなくても、
16 ビット整数 $x$ と $y$ の加算が正しく計算できます。

例えば、
0x6789 + 0x09ab を計算すると以下のようになります (レジスタ \r{1}〜\r{4} の大きさをすべて 8 ビットとしていることに注意してください)。
| \r{1}  ← 0x89              |                                       |
| \r{2}  ← 0x67              |                                       |
| \r{3}  ← 0xab              |                                       |
| \r{4}  ← 0x09              |                                       |
| \r{1}  ← <+> \r{3}         | # \r{1} = 0x89 + 0x67 = 0x34, \cf = 1 |
| \r{2}  ← <+> (\r{4} + \cf) | # \r{2} = 0x67 + 0x9 + \cf = 0x71     |

レジスタ \r{1} およびレジスタ \r{2} に、
それぞれ 0x34 と 0x71 が格納され、
正しく 0x6789 + 0x09ab = 0x7134 が計算できています。

ここでは 8 ビットのレジスタを用いて 16 ビットの加算を行う例を示しましたが、
ADC 命令を繰り返して実行すれば、
もっと桁数の多い計算が可能になります。
例えば、
32 ビットのレジスタを用いて、
上のような処理を 10 回繰り返せば、
32 $\times$ 10 (= 320) ビットの整数の加算が可能になります。

#+begin_note
なお、
文献 \cite{Intel04:IA32J-1} の 7.2.2.1 節に ADD と ADC の違いが説明されていますが、
英語版 \cite{Intel20:IA32} の直訳となっていて、
おそらく日本語版の説明を読んでも理解は難しいと思います。

インテルのソフトウェア開発マニュアルに限らず、
日本語版の説明が理解できないときは、
英語版の説明を読むようにするとよいでしょう。
日本語版も直訳としては正しいといえますが、
残念ながら直訳では意味を理解するのは容易ではありません。
これは、
インテルが発行しているデータシートに限った話ではなく、
(英語版が原語の) 日本語版の技術文書のほとんどに当てはまります。
#+end_note

以下に、
ADD 命令および ADC 命令のオペコード表を示します (文献 \cite{Intel04:IA32J-2A} より抜粋)。

| オペコード | 命令             | 説明                             |
|------------+------------------+----------------------------------|
| 04 ib      | ADD AL, imm8     | imm8 をAL に加算する。           |
| 05 iw      | ADD AX, imm16    | imm16 をAX に加算する。          |
| 05 id      | ADD EAX, imm32   | imm32 をEAX に加算する。         |
| 80 /0 ib   | ADD r/m8, imm8   | imm8 をr/m8 に加算する。         |
| 81 /0 iw   | ADD r/m16, imm16 | imm16 をr/m16 に加算する。       |
| 81 /0 id   | ADD r/m32, imm32 | imm32 をr/m32 に加算する。       |
| 83 /0 ib   | ADD r/m16, imm8  | 符号拡張imm8 をrm16 に加算する。 |
| 83 /0 ib   | ADD r/m32, imm8  | 符号拡張imm8 をrm32 に加算する。 |
| 00 /r      | ADD r/m8, r8     | r8 をr/m8 に加算する。           |
| 01 /r      | ADD r/m16, r16   | r16 をr/m16 に加算する。         |
| 01 /r      | ADD r/m32, r32   | r32 をr/m32 に加算する。         |
| 02 /r      | ADD r8, r/m8     | r/m8 をr8 に加算する。           |
| 03 /r      | ADD r16, r/m16   | r/m16 をr16 に加算する。         |
| 03 /r      | ADD r32, r/m32   | r/m32 をr32 に加算する。         |

| オペコード | 命令             | 説明                                              |
|------------+------------------+---------------------------------------------------|
| 14 ib      | ADC AL, imm8     | キャリーを加えてimm8 をAL に加算する。            |
| 15 iw      | ADC AX, imm16    | キャリーを加えてimm16 をAX に加算する。           |
| 15 id      | ADC EAX, imm32   | キャリーを加えてimm32 をEAX に加算する。          |
| 80 /2 ib   | ADC r/m8, imm8   | キャリーを加えてimm8 をr/m8 に加算する。          |
| 81 /2 iw   | ADC r/m16, imm16 | キャリーを加えてimm16 をr/m16 に加算する。        |
| 81 /2 id   | ADC r/m32, imm32 | CF を加えてimm32 をr/m32 に加算する。             |
| 83 /2 ib   | ADC r/m16, imm8  | CF を加えて符号拡張imm8 をr/m16 に加算する。      |
| 83 /2 ib   | ADC r/m32, imm8  | CF を加えて符号拡張imm8 をr/m32 に加算する。      |
| 10 /r      | ADC r/m8, r8     | キャリーを加えてバイトレジスタをr/m8 に加算する。 |
| 11 /r      | ADC r/m16, r16   | キャリーを加えてr16 をr/m16 に加算する。          |
| 11 /r      | ADC r/m32, r32   | CF を加えてr32 をr/m32 に加算する。               |
| 12 /r      | ADC r8, r/m8     | キャリーを加えてr/m8 をバイトレジスタに加算する。 |
| 13 /r      | ADC r16, r/m16   | キャリーを加えてr/m16 をr16 に加算する。          |
| 13 /r      | ADC r32, r/m32   | CF を加えてr/m32 をr32 に加算する。               |

これまで登場していない、
ib、
iw、
id のような表記が登場しますが、
これらは、
バイト (8 ビット)、
ワード (16 ビット)、
ダブルワード (32 ビット) の即値が命令コードのあとに続くことを意味しています。
例えば、
#+begin_src asm
	addl	$0x12345678, %eax
#+end_src
であれば、
0x05、
0x78、
0x56、
0x34、
0x12 という 5 バイトの機械語になり、
「ADD EAX, imm32」のオペコードである 0x05 のあとに、
即値である 0x12345678 をリトルエンディアンで格納した 0x78、
0x56、
0x34、
0x12 が続きます。

#+begin_quote
あれ、
MOV 命令のオペコード表では、
オペランドに即値を取る場合でも、
「オペコード」の覧に ib、
iw、
id などと書いていなかったはずでは?
#+end_quote
と思った人がいるかもしれませんが、
そのとおりです。
日本語版のソフトウェア開発マニュアルでは、
オペコードのあとに即値を取る場所に ib、
iw、
id が書いてあったり、
書いてなかったりします。
おそらく記述漏れだと考えられます。

英語版の (随時更新されている) ソフトウェア開発マニュアルでは、
オペコードのあとに即値を取る場合は、
すべて ib、
iw、
id が書かれています。

以下に、
ADD 命令のサンプルプログラムを示します (図 [[fig:x86arith/add.lst]])。

#+caption: x86arith/add.lst
#+label: fig:x86arith/add.lst
#+include: "code/x86arith/add.lst" src asm

また、
以下に示すのが ADC 命令のサンプルプログラムです (図 [[fig:x86arith/adc.lst]])。

#+caption: x86arith/adc.lst
#+label: fig:x86arith/adc.lst
#+include: "code/x86arith/adc.lst" src asm

このように、
8 ビットの ADD 命令や ADC 命令で、
16 ビット + 16 ビットの加算を行ったり、
また、
32 ビットの ADD 命令や ADC 命令で、
64 ビット + 64 ビットの加算を行ったりすることができます。

*** 減算命令: SUB (Subtract)、SBB (Subtract with Borrow)

次は減算命令です。

*SUB --- Subtract* [4-249]

*SBB --- Integer Subtraction with Borrow* [4-198]

SUB 命令および SBB 命令は、
出所オペランドの値を宛先オペランドから減算します。
SUB 命令および SBB 命令の動作は、
加算が減算になる点を除き、
ADD 命令および ADC 命令とほとんど同じです。

SUB 命令および SBB 命令は、
2 つのオペランドの差を計算し、
結果をレジスタまたはメモリに格納します。
SBB 命令は、
ADC 命令と同じように、
SUB 命令とほとんど同じ処理ですが、
(SBB 命令の実行直前に) CF フラグがセットされていれば、
計算結果から 1 を減じます。

例えば、
2 つのオペランドがどちらもレジスタの場合、
SUB 命令の動作は
#+begin_quote
\r{i} ← <-> \r{j}
#+end_quote
ですが、
SBB 命令の動作は
#+begin_quote
\r{i} ← <-> (\r{j} + \cf)
#+end_quote
となります。
ADC 命令と同じように、
CF フラグの結果を減算に反映させることで、
桁数の多い整数どうしの減算が可能になります。

次に示すのは、
SUB 命令および SBB 命令のオペコード表です (文献 \cite{Intel04:IA32J-2B} より抜粋)。

| オペコード | 命令             | 説明                                  |
|------------+------------------+---------------------------------------|
| 2C ib      | SUB AL, imm8     | AL からimm8 を引く。                  |
| 2D iw      | SUB AX, imm16    | AX からimm16 を引く。                 |
| 2D id      | SUB EAX, imm32   | EAX からimm32 を引く。                |
| 80 /5 ib   | SUB r/m8, imm8   | r/m8 からimm8 を引く。                |
| 81 /5 iw   | SUB r/m16, imm16 | r/m16 からimm16 を引く。              |
| 81 /5 id   | SUB r/m32, imm32 | r/m32 からimm32 を引く。              |
| 83 /5 ib   | SUB r/m16, imm8  | r/m16 から符号拡張されたimm8 を引く。 |
| 83 /5 ib   | SUB r/m32, imm8  | r/m32 から符号拡張されたimm8 を引く。 |
| 28 /r      | SUB r/m8, r8     | r/m8 からr8 を引く。                  |
| 29 /r      | SUB r/m16, r16   | r/m16 からr16 を引く。                |
| 29 /r      | SUB r/m32, r32   | r/m32 からr32 を引く。                |
| 2A /r      | SUB r8, r/m8     | r8 からr/m8 を引く。                  |
| 2B /r      | SUB r16, r/m16   | r16 からr/m16 を引く。                |
| 2B /r      | SUB r32, r/m32   | r32 からr/m32 を引く。                |

| オペコード | 命令             | 説明                                              |
|------------+------------------+---------------------------------------------------|
| 1C ib      | SBB AL, imm8     | AL から imm8 をボローありで引く。                 |
| 1D iw      | SBB AX, imm16    | AX から imm16 をボローありで引く。                |
| 1D id      | SBB EAX, imm32   | EAX から imm32 をボローありで引く。               |
| 80 /3 ib   | SBB r/m8, imm8   | r/m8 からimm8 をボローありで引く。                |
| 81 /3 iw   | SBB r/m16, imm16 | r/m16 からimm16 をボローありで引く。              |
| 81 /3 id   | SBB r/m32, imm32 | r/m32 からimm32 をボローありで引く。              |
| 83 /3 ib   | SBB r/m16, imm8  | r/m16 から符号拡張されたimm8 をボローありで引く。 |
| 83 /3 ib   | SBB r/m32, imm8  | r/m32 から符号拡張されたimm8 をボローありで引く。 |
| 18 /r      | SBB r/m8, r8     | r/m8 からr8 をボローありで引く。                  |
| 19 /r      | SBB r/m16, r16   | r/m16 からr16 をボローありで引く。                |
| 19 /r      | SBB r/m32, r32   | r/m32 からr32 をボローありで引く。                |
| 1A /r      | SBB r8, r/m8     | r8 からr/m8 をボローありで引く。                  |
| 1B /r      | SBB r16, r/m16   | r16 からr/m16 をボローありで引く。                |
| 1B /r      | SBB r32, r/m32   | r32 からr/m32 をボローありで引く。                |

以下は、
SUB 命令のサンプルプログラムです (図 [[fig:x86arith/sub.lst]])。

#+caption: x86arith/sub.lst
#+label: fig:x86arith/sub.lst
#+include: "code/x86arith/sub.lst" src asm

また、
以下は SBB 命令のサンプルプログラムです (図 [[fig:x86arith/sbb.lst]])。

#+caption: x86arith/sbb.lst
#+label: fig:x86arith/sbb.lst
#+include: "code/x86arith/sbb.lst" src asm

ADC 命令のサンプルプログラムと同じように、
8 ビットの SUB 命令や SBC 命令で、
16 ビット - 16 ビットの減算を行ったりまた、
32 ビットの SUB 命令や SBB 命令で、
64 ビット - 64 ビットの減算を行ったりすることが可能です。

*** 乗算命令: MUL (Multiply)、IMUL (sIgned Multiply)

*MUL --- Unsigned Multiply* [3-561]

*IMUL --- Signed Multiply* [3-371]

MUL 命令および IMUL 命令は、
それぞれ符号なし整数と符号付き整数の乗算を行います。
オペランドが *符号なし整数 (unsigned integer)* か *符号付き整数 (signed integer)* かによって別の命令が用意されています。

MUL 命令は ADD 命令や SUB 命令とは異なり、
少し変わった命令です。

まず、
MUL 命令はオペランドを 1 つだけ取ります。
オペランドには、
レジスタおよびメモリロケーションが指定できます。
即値は指定できません。
「乗算命令なのにオペランドが 1 つだけ?」
と疑問を持ちますが、
本当にオペランドは 1 つだけです。
その理由は、
乗算における他方のオペランドがレジスタ AL、
AX、
EAX に決めうちされているためです。

さらに、
整数の乗算では、
多くの場合、
計算結果の桁数が増えてしまうため、
MUL 命令は乗算結果を 2 つのレジスタに分けて格納します。
例えば 8 ビットの値の乗算 (0x89 \times 0xab)
を考えます。
オペランドは 8 ビットの数でも、
0x89 \times 0xab = 0x5b83 のように乗算すると結果が 16 ビットの値になってしまいます。

このような場合、
1 つの対処方法は、
ADD 命令や SUB 命令と同じように、
桁あふれが起きたときには下位 8 ビットだけ (上の例では 0x83)
を保存し、
桁あふれが起きたことを CF フラグや OF フラグで通知するという方法です。
しかし乗算命令では桁数が増えることが一般的であり、
この方法では頻繁に値が切り捨てられてしまいます。

そこで MUL 命令では、
演算結果を以下のようなレジスタのペアに格納します。
- レジスタ AL \times なんとか →レジスタ AX 
- レジスタ AX \times なんとか → レジスタ DX:AX 
- レジスタ EAX \times なんとか → レジスタ EDX:EAX
このため例えば、
8 ビットの値どうしの乗算
#+begin_src asm
	movb	$0x12, %al
	movb	$0x34, %cl
        mulb    %cl
#+end_src
の場合は、
計算結果がレジスタ AL (8 ビット) ではなくレジスタ AX (16 ビット) に格納されます。
同様に、
16 ビットの値どうしの乗算
#+begin_src asm
	movw	$0x1234, %ax
	movw	$0x0100, %cx
        mulw    %cx
#+end_src
の場合は、
計算結果を 32 ビットで計算し、
計算結果をレジスタ AX (16 ビット) ではなく、
レジスタ DX とレジスタ AX に分けて格納します。
32 ビットの計算結果の、
上位 16 ビットをレジスタ DX に、
下位 16 ビットをレジスタ AX に格納します。

MUL 命令では、
計算結果に応じて OF フラグと CF フラグが設定されます。
結果の上位部分 (例えば、
DX:AX レジスタに結果が格納されるならレジスタ DX の値) がゼロの場合は、
OF フラグと CF フラグが 0 になります。
また、
結果の上位部分がゼロでなければ、
OF フラグと CF フラグが 0 がどちらも 1 に設定されます。
それ以外のステータスフラグ (フラグ SF/ZF/AF/ PF) は未定義 (どのように変化するかは不定) です。

MUL 命令の動作の概要を CPU の抽象モデルで記述すると以下のようになります。
レジスタ AL/AX/EAX を \r{a}、
MUL 命令のオペランドを \r{i} や $m$ と表記しています。

- レジスタ \r{a} の値に、レジスタ \r{i} の値を掛け、結果を \r{d}:\r{a}
  に格納する
  #+begin_quote
  temp ← \r{a} \\
  temp ← <*> \r{i} \\
  \r{a} ← temp の下位部分 \\
  \r{d} ← temp の上位部分
  #+end_quote

- レジスタ \r{a} の値に、メモリに格納されている値を掛け、結果を
  \r{d}:\r{a} に格納する
  #+begin_quote
  temp ← \r{a} \\
  temp ← <*> [$m$] \\
  \r{a} ← temp の下位部分 \\
  \r{d} ← temp の上位部分
  #+end_quote

ここでは、
CPU の抽象モデルだけでは完全に記述できないため、
「temp の下位部分」、
「temp の上位部分」のような処理を表す表現を使っています。
「temp の下位部分」や「temp の上位部分」は、
下位のビットや上位のビット (何ビットかは \r{a} の大きさによる) を取り出す操作を表しています。

MUL 命令のオペコード表です (文献 \cite{Intel04:IA32J-2A} より抜粋)。

| オペコード | 命令      | 説明                                |
|------------+-----------+-------------------------------------|
| F6 /4      | MUL r/m8  | 符号なし乗算(AX ← AL * r/m8)       |
| F7 /4      | MUL r/m16 | 符号なし乗算(DX:AX ← AX * r/m16)   |
| F7 /4      | MUL r/m32 | 符号なし乗算(EDX:EAX ← EAX * r/m32) |

IA-32 アーキテクチャの命令としては珍しく単純なオペコード表です。

MUL 命令のサンプルプログラムです (図 [[fig:x86arith/mul.lst]])。

#+caption: x86arith/mul.lst
#+label: fig:x86arith/mul.lst
#+include: "code/x86arith/mul.lst" src asm

MUL 命令は符号なし整数の乗算命令でしたが、
IMUL 命令は符号付き整数の乗算命令です。

IMUL 命令は、
MUL 命令と同じように 1 つのオペランドを取ります。
IMUL 命令では演算が符号付き整数で行われる点を除き、
MUL 命令と基本的に同じです。

ただし IMUL 命令は MUL 命令と違い、
2 つのオペランドを指定したり、
さらに 3 つのオペランドを指定したりすることもできます。
宛先オペランドにはレジスタしか指定できませんが、
出所オペランドには即値、
レジスタ、
メモリロケーションが指定できます。

オペランドが 2 つや 3 つの場合には、
オペランドが 1 つのときのように DX:AX レジスタや EDX:EAX レジスタに計算結果を格納するのではなく、
そのまま宛先オペランドに格納します。
このため、
2 つ以上のオペランドを指定する場合にはオーバーフローに注意が必要です。

2 オペランド時の、
IMUL 命令の動作を CPU の抽象モデルで記述すると以下のようになります。

- レジスタ \r{i} の値にレジスタ \r{j} の値を掛ける
  #+begin_quote
  \r{i} ← <*> \r{j}
  #+end_quote

- レジスタ \r{i} の値に即値 $c$ を掛ける
  #+begin_quote
  \r{i} ← <*> $c$
  #+end_quote

- レジスタ \r{i} の値にメモリに格納されている値を掛ける
  #+begin_quote
  \r{i} ← <*> [$m$]
  #+end_quote

IMUL 命令は、
このように ADD 命令や SUB 命令と同じような普通の形式のオペランドを取りますが、
3 オペランドの指定も可能です。
3 オペランドの場合は、
「IMUL 宛先オペランド, 出所オペランド 1, 出所オペランド 2」のように出所オペランドが 2 つになります。
宛先オペランドにはやはりレジスタしか指定できませんが、
出所オペランド 1 にはレジスタもしくはメモリロケーションが指定できます。
また、
出所オペランド 2 には即値のみが指定できます。

3 オペランド時の、
IMUL 命令の動作を CPU の抽象モデルで記述すると以下のようになります。

- レジスタ \r{i} の値に即値 $c$ を掛けて、レジスタ \r{j} に格納する
  #+begin_quote
  \r{j} ← \r{i} * $c$
  #+end_quote

- メモリ $m$ に格納されている値に即値 $c$ を掛けて、レジスタ \r{i} に格納する
  #+begin_quote
  \r{i} ← [$m$] * $c$
  #+end_quote

AT&T 構文の場合、
3 つのオペランドは
#+begin_src asm
	imull	$2, %ecx, %eax
#+end_src
のように順番が逆になります。
前から順に、
出所オペランド 2、
出所オペランド 1、
宛先オペランドの順番です。

IMUL 命令はこのように、
オペランドの数が 1 ～ 3 の 3 種類があり、
出所オペランド 2 は即値しか指定できないなど、
少し癖のある命令だといえます。

以下、
IMUL 命令のオペコード表です (文献 \cite{Intel04:IA32J-2A} より抜粋)。

#+attr_latex: :environment maxtabular
| オペコード | 命令                   | 説明                                                                  |
|------------+------------------------+-----------------------------------------------------------------------|
| F6 /5      | IMUL r/m8              | AX← AL * r/m バイト                                                  |
| F7 /5      | IMUL r/m16             | DX:AX ← AX * r/m ワード                                              |
| F7 /5      | IMUL r/m32             | EDX:EAX ← EAX * r/m ダブルワード                                     |
| 0F AF /r   | IMUL r16, r/m16        | ワードレジスタ ← ワードレジスタ * r/m ワード                         |
| 0F AF /r   | IMUL r32, r/m32        | ダブルワード・レジスタ ← ダブルワード・レジスタ * r/m ダブルワード   |
| 6B /r ib   | IMUL r16, r/m16, imm8  | ワードレジスタ ← r/m16 * 符号拡張即値バイト                          |
| 6B /r ib   | IMUL r32, r/m32, imm8  | ダブルワード・レジスタ ← r/m32 * 符号拡張即値バイト                  |
| 6B /r ib   | IMUL r16, imm8         | ワードレジスタ ← ワードレジスタ * 符号拡張即値バイト                 |
| 6B /r ib   | IMUL r32, imm8         | ダブルワード・レジスタ ← ダブルワード・レジスタ * 符号拡張即値バイト |
| 69 /r iw   | IMUL r16, r/m16, imm16 | ワードレジスタ ← r/m16 * 即値ワード                                  |
| 69 /r id   | IMUL r32, r/m32, imm32 | ダブルワード・レジスタ ← r/m32 * 即値ダブルワード                    |
| 69 /r iw   | IMUL r16, imm16        | ワードレジスタ ← r/m16 * 即値ワード                                  |
| 69 /r id   | IMUL r32, imm32        | ダブルワード・レジスタ ← r/m32 * 即値ダブルワード                    |

また、
IMUL 命令のサンプルプログラムを以下に示します (図 [[fig:x86arith/imul.lst]])。

#+caption: x86arith/imul.lst
#+label: fig:x86arith/imul.lst
#+include: "code/x86arith/imul.lst" src asm

*** 除算命令: DIV (Divide)、IDIV (sIgned Divide)

**DIV --- Unsigned Divide** [3-204]

***IDIV --- Signed Divide*** [3-368]

DIV 命令および IDIV 命令は、
それぞれ符号なし整数と符号付き整数の除算を行います。
指定された 2 つのオペランドの除算を行い、
結果をレジスタに格納します。

除算命令は、
乗算の MUL 命令と同じように 1 つだけオペランドを取ります。
幸いなことに、
DIV 命令と IDIV 命令は、
MUL 命令や IMUL 命令ほど複雑ではありません。

DIV 命令と IDIV 命令は、
演算を、
符号なしで行うか、
符号付きで行うかのみが異なっています。
以下ではこれら 2 つの命令をまとめて説明します。

DIV 命令や IDIV 命令は、
レジスタ AX、
DX:AX (2 つ並べて 32 ビットの値を表現)、
EDX:EAX (2 つ並べて 64 ビットの値を表現) の値を、
指定したオペランドで割った結果 (商) をレジスタ AL、
AX、
EAX に格納します。
除算の余り (剰余) をレジスタ AH、
DX、
EDX に格納します。

ステータスフラグの変化は未定義です。
フラグ CF/OF/SF/ZF/AF/PF がどのように変化するは不定です。

数学では 0 での除算は定義されていません。
このため、
オペランドに 0 を指定する (0 で割ろうとする) と #DE (Division Error) という *例外 (exception)* が発生します。
通常、
CPU が発生した例外は、
アプリケーションプログラムではなくオペレーティングシステムが検知し、
例外の種類に応じた処理を行います。

また、
除算の結果がレジスタに収まらない場合にも、
同じように #DE という例外が発生するため注意が必要です。
例えば、
DIV 命令や IDIV 命令で
#+begin_src asm
	divb	%cl
#+end_src
を実行すると、
レジスタ AX の値をレジスタ CL の値で割った結果のうち、
商がレジスタ AL に格納され、
剰余がレジスタ AH に格納されます。

さらに、
商がレジスタ AL に収まらない場合は例外 #DE が発生します。
例えば、
符号なし整数のための DIV 命令の場合、
商が 255 を超えると例外が発生します。

DIV 命令および IDIV 命令の処理を、
CPU の抽象モデルで記述すると以下のようになります。

- レジスタ \r{i} の値をレジスタ \r{j} の値で割る
  #+begin_quote
  \r{i} ← </> \r{j}
  #+end_quote

- レジスタ \r{i} の値をメモリ $m$ の値で割る
  #+begin_quote
  \r{i} ← </> [$m$]
  #+end_quote

正確には、
上で説明したように剰余が別のレジスタに保存されます。

IA-32 アーキテクチャは信じられないくらい複雑なアーキテクチャですが、
サポートしている算術演算は四則演算 (加算・減算・乗算・除算の 4 つ) だけです。

例えば、
整数どうしの羃 (べき) (例 : $12^3$ = 12 \times 12 \times 12) や、
階乗 (例 : 6! = 6 \times 5 \times \cdots \times 2 \times 1) を計算するための専用の命令は持っていません。
IA-32 アーキテクチャも、
フォン・ノイマン・アーキテクチャの一種なので、
単純な処理の組み合わせによって、
整数どうしの羃や階乗の計算などの複雑な計算を実現できます。

以下に示すのは、
DIV 命令および IDIV 命令のオペコード表です (文献 \cite{Intel04:IA32J-2A} より抜粋)。

#+attr_latex: :environment maxtabular
| オペコード | 命令      | 説明                                                                |
|------------+-----------+---------------------------------------------------------------------|
| F6 /6      | DIV r/m8  | AX を r/m8 で符号なし除算する。結果は次のようにストアされる。       |
|            |           | AL ←商、AH ←剰余                                                  |
| F7 /6      | DIV r/m16 | DX:AX を r/m16 で符号なし除算する。結果は次のようにストアされる。   |
|            |           | AX ←商、DX ←剰余                                                  |
| F7 /6      | DIV r/m32 | EDX:EAX を r/m32 で符号なし除算する。結果は次のようにストアされる。 |
|            |           | EAX ←商、EDX ←剰余                                                |

#+attr_latex: :environment maxtabular
| オペコード | 命令       | 説明                                                                |
|------------+------------+---------------------------------------------------------------------|
| F6 /7      | IDIV r/m8  | AX を r/m8 で符号付き除算する。結果は次のようにストアされる。       |
|            |            | AL ←商、AH ←剰余                                                  |
| F7 /7      | IDIV r/m16 | DX:AX を r/m16 で符号付き除算する。結果は次のようにストアされる。   |
|            |            | AX ←商、DX ←剰余                                                  |
| F7 /7      | IDIV r/m32 | EDX:EAX を r/m32 で符号付き除算する。結果は次のようにストアされる。 |
|            |            | EAX ←商、EDX ←剰余                                                |

DIV 命令のサンプルプログラムです。

#+caption: x86arith/div.lst
#+label: fig:x86arith/div.lst
#+include: "code/x86arith/div.lst" src asm

*** インクリメント命令: INC (Increment)

*INC --- Increment by 1* [3-378]

INC 命令はオペランドの値に 1 を加えます。
INC 命令のオペランドにはレジスタもしくはメモリロケーションが指定できます。

レジスタやメモリの値を 1 だけ増加させるという処理は頻繁に行いますので、
値を 1 だけ増加させる専用の命令が用意されています。

INC 命令の動作を CPU の抽象モデルで記述すると以下のようになります。

- レジスタ \r{i} に 1 を加える
  #+begin_quote
  \r{i} ← <+> 1
  #+end_quote

- メモリに格納されている値に 1 を加える
  #+begin_quote
  [$m$] ← <+> 1
  #+end_quote

演算結果に応じてステータスフラグ (EFLAGS) の値が変化し、
フラグ OF/SF/ZF/AF/PF が結果に応じて設定されます。
ただし、
CF フラグだけは変化しません。

以下に示すのは、
INC 命令のオペコード表です (文献 \cite{Intel04:IA32J-2A} より抜粋)。

| オペコード | 命令      | 説明                                            |
|------------+-----------+-------------------------------------------------|
| FE /0      | INC r/m8  | r/m バイトを 1 インクリメントする。             |
| FF /0      | INC r/m16 | r/m ワードを 1 インクリメントする。             |
| FF /0      | INC r/m32 | r/m ダブルワードを 1 インクリメントする。       |
| 40+rw      | INC r16   | ワードレジスタを 1 インクリメントする。         |
| 40+rd      | INC r32   | ダブルワード・レジスタを 1 インクリメントする。 |

INC 命令は頻繁に使用される命令なので、
機械語も短くて済みます。

INC 命令のサンプルプログラムです。

#+caption: x86arith/inc.lst
#+label: fig:x86arith/inc.lst
#+include: "code/x86arith/inc.lst" src asm

*** デクリメント命令: DEC (Decrement)

*DEC --- Decrement by 1* [3-202]

DEC 命令は INC 命令の逆であり、
DEC 命令はオペランドの値から 1 を減じます。

INC 命令と同じように、
DEC 命令の動作を CPU の抽象モデルで記述すると以下のようになります。

- レジスタ \r{i} から 1 を減じる
  #+begin_quote
  \r{i} ← <-> 1
  #+end_quote

- メモリに格納されている値から 1 を減じる
  #+begin_quote
  [$m$] ← <-> 1
  #+end_quote

ステータスフラグの変化も INC 命令と同じです。
また、
CF フラグが変化しないという点も同じです。

もちろん、
INC 命令や DEC 命令と同じような処理は、
ADD 命令や SUB 命令を用いて記述することもできます。
例えば、
レジスタ EAX に 1 を加えるのであれば、
#+begin_src asm
	addl $1, %eax
#+end_src
と書いてもかまいませんし、
同様に、
レジスタ EAX の値を 1 だけ減らすのであれば、
#+begin_src asm
	subl $1, %eax
#+end_src
や
#+begin_src asm
	addl $-1, %eax
#+end_src
のように書いてもかまいません。
しかし、
1 だけレジスタやメモリの値を増減させるというのは頻繁に行われる処理なので、
このような専用の命令が用意されています。

ただし、
ADD 命令や SUB 命令では CF フラグが設定されるのに対し、
INC 命令や DEC 命令は CF フラグを変化させないという点が異なります。

以下が、
DEC 命令のオペコード表です (文献 \cite{Intel04:IA32J-2A} より抜粋)。

| オペコード | 命令      | 説明                          |
|------------+-----------+-------------------------------|
| FE /1      | DEC r/m8  | r/m8 を 1 デクリメントする。  |
| FF /1      | DEC r/m16 | r/m16 を 1 デクリメントする。 |
| FF /1      | DEC r/m32 | r/m32 を 1 デクリメントする。 |
| 48+rw      | DEC r16   | r16 を 1 デクリメントする。   |
| 48+rd      | DEC r32   | r32 を 1 デクリメントする。   |

DEC 命令のサンプルプログラムを以下に示します (図 [[fig:x86arith/dec.lst]])。

#+caption: x86arith/dec.lst
#+label: fig:x86arith/dec.lst
#+include: "code/x86arith/dec.lst" src asm

*** 比較命令: CMP (Compare)

*CMP --- Compare Two Operands* [3-95]

CMP 命令は、
指定された 2 つのオペランドの値を比較します。
具体的には、
2 つのオペランドの差を計算し、
計算結果に応じて、
EFLAGS 中のステータスフラグの値を設定します。
フラグ CF/OF/SF/ZF/AF/PF が設定されます。

CMP 命令は比較する *だけ* で、
2 つのオペランドの値には影響を与えません。
比較結果に応じてステータスフラグを設定するだけです。

2 つのオペランドの差 (宛先オペランド - 出所オペランド) を計算します。
ADD 命令や SUB 命令と同じように、
オペランドの値は、
符号なし整数でも符号付き整数でもどちらでも構いません。
符号なし整数と見なしたときの比較結果が CF フラグに、
符号付き整数と見なしたときの比較結果が OF フラグに保存されます。

オペランドの差によって桁あふれが発生したか否かに応じて CF フラグ (符号なし整数の場合) や OF フラグ (符号付き整数の場合) が設定されます。
結果がゼロか否かに応じて ZF フラグを設定します。
結果が負であったか否かに応じて SF フラグを設定します。

別の言い方をすれば、
比較命令である CMP 命令は、
減算命令である SUB 命令と基本的に同じです。
ただし、
SUB 命令が計算結果を宛先オペランドに格納するのに対し、
CMP 命令は計算結果をフラグに反映させるだけで、
レジスタやメモリの値は変更しません。

CMP は、
次章で説明する制御転送命令などと組み合わせて利用されます。

CMP 命令のオペコード表です (文献 \cite{Intel04:IA32J-2A} より抜粋)。

| オペコード | 命令             | 説明                        |
|------------+------------------+-----------------------------|
| 3C ib      | CMP AL, imm8     | imm8 を AL と比較する。     |
| 3D iw      | CMP AX, imm16    | imm16 を AX と比較する。    |
| 3D id      | CMP EAX, imm32   | imm32 を EAX と比較する。   |
| 80 /7 ib   | CMP r/m8, imm8   | imm8 を r/m8 と比較する。   |
| 81 /7 iw   | CMP r/m16, imm16 | imm16 を r/m16 と比較する。 |
| 81 /7 id   | CMP r/m32, imm32 | imm32 を r/m32 と比較する。 |
| 83 /7 ib   | CMP r/m16, imm8  | imm8 を r/m16 と比較する。  |
| 83 /7 ib   | CMP r/m32, imm8  | imm8 を r/m32 と比較する。  |
| 38 /r      | CMP r/m8, r8     | r8 を r/m8 と比較する。     |
| 39 /r      | CMP r/m16, r16   | r16 を r/m16 と比較する。   |
| 39 /r      | CMP r/m32, r32   | r32 を r/m32 と比較する。   |
| 3A /r      | CMP r8, r/m8     | r/m8 を r8 と比較する。     |
| 3B /r      | CMP r16, r/m16   | r/m16 を r16 と比較する。   |
| 3B /r      | CMP r32, r/m32   | r/m32 を r32 と比較する。   |

上のオペコード表からわかるように、
出所オペランドと宛先オペランドに指定できるオペランドの種類が決まっているので注意してください。
特に、
即値を指定できるのは出所オペランドのみです。
即値を宛先オペランドに指定することはできません。
このため、
#+begin_src asm
	cmpb    $0x78, %al
#+end_src
のようには書けますが、
#+begin_src asm
	cmpb    %al, $0x78
#+end_src
のようには書けません (アセンブルに失敗します)。

CMP 命令のサンプルプログラムです (図 [[fig:x86arith/cmp.lst]])。

#+caption: x86arith/cmp.lst
#+label: fig:x86arith/cmp.lst
#+include: "code/x86arith/cmp.lst" src asm

CMP 命令は比較命令であり、
汎用レジスタやメモリの値は一切変化しません。
CMP 命令の結果に応じてステータスフラグレジスタが変化します。

** 論理命令
<<sec:x86arith/logical>>

IA-32 アーキテクチャの論理命令は以下の 4 つです (文献 \cite{Intel04:IA32J-1} より抜粋)。

| AND | Perform bitwise logical AND                |
|     | ビットごとの AND（論理積）演算を実行       |
| OR  | Perform bitwise logical OR                 |
|     | ビットごとの OR（論理和）演算を実行        |
| XOR | Perform bitwise logical exclusive OR       |
|     | ビットごとの XOR（排他的論理和）演算を実行 |
| NOT | Perform bitwise logical NOT                |
|     | ビットごとの NOT（否定論理）演算を実行     |

*** 論理命令: AND、OR、XOR

*AND --- Logical AND* [3-39]

*OR -- Logical Inclusive OR* [4-6]

*XOR -- Logical Exclusive OR* [4-296]

AND 命令、
OR 命令、
XOR 命令は論理演算の種類が異なるだけで、
それ以外はほぼ同じように動作します。
そこで、
以下ではこれらの 3 命令をまとめて説明します。

AND 命令、
OR 命令、
XOR 命令は、
指定された 2 つのオペランドに対してビットごとの論理演算を行い、
結果をレジスタまたはメモリに格納します。
命令の名前 (ニーモニック) が表すように、
それぞれ論理積、
論理和、
排他的論理和を計算するための命令です。

AND 命令、
OR 命令、
XOR 命令は、
2 つのオペランドをそれぞれ単なるビット列として扱い、
ビット単位の論理積、
論理和、
排他的論理和を計算します。
オペランドに格納されている値が 2 進数であろうが、
文字列であろうが、
符号なし整数であろうが、
符号付き整数であろうが関係ありません。
オペランドの値が何を意味するかに関係なく、
単なるビット列として論理演算を行います。

AND 命令、
OR 命令、
XOR 命令の実行によってステータスフラグが変化します。
まず、
OF フラグおよび CF フラグは 0 になります。
また、
フラグ SF、
ZF、
PF は論理演算の結果に応じて設定されます。
ただし、
AF フラグの状態は未定義です。

AND 命令の動作を CPU の抽象モデルで記述すると以下のようになります。
以下では、
ビット単位の論理積、
論理和、
排他的論理和をそれぞれ「~&~」、
「~|~」、
「~^~」と表記します (C 言語と同じ演算子の表記を用います)。

 - レジスタ \r{i} と即値 $c$ の論理積を計算し、レジスタ \r{i} に格納す
   る
   #+begin_quote
   \r{i} ← <&> $c$
   #+end_quote

 - レジスタ \r{i} とレジスタ \r{j} の論理積を計算し、レジスタ \r{i} に
   格納する
   #+begin_quote
   \r{i} ← <&> \r{j}
   #+end_quote

 - レジスタ \r{i} とメモリ $m$ に格納されている値の論理積を計算し、レ
   ジスタ \r{i} に格納する
   #+begin_quote
   \r{i} ← <&> [$m$]
   #+end_quote

 - メモリ $m$ に格納されている値と即値 $c$ の論理積を計算し、メモリ
   $m$ に格納する
   #+begin_quote
   [$m$] ← <&> $c$
   #+end_quote

 - メモリ $m$ に格納されている値とレジスタ \r{i} の論理積を計算し、メ
   モリ $m$ に格納する
   #+begin_quote
   [$m$] ← <&> \r{i}
   #+end_quote

OR 命令および XOR 命令の処理も、
(実行される論理演算が、
論理積ではなく論理和や排他的論理和であるという点を除いて) AND 命令と同じです。

以下に示すのは、
AND 命令、
OR 命令、
XOR 命令のオペコード表です (文献 \cite{Intel04:IA32J-2A,Intel04:IA32J-2B} より抜粋)。

| オペコード | 命令             | 説明                                     |
|------------+------------------+------------------------------------------|
| 24 ib      | AND AL, imm8     | AL と imm8 との AND をとる。             |
| 25 iw      | AND AX, imm16    | AX と imm16 との AND をとる。            |
| 25 id      | AND EAX, imm32   | EAX と imm32 との AND をとる。           |
| 80 /4 ib   | AND r/m8, imm8   | r/m8 と imm8 との AND をとる。           |
| 81 /4 iw   | AND r/m16, imm16 | r/m16 と imm16 との AND をとる。         |
| 81 /4 id   | AND r/m32, imm32 | r/m32 と imm32 との AND をとる。         |
| 83 /4 ib   | AND r/m16, imm8  | r/m16 と imm8(符号拡張)との AND をとる。 |
| 83 /4 ib   | AND r/m32, imm8  | r/m32 と imm8(符号拡張)との AND をとる。 |
| 20 /r      | AND r/m8, r8     | r/m8 と r8 との AND をとる。             |
| 21 /r      | AND r/m16, r16   | r/m16 と r16 との AND をとる。           |
| 21 /r      | AND r/m32, r32   | r/m32 と r32 との AND をとる。           |
| 22 /r      | AND r8, r/m8     | r8 と r/m8 との AND をとる。             |
| 23 /r      | AND r16, r/m16   | r16 と r/m16 との AND をとる。           |
| 23 /r      | AND r32, r/m32   | r32 と r/m32 との AND をとる。           |

| オペコード | 命令            | 説明                                    |
|------------+-----------------+-----------------------------------------|
| 0C ib      | OR AL, imm8     | AL と imm8 との OR をとる。             |
| 0D iw      | OR AX, imm16    | AX と imm16 との OR をとる。            |
| 0D id      | OR EAX, imm32   | EAX と imm32 との OR をとる。           |
| 80 /1 ib   | OR r/m8, imm8   | r/m8 と imm8 との OR をとる。           |
| 81 /1 iw   | OR r/m16, imm16 | r/m16 と imm16 との OR をとる。         |
| 81 /1 id   | OR r/m32, imm32 | r/m32 と imm32 との OR をとる。         |
| 83 /1 ib   | OR r/m16, imm8  | r/m16 と imm8(符号拡張)との OR をとる。 |
| 83 /1 ib   | OR r/m32, imm8  | r/m32 と imm8(符号拡張)との OR をとる。 |
| 08 /r      | OR r/m8, r8     | r/m8 と r8 との OR をとる。             |
| 09 /r      | OR r/m16, r16   | r/m16 と r16 との OR をとる。           |
| 09 /r      | OR r/m32, r32   | r/m32 と r32 との OR をとる。           |
| 0A /r      | OR r8, r/m8     | r8 と r/m8 との OR をとる。             |
| 0B /r      | OR r16, r/m16   | r16 と r/m16 との OR をとる。           |
| 0B /r      | OR r32, r/m32   | r32 と r/m32 との OR をとる。           |

| オペコード | 命令             | 説明                                     |
|------------+------------------+------------------------------------------|
| 34 ib      | XOR AL, imm8     | AL と imm8 との XOR をとる。             |
| 35 iw      | XOR AX, imm16    | AX と imm16 との XOR をとる。            |
| 35 id      | XOR EAX, imm32   | EAX と imm32 との XOR をとる。           |
| 80 /6 ib   | XOR r/m8, imm8   | r/m8 と imm8 との XOR をとる。           |
| 81 /6 iw   | XOR r/m16, imm16 | r/m16 と imm16 との XOR をとる。         |
| 81 /6 id   | XOR r/m32, imm32 | r/m32 と imm32 との XOR をとる。         |
| 83 /6 ib   | XOR r/m16, imm8  | r/m16 と imm8(符号拡張)との XOR をとる。 |
| 83 /6 ib   | XOR r/m32, imm8  | r/m32 と imm8(符号拡張)との XOR をとる。 |
| 30 /r      | XOR r/m8, r8     | r/m8 と r8 との XOR をとる。             |
| 31 /r      | XOR r/m16, r16   | r/m16 と r16 との XOR をとる。           |
| 31 /r      | XOR r/m32, r32   | r/m32 と r32 との XOR をとる。           |
| 32 /r      | XOR r8, r/m8     | r8 と r/m8 との XOR をとる。             |
| 33 /r      | XOR r16, r/m16   | r16 と r/m16 との XOR をとる。           |
| 33 /r      | XOR r32, r/m32   | r32 と r/m32 との XOR をとる。           |

次が、
AND 命令のサンプルプログラムです (図 [[fig:x86arith/and.lst]])。

#+caption: x86arith/and.lst
#+label: fig:x86arith/and.lst
#+include: "code/x86arith/and.lst" src asm

*** 論理命令: NOT

*NOT --- One's Complement Negation* [4-4]

NOT 命令は、
オペランドの値に含まれている各ビットの 0 と 1 を反転します。
ビットごとの論理否定 (logical negation) です (文献 \cite{Intel04:IA32J-1} では「否定論理」と訳されています)。

AND 命令、
OR 命令、
XOR 命令とは異なり、
NOT 命令は 1 つのオペランドだけを取ります。
オペランドにはレジスタまたはメモリロケーションを指定できます。

NOT 命令はステータスフラグレジスタを変化させません。
このため例えば
#+begin_src asm
	movw	$0xffff, %ax
	notb	%ax
#+end_src
を実行するとレジスタ AX の値はゼロになりますが、
ZF フラグは変化しません。

NOT 命令のオペコード表を以下に示します (文献 \cite{Intel04:IA32J-2B} より抜粋)。

| オペコード | 命令      | 説明                         |
|------------+-----------+------------------------------|
| F6 /2      | NOT r/m8  | r/m8 の各ビットを反転する。  |
| F7 /2      | NOT r/m16 | r/m16 の各ビットを反転する。 |
| F7 /2      | NOT r/m32 | r/m32 の各ビットを反転する。 |

次に示すのは、
NOT 命令のサンプルプログラムです (図 [[fig:x86arith/not.lst]])。

#+caption: x86arith/not.lst
#+label: fig:x86arith/not.lst
#+include: "code/x86arith/not.lst" src asm

** シフト命令とローテート命令
<<sec:x86arith/shift>>

[[sec:x86regs/category]] 節で説明したように、
IA-32 アーキテクチャにおける汎用命令のうち、
シフト命令およびローテート命令は以下のように分類されます。

- シフト命令とローテート命令
  - ビットのシフト命令 ★
  - ビットのダブルシフト命令
  - ビットのローテート命令

シフト命令とローテート命令は以下の 9 種類です (文献 \cite{Intel04:IA32J-1} より抜粋)。

| SAR  | Shift arithmetic right                        |
|      | 算術右シフト                                  |
| SHR  | Shift logical right                           |
|      | 論理右シフト                                  |
| SAL  | /SHL Shift arithmetic left/Shift logical left |
|      | 算術左シフト/ 論理左シフト                    |
| SHRD | Shift right double                            |
|      | 右ダブルシフト                                |
| SHLD | Shift left double                             |
|      | 左ダブルシフト                                |
| ROR  | Rotate right                                  |
|      | 右ローテート                                  |
| ROL  | Rotate left                                   |
|      | 左ローテート                                  |
| RCR  | Rotate through carry right                    |
|      | キャリーを通した右ローテート                  |
| RCL  | Rotate through carry left                     |
|      | キャリーを通した左ローテート                  |

以下では、
特に重要なビットのシフト命令を説明します。

*** ビットのシフト命令: SAL、SHL、SAR、SHR

*SAL/SAR/SHL/SHR -- Shift* [4-193]

SAL 命令、
SAR 命令、
SHL 命令、
SHR 命令は、
レジスタもしくはメモリに格納された値を、
指定された数だけ左もしくは右にビットシフトします。

これらの命令はオペランドを 1 つもしくは 2 つ取り、
オペランドが 1 つの場合は、
オペランドに指定された値を 1 ビットだけシフトします。
この場合、
オペランドにはレジスタまたはメモリロケーションを指定できます。

オペランドが 2 つの場合は、
宛先オペランドにビットシフトされる値を、
出所オペランドにビットシフトの回数を指定します。
宛先オペランドにはレジスタまたはメモリロケーションを指定できます。

これまでの他の命令のオペランドの形式から類推すると、
出所オペランドには即値、
レジスタ、
メモリロケーションが指定できそうに思えます。
しかし、
SAL 命令、
SAR 命令、
SHL 命令、
SHR 命令には、
即値か *レジスタ CL のみ* しか指定できません。
レジスタ CL 以外の汎用レジスタは指定できませんし、
メモリロケーションも指定できません。
シフト命令のオペランド指定は特殊なので注意してください。

どれも基本的には単なるビットシフトの命令ですが、
細かな挙動がそれぞれ少しずつ違うため注意が必要です。
命令名の末尾の L は *Left (左シフト)* を、
R は *Right (右シフト)* を意味します。
命令名の中央の H は sHift (単なるシフト→ *論理シフト*) を、
A は *Arithmetic (算術シフト)* を意味します。
また、
論理シフトは *符号なし整数* のためのシフト、
算術シフトは *符号付き整数* のためのシフトです。

つまり、
シフトする方向が左と右で 2 通り、
符号なし整数用と符号付き整数用の 2 通りと、
あわせて 2 $\times$ 2 = 4 通りあります。

まず、
SAL 命令および SHL 命令は、
宛先オペランドの値を、
出所オペランドの値の数だけ左に (LSB から MSB に向けて ([[sec:number/binary]] 節)) ビットシフトします。
計算結果を宛先オペランドに格納します。

SAL 命令と SHL 命令は別のニーモニックが付けられていますが、
実際には同じ命令です。
つまり、
SAL 命令でも SHL 命令でも、
同じ機械語が生成されます。

SAR 命令および SHR 命令は、
末尾の R からわかるように、
シフトする方向が「左」ではなく「右」 (MSB から LSB に向けて) です。

これらの命令によって CF フラグが設定されます。
左シフトの場合、
MSB から最後に追い出されたビットが CF フラグに格納されます。
右シフトの場合、
LSB から最後に追い出されたビットが CF フラグに格納されます。

少しややこしいですが、
OF フラグの変化は命令やシフト回数によって異なります。
1 ビットシフトの場合は、
以下のように設定されます。
2 ビット以上の場合は OF フラグは変化しません。

- SHL/SAL (左シフト)

  シフト後の最上位ビット (MSB) と CF フラグが等しい場合に OF フラグが 1 になります。
  等しくなければ 0 になります。

- SHR (論理右シフト)

  シフト前の最上位ビットの値が OF フラグに格納されます。

- SAR (算術右シフト)

  OF フラグは常に 0 になります。

他のステータスフラグのうち、
フラグ SF/ZF/PF は、
計算結果によって設定されます。
AF フラグの変化は未定義です。

ビットシフト命令の動作を CPU の抽象モデル ([[sec:mem/cpu-model]] 節) で記述すると以下のようになります。
以下では、
ビット単位の左シフトおよび右シフトをそれぞれ ~<<~ および ~>>~ と表記します (C 言語の演算子と同じ表記を用います)。

- レジスタ \r{i} を即値 $c$ の回数だけ左方向にシフトする
  #+begin_quote
  \r{i} ← < ~<<~ > $c$
  #+end_quote

- レジスタ \r{i} をレジスタ \r{j} の回数だけ左方向にシフトする
  #+begin_quote
  \r{i} ← < ~<<~ > \r{j}
  #+end_quote
  レジスタ \r{j} にはレジスタ CL のみが指定できます。

- メモリ $m$ 上の値を即値 $c$ の回数だけ左方向にシフトする
  #+begin_quote
  [$m$] ← < ~<<~ > $c$
  #+end_quote

- メモリ $m$ 上の値をレジスタ \r{i} の回数だけ左方向にシフトする
  #+begin_quote
  [$m$] ← < ~<<~ > \r{i}
  #+end_quote
  レジスタ \r{j} にはレジスタ CL のみが指定できます。

左シフトでは、
(シフトによって最後に押し出された) MSB の値が CF フラグに格納されます。

ビットシフトの例を説明しましょう (図 [[fig:x86arith/shift-left]])。
ここでは、
レジスタの大きさが 8 ビットの場合を考えます。
レジスタ \r{1} に 0b11010110 (= 0xd6) を格納し、
1 ビットだけ左にシフトします。
#+begin_quote
\r{1} ← 0b11010110 \\
\r{1} ← < ~<<~ > 1
#+end_quote

#+caption: 1 ビット左シフトの例
#+label: fig:x86arith/shift-left
[[./figure/x86arith/shift-left.png]]

これにより、
レジスタ \r{1} には 0b10101100 (= 0xac) が格納されます。
元の値 (0b11010110) を左に 1 ビットだけずらして、
最下位ビット (LSB) にはゼロが埋められます。
元の値 (0b11010110) の最上位ビット (MSB) が 1 だったので、
CF フラグが 1 になります。
そして CF フラグの値と最上位ビットが一致しているため、
OF フラグも 1 になります。

同様に、
論理右シフトである SHR 命令の動作を CPU の抽象モデルで記述すると以下のようになります。

- レジスタ \r{i} を即値 $c$ の回数だけ右方向にシフトする
  #+begin_quote
  \r{i} ← < ~>>~ > $c$
  #+end_quote

- レジスタ \r{i} をレジスタ \r{j} の回数だけ右方向にシフトする
  #+begin_quote
  \r{i} ← < ~>>~ > \r{j}
  #+end_quote
  レジスタ \r{j} にはレジスタ CL のみが指定できます。

- メモリ $m$ 上の値を即値 $c$ の回数だけ右方向にシフトする
  #+begin_quote
  [$m$] ← < ~>>~ > $c$
  #+end_quote

- メモリ $m$ 上の値をレジスタ \r{i} の回数だけ右方向にシフトする
  #+begin_quote
  [$m$] ← < ~>>~ > \r{i}
  #+end_quote
  レジスタ \r{j} にはレジスタ CL のみが指定できます。

右シフトでは、
(シフトによって最後に押し出された) LSB の値が CF フラグに格納されます。

先ほどの例と同じように、
右方向へのビットシフトの例を説明します。
レジスタ \r{1} に 0b11010110 (= 0xd6) を格納し、
1 ビットだけ右にシフトします。
#+begin_quote
\r{1} ← 0b11010110 \\
\r{1} ← <>>> 1
#+end_quote

これにより、
レジスタ \r{1} には 0b01101011 (= 0x6b) が格納されます。
元の値 (0b11010110) を右に 1 ビットだけずらして、
最上位ビット (MSB) にはゼロが埋められ、
元の値 (0b11010110) の最下位ビット (LSB) が 0 のため、
CF フラグが 0 になります。
シフト前の最上位ビットの値が 1 だったので、
OF フラグには 1 がセットされます。

算術右シフトである SAR 命令は SHR 命令と同様ですが、
符号ビット (MSB) を保存して、
符号ビット以外のビットの右シフトを行うという点が異なっています。

2 進数の定義 ([[sec:number/binary]] 節) から、
- 左に 1 ビットシフトする = 値を 2 倍する
- 右に 1 ビットシフトする = 値を 1/2 倍する
という関係があることがわかります。
MUL 命令や DIV 命令を用いた整数の乗算や除算よりも、
ここで説明したビットシフト命令のほうが (ハードウェアで実行しなければならない処理がはるかに簡単なので) 圧倒的に高速です。
このため、
乗数や除数が 2 のべき ($2^n$) であれば、
MUL 命令や DIV 命令を使用せずに、
ビットシフト命令を用いることで高速な計算が可能になります。

SAL/SAR/SHL/SHR 命令のオペコード表です (文献 \cite{Intel04:IA32J-2B} より抜粋)。

| オペコード | 命令            | 説明                                    |
|------------+-----------------+-----------------------------------------|
| D0 /4      | SAL r/m8        | r/m8 に 2 を 1 回掛ける。               |
| D2 /4      | SAL r/m8, CL    | r/m8 に 2 を CL 回掛ける。              |
| C0 /4 ib   | SAL r/m8, imm8  | r/m8 に 2 を imm8 回掛ける。            |
| D1 /4      | SAL r/m16       | r/m16 に 2 を 1 回掛ける。              |
| D3 /4      | SAL r/m16, CL   | r/m16 に 2 を CL 回掛ける。             |
| C1 /4 ib   | SAL r/m16, imm8 | r/m16 に 2 を imm8 回掛ける。           |
| D1 /4      | SAL r/m32       | r/m32 に 2 を 1 回掛ける。              |
| D3 /4      | SAL r/m32, CL   | r/m32 に 2 を CL 回掛ける。             |
| C1 /4 ib   | SAL r/m32, imm8 | r/m32 に 2 を imm8 回掛ける。           |
| D0 /7      | SAR r/m8        | r/m8 を 2 で 1 回符号付き除算する。     |
| D2 /7      | SAR r/m8, CL    | r/m8 を 2 で CL 回符号付き除算する。    |
| C0 /7 ib   | SAR r/m8, imm8  | r/m8 を 2 で imm8 回符号付き除算する。  |
| D1 /7      | SAR r/m16       | r/m16 を 2 で 1 回符号付き除算する。    |
| D3 /7      | SAR r/m16, CL   | r/m16 を 2 で CL 回符号付き除算する。   |
| C1 /7 ib   | SAR r/m16, imm8 | r/m16 を 2 で imm8 回符号付き除算する。 |
| D1 /7      | SAR r/m32       | r/m32 を 2 で 1 回符号付き除算する。    |
| D3 /7      | SAR r/m32, CL   | r/m32 を 2 で CL 回符号付き除算する。   |
| C1 /7 ib   | SAR r/m32, imm8 | r/m32 を 2 で imm8 回符号付き除算する。 |
| D0 /4      | SHL r/m8        | r/m8 に 2 を 1 回掛ける。               |
| D2 /4      | SHL r/m8, CL    | r/m8 に 2 を CL 回掛ける。              |
| C0 /4 ib   | SHL r/m8, imm8  | r/m8 に 2 を imm8 回掛ける。            |
| D1 /4      | SHL r/m16       | r/m16 に 2 を 1 回掛ける。              |
| D3 /4      | SHL r/m16, CL   | r/m16 に 2 を CL 回掛ける。             |
| C1 /4 ib   | SHL r/m16, imm8 | r/m16 に 2 を imm8 回掛ける。           |
| D1 /4      | SHL r/m32       | r/m32 に 2 を 1 回掛ける。              |
| D3 /4      | SHL r/m32, CL   | r/m32 に 2 を CL 回掛ける。             |
| C1 /4 ib   | SHL r/m32, imm8 | r/m32 に 2 を imm8 回掛ける。           |
| D0 /5      | SHR r/m8        | r/m8 を 2 で 1 回符号なし除算する。     |
| D2 /5      | SHR r/m8, CL    | r/m8 を 2 で CL 回符号なし除算する。    |
| C0 /5 ib   | SHR r/m8, imm8  | r/m8 を 2 で imm8 回符号なし除算する。  |
| D1 /5      | SHR r/m16       | r/m16 を 2 で 1 回符号なし除算する。    |
| D3 /5      | SHR r/m16, CL   | r/m16 を 2 で CL 回符号なし除算する。   |
| C1 /5 ib   | SHR r/m16, imm8 | r/m16 を 2 で imm8 回符号なし除算する。 |
| D1 /5      | SHR r/m32       | r/m32 を 2 で 1 回符号なし除算する。    |
| D3 /5      | SHR r/m32, CL   | r/m32 を 2 で CL 回符号なし除算する。   |
| C1 /5 ib   | SHR r/m32, imm8 | r/m32 を 2 で imm8 回符号なし除算する。 |

以下に示すのは、
SHL 命令および SAL 命令のサンプルプログラムです。

#+caption: x86arith/shl.lst
#+label: fig:x86arith/shl.lst
#+include: "code/x86arith/shl.lst" src asm

また、
SHR 命令および SAR 命令のサンプルプログラムです。

#+caption: x86arith/shr.lst
#+label: fig:x86arith/shr.lst
#+include: "code/x86arith/shr.lst" src asm

** 章末問題
<<sec:x86arith/quiz>>

1. 123 + 456 を計算するアセンブリ言語プログラムを示せ。

2. (123 + 456) / 78 を計算するアセンブリ言語プログラムを示せ。

3. 789 / (123 + 456) を計算するアセンブリ言語プログラムを示せ。

4. (12 + 34) / (5 - 6) \times (7 - 89) を計算するアセンブリ言語プログ
   ラムを示せ。

   #+begin_answer
   1.〜4. をまとめて記述したプログラムのアセンブル結果: ~ex.lst~ (図
   [[fig:x86arith/ex/ex.lst]])
   #+caption: x86arith/ex/ex.lst
   #+label: fig:x86arith/ex/ex.lst
   #+include: "code/x86arith/ex/ex.lst" src asm
   #+end_answer

5. レジスタ EAX の値 (符号なし整数) を 4 倍するアセンブリ言語プログ
   ラムを示せ。ただし、(1) ADD 命令のみ、(2) MOV 命令と MUL 命令、(3)
   MOV 命令と SHL 命令のみ、の 3 種類で記述すること。

   #+begin_answer
   プログラムの例: ~mul.lst~ (図 [[fig:x86arith/ex/mul.lst]])
   #+caption: x86arith/ex/mul.lst
   #+label: fig:x86arith/ex/mul.lst
   #+include: "code/x86arith/ex/mul.lst" src asm
   #+end_answer

6. レジスタ EAX の値の 2 の補数を計算するアセンブリ言語プログラムを示
   せ。

   #+begin_answer
   プログラムの例: ~2-comp.lst~ (図 [[fig:x86arith/ex/2-comp.lst]])
   #+caption: x86arith/ex/2-comp.lst
   #+label: fig:x86arith/ex/2-comp.lst
   #+include: "code/x86arith/ex/2-comp.lst" src asm
   #+end_answer

