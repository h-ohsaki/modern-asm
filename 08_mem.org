# -*- Org -*-
# 
# Copyright (c) 2021, Hiroyuki Ohsaki.
# All rights reserved.
# 

# This document is licensed under a Creative Commons
# Attribution-NonCommercial-ShareAlike 4.0 International License (CC
# BY-NC-SA 4.0).

# This document is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# Creative Commons License for more details.

# You should have received a copy of the license along with this work.
# If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

* コンピュータの構造: メモリと CPU の抽象モデル
<<ch:mem>>

** いろいろなメモリ
<<sec:mem/type>>

[[ch:cpu]] 章で述べたように、
フォン・ノイマン型コンピュータは *プログラム内蔵型コンピュータ* です。
メモリ内にコンピュータが実行するプログラムと、
そのプログラムが利用するデータが格納 (= 内蔵) されています。

CPU は、
その内部にある ALU とレジスタを駆使して処理を実行します。
レジスタは CPU 内部にあるため、
極めて高速にアクセスできます。
レジスタに格納している値を読み出すのも、
レジスタに値を格納するのも非常に高速です。

しかし、
その高速性の代償として、
CPU は非常に少量のレジスタしか持っていません。
レジスタは一種のメモリですが、
高速なメモリを CPU 内部に大量に持つことは、
技術的・経済的に困難だからです。
そのため、
プログラム本体や、
プログラム実行に必要なデータをすべてレジスタには格納できません。
プログラム本体や、
プログラム実行に必要なデータは、
レジスタではなく、
CPU 外部のメモリに保存されます (図 [[fig:cpu/computer]])。

ここで、
少し「メモリ」という言葉を整理しましょう。

本来 *メモリ (memory)* という言葉は、
単に記憶装置を意味し、
コンピュータにおいては、
情報を格納する装置をメモリと呼びます。

フォン・ノイマン・アーキテクチャでは、
メモリは 1 つしかありません (図 [[fig:cpu/computer]])。
CPU とメモリがバスで接続されていて、
CPU はメモリからデータを読み出したり、
メモリにデータを書き込んだりすることにより処理を実行します。
コンピュータの基本的な原理や、
アセンブリ言語によるプログラミングの基礎を学ぶだけであれば、
この「メモリ」だけを考えれば十分です。

とはいえ、
最近のコンピュータはさまざまなメモリを搭載しています (図 [[fig:mem/memory]])。
メモリという言葉には記憶装置という意味しかないため、
CPU 内部のレジスタも一種のメモリだといえますし、
さらに、
現在使用されている CPU のほとんどは、
メモリアクセスを高速化するために、
最近アクセスされたメモリの内容を一時的に保存しておく *キャッシュメモリ (cache memory)* というものも持っています。

#+caption: さまざまなメモリ
#+label: fig:mem/memory
#+attr_latex: :width \columnwidth
[[./figure/mem/memory.png]]

多くのコンピュータには、
ハードディスクや SSD (Solid State Drive) のような *外部記憶装置 (external storage)* も搭載されています。
フォン・ノイマン・アーキテクチャには、
もともと外部記憶装置という概念は含まれていません。
一方、
最近のコンピュータの多くは、
プログラムそのものや、
プログラムの入力データ・出力データを保存するための外部記憶装置を持ちます。
外部「記憶装置」という名前が表すように、
これらもメモリの一種です。

このように、
突き詰めればさまざまなものがメモリの一種となってしまいますが、
本書を含めて、
文章やリファレンスなどで「メモリ」という言葉が実際に何を差すのかは、
文脈によって異なります。
注意してください。

*** メモリの階層構造

コンピュータにおけるメモリは階層構造になっています。
CPU に一番近いメモリは *一次ストレージ (primary storage)* と呼ばれ、
その次に近いメモリは *二次ストレージ (secondary storage)* と呼ばれることがあります。

フォン・ノイマン・アーキテクチャにおけるメモリは、
一次ストレージのメモリに相当します。
一次ストレージのメモリは、
他と区別するために *主記憶装置 (main memory)* と呼ばれます。
例えば、
コンピュータが搭載している、
8G バイトや 16G バイトなどのメモリが主記憶装置です。
本書では、
単に「メモリ」と表記していれば、
それはほとんどの場合主記憶装置のことを指します。

SSD やハードディスクは二次ストレージのメモリに相当します。
二次ストレージのメモリは主記憶装置と区別して、
*外部記憶装置 (auxiliary memory)* と呼ばれます。

以上が、
コンピュータを構成する主要なメモリです。
以下の 4 つを正しく理解しましょう。
- レジスタ
- キャッシュメモリ
- 主記憶装置
- 外部記憶装置

*** その他のメモリ

IA-32 アーキテクチャの CPU を搭載するコンピュータの場合、
これら 4 種類のメモリ以外にも、
さまざまなメモリが搭載されています。

例えば、以下のようなものが挙げられます。

- BIOS

  *BIOS (Basic Input/Output System)* とは、
  コンピュータの電源投入時に自動的に実行されるプログラムです。
  BIOS は、
  キーボードやディスプレイを初期化し、
  ハードディスクや SSD の最初のセクタを読み出して、
  オペレーティングシステムを起動します。
  BIOS は ROM やフラッシュメモリに格納されています。

- CMOS

  *CMOS (Complementary Metal-Oxide Semiconductor)* とはハードウェアの設定情報や時計の現在時刻を保存するための小容量の RAM です。
  CMOS とは、
  もともとは半導体素子の構造を表す名称です。

- VRAM

  *VRAM (Video RAM)* とは、
  出力デバイスの一種であるビデオカード上に存在する、
  ディスプレイに描画される内容を保持している RAM であり、
  フレームバッファとも呼ばれます。
  例えば、
  VRAM の内容をすべてゼロにして、
  ビデオカードに描画指示を出せば、
  通常、
  ディスプレイの表示が真っ黒になります。

アセンブリ言語によるプログラミングでは、
このようなさまざまなメモリはそれほど重要ではありませんが、
「コンピュータには、
レジスタと、
キャッシュメモリ、
主記憶装置、
外部記憶装置以外にもさまざまななメモリがある」ということは理解しておいてください。

それでは、
コンピュータにおける主記憶装置の話に戻りましょう。

** メモリのアドレスとアドレスマップ
<<sec:mem/memory>>

*メモリ (memory)* とは、
コンピュータの記憶をつかさどる LSI です。
通常、
メモリは、
バイトやワードなどの単位で自由にアクセスできます。
メモリに使用する半導体の種類やコンピュータのアーキテクチャにもよりますが、
一般に、
メモリには数 M バイト〜数 G バイト程度の大量の情報を格納できます。

メモリのどの部分をアクセスするかは、
*アドレス (address)* によって指定します。
英語の address とは「住所」の意味です。
アドレス帳の「アドレス」と同じ意味です。

メモリのアドレスは、
通常、
0 から始まる非負整数で表現されます。
アドレスの上限はコンピュータのアーキテクチャによって決まります。
例外もありますが、
多くの場合、
アドレスの上限はレジスタの大きさで決まります。
レジスタの大きさが 16 ビットであれば、
レジスタで表現できるアドレスは 0〜$2^{16} - 1$ (= 0xffff) となります。
同様に、
レジスタの大きさが 32 ビットであれば、
レジスタで表現できるアドレスは 0〜$2^{32} -1$ (= 0xffff ffff) となります。
日常生活で使われる住所は「兵庫県三田市学園 1-2-3」のように表記されます。
一方、
メモリのアドレスは 0x1234 5678 のような整数で表記されます。

#+begin_note
メモリのアドレスは *番地* とも呼ばれます。
#+end_note

あるアドレスから別のアドレスまでの範囲を、
*アドレス空間 (address space)* と呼びます。
アドレス空間は、
図 [[fig:mem/map]] のように *アドレスマップ (address map)* として図示されます。
この例では、
アドレスが 0x0000 0000 から 0xffff ffff までの 32 ビットのアドレス空間を、
下位アドレスが上に、
上位アドレスが下になるように図示しています。

#+caption: メモリのアドレスマップの表記法 (上から下)
#+label: fig:mem/map
#+attr_latex: :width .5\columnwidth
[[./figure/mem/map.png]]

アドレスマップを図示する方法として、
これとは逆のパターンもあります (図 [[fig:mem/map-rev]])。
図 [[fig:mem/map]] と同じように、
この例でも、
アドレスが 0x0000 0000 から 0xffff ffff までの 32 ビットのアドレス空間を示しています。
ただし、
先ほどの例とは逆で、
下位アドレスが下に、
上位アドレスが上になるように図示されています。

#+caption: メモリのアドレスマップの表記法 (下から上)
#+label: fig:mem/map-rev
#+attr_latex: :width .5\columnwidth
[[./figure/mem/map-rev.png]]

アドレスマップを図示する場合に、
両方の表記法が用いられるので注意が必要です。
アドレスマップを読むときには、
どちらの表記法が使われているのかを確認しましょう。
本書では、
図 [[fig:mem/map]] (上から下) の表記法を用います。

コンピュータのアーキテクチャにもよりますが、
一般に、
メモリはバイト単位もしくはワード単位で参照できます。
バイト単位でアクセスできるメモリの例を図 [[fig:mem/map-detail]] に示します。
この図は、
アドレス 0x0000 0000 から 0x0000 0007 までの先頭 8 バイトを示しています。
この例では、
アドレスの単位は「バイト」です。
それぞれのアドレスに 1 バイト (= 8 ビット) の情報を格納できます。

#+caption: メモリの例
#+label: fig:mem/map-detail
#+attr_latex: :width .5\columnwidth
[[./figure/mem/map-detail.png]]

** リトルエンディアンとビッグエンディアン
<<sec:mem/endianness>>

コンピュータにおいて、
数値をメモリに書き込むときの順番を *エンディアンネス (endianness)* と呼びます。

例えば、
32 ビットの整数 0x1234 5678 (10 進数で 305 419 896) をバイト (8 ビット) 単位でメモリに格納することを考えます。
32 ビットの整数 0x1234 5678 は 0x12、
0x34、
0x56、
0x78 の 4 バイトで構成されます。
これらの 4 バイトを、
上位ビットのものから順番に
#+begin_quote
0x12、0x34、0x56、0x78
#+end_quote
のように格納する方法を *リトルエンディアン (little-endian)* と呼びます。
逆に、下位ビットのものから順番に
#+begin_quote
0x78、0x56、0x34、0x12
#+end_quote
のように格納する方法を *ビッグエンディアン (big-endian)* と呼びます。

エンディアンネスは CPU によってそれぞれ異なります。
インテルの IA-32 アーキテクチャの CPU はすべてリトルエンディアンですが、
通信の世界では主にビッグエンディアンが使われており、
例えば TCP/IP ネットワークの通信プロトコルはビッグエンディアンを使う決まりになっています。
そのため、
通信プロトコルにおける (ビッグエンディアンの) バイトの格納順序は *ネットワークオーダ (network order)* とも呼ばれています。

「リトルエンディアンとビッグエンディアンの、
どちらが優れているのだろう?」
と疑問を持つと思いますが、
特に優劣はありません。
リトルエンディアン、
ビッグエンディアン、
それぞれに利点・欠点があります。
例えば、
リトルエンディアンの利点・欠点は以下のようなものです。

- 利点: 大きさ (ビット数) の異なる数値が混在するプログラムが簡単に書ける

  リトルエンディアンでは、
  32 ビット、
  16 ビット、
  8 ビットなど、
  大きさの数の異なる数値が混在するプログラムを簡単に書けます。

  例えば、
  リトルエンディアンで、
  0x8000 番地に 32 ビットの値である 0x1234 5678 を格納すると、
  0x8000 番地が 0x78、
  0x8001 番地が 0x56、
  0x8002 番地が 0x34、
  0x8003 番地が 0x12 になります。

  8 ビット幅のレジスタで読み出したい場合は、
  何も考えずに 0x8000 番地から読み出せば、
  下位 8 ビットの 0x78 が読み出せます。

  16 ビット幅のレジスタで読み出したい場合は、
  これも何も考えずに 0x8000 番地から読み出せば、
  下位 16 ビットの 0x5678 が読み出せます。

  ビッグエンディアンの場合、
  - 8 ビット幅のレジスタで読み出す場合は 0x8003 番地から読み出す
  - 16 ビット幅のレジスタで読み出す場合は 0x8002 番地から読み出す
  のように、
  値のビット数に応じて読み出し番地をそのつど変える必要があります。

- 欠点: メモリの 16 進ダンプを理解しづらい

  リトルエンディアンでは、
  メモリの内容を 16 進数でダンプしたときに、
  格納した値が逆順に表示されるので理解しづらいという  欠点があります。

  上と同じように、
  リトルエンディアンで、
  0x8000 番地に 32 ビットの値である 0x1234 5678 を格納すると、
  0x8000 番地が 0x78、
  0x8001 番地が 0x56、
  0x8002 番地が 0x34、
  0x8003 番地が 0x12 になります。

  このとき、0x8000 番地からメモリをダンプすると
  #+begin_src raw
  0x8000: 78 56 34 12
  #+end_src
  のように表示されます。
  「78 56 34 12」という 16 進数の列を見て、
  「この計算機はリトルエンディアンだから、
  78 56 34 12 は 0x1234 5678 を意味する」というのを頭の中で読み変える必要があります。

  ビッグエンディアンの場合は、
  0x8000 番地からメモリをダンプすると
  #+begin_src raw
  0x8000: 12 34 56 78
  #+end_src
  のように表示されます。
  0x1234 5678 が格納されているのが一目でわかります。

基本的に、
ビッグエンディアンの利点・欠点は、
リトルエンディアンの利点・欠点の裏返しです。
ビッグエンディアンの利点・欠点は
- 利点: メモリの 16 進ダンプを理解しやすい
- 欠点: 大きさ (ビット数) の異なる数値が混在するプログラムを書くのが面倒
となります。

** データの大きさを表す用語
<<sec:mem/data-size>>

[[sec:number/binary]] 節で述べたように、
コンピュータが扱うデータの単位として、
通常、
ビットやバイトが用いられます。

ただし、
ビットやバイトだけでは不便であるため、
アセンブリ言語プログラミングでは、
さまざまなデータの大きさを表す用語が用いられます。
例えば、
IA-32 アーキテクチャでは、
*ワード (word)* という言葉が 16 ビットを意味し、
*ダブルワード (double word)* は 32 ビットを意味します。

ただし、
残念なことに、
コンピュータのアーキテクチャが違ったり、
アセンブリ言語や高級言語が違ったりすると、
データの大きさを表す用語の意味が異なります。

例えば、
C 言語において *ロング (long)* と言えば、
それは ~long int~ 型を意味します。
C 言語における ~long int~ 型は、
C 言語の規格によって 32 ビット以上であることが定められています。
しかし実際の処理系 (C コンパイラ) が ~long int~ 型を何ビットで実現しているかは、
その処理系によります。
通常、
32 ビット環境では ~long int~ 型は 32 ビットであり、
64 ビット環境では ~long int~ 型は普通は 64 ビットです。
ただし、
実際に何ビットかはその処理系によります。

GNU アセンブラ (GAS) においてロング (long) と言えば、
それは ~int~ と呼ばれるデータサイズを意味します。
~int~ が何ビットなのかは、
GAS が対象とするコンピュータによります。
対象とするコンピュータが IA-32 アーキテクチャの場合、
~int~ は 32 ビットを意味します。

このように、
同じ用語であっても、
文脈によって違うデータサイズを意味します。
ここでは
- C 言語
- IA-32 アーキテクチャ
- GNU アセンブラ
におけるデータ型の大きさを示します。

まず、
C 言語における *データ型 (data type)* の大きさを表 [[fig:c-data-type]] に示します。
C 言語における *型名 (type name)* と、
それぞれの型の最小ビット数、
IA-32 アーキテクチャ (x86) における典型的なビット数、
IA-32 アーキテクチャの 64 ビット拡張 (x86-64) における典型的なビット数を示しています。

#+caption: C 言語におけるデータ型の大きさ
#+label: fig:c-data-type
| 型名                                                             | 最小ビット数 | x86 | x86-64 |
|------------------------------------------------------------------+--------------+-----+--------|
| char                                                             |            8 |   8 |      8 |
| signed char                                                      |            8 |   8 |      8 |
| unsigned char                                                    |            8 |   8 |      8 |
| short, short int, signed short, signed short int                 |           16 |  16 |     16 |
| unsigned short, unsigned short int                               |           16 |  16 |     16 |
| int, signed, signed int                                          |           16 |  32 |     32 |
| unsigned, unsigned int                                           |           16 |  32 |     32 |
| long, long int, signed long, signed long int                     |           32 |  32 |     64 |
| unsigned long, unsigned long int                                 |           32 |  32 |     64 |
| long long, long long int, signed long long, signed long long int |           64 |  64 |     64 |
| unsigned long long, unsigned long long int                       |           64 |  64 |     64 |
| float                                                            |           32 |  32 |     32 |
| double                                                           |           64 |  64 |     64 |
| long double                                                      |           80 |  96 |    128 |

C 言語の規格では、
各型の最小のビット数と、
それぞれの型のビット数の大小関係のみが規定されており、
実際のビット数はそれぞれの処理系によって異なります。
そのため、
この表では、
一般的な C コンパイラにおける、
それぞれの型のデータサイズを示しています。

次に、
IA-32 アーキテクチャにおける *基本データ型 (basic data type)* の大きさを表 [[fig:ia32-data-type]] に示します。
データ型の名称と、
その名称が表すバイト数およびビット数を示しています。

#+caption: IA-32 アーキテクチャにおける基本データ型
#+label: fig:ia32-data-type
| 名称                                    | バイト数 | ビット数 |
|-----------------------------------------+----------+----------|
| バイト (byte)                           |        1 |        8 |
| ワード (word)                           |        2 |       16 |
| ダブルワード (double word)              |        4 |       32 |
| クワッドワード (quad word)              |        8 |       64 |
| ダブルクワッドワード (double quad word) |       16 |      128 |
| 単精度 (single precision)               |        4 |       32 |
| 倍精度 (double precision)               |        8 |       64 |
| 拡張倍精度 (extended double precision)  |       10 |       80 |

まず、
IA-32 アーキテクチャでは「1 ワードは 16 ビット」と定められています。
そして他のデータ型は、
「ワードの何倍か?」
という考え方で名称が付けられています。
32 ビットはワード (16 ビット) の 2 倍 (double) なので *ダブルワード (double word)* と呼ばれ、
64 ビットはワード (16 ビット) の 4 倍 (quad) なので *クワッドワード (quad word)* と呼ばれます。
同じく、
128 ビットはクワッドワード (64 ビット) の 2 倍なので *ダブルクワッドワード (double quad word)* と呼ばれます。
浮動小数点数は、
IEEE 754 の浮動小数点表現 ([[sec:floating-point-nubmer]] 節) と同じ名称およびデータサイズです。

C 言語におけるデータ型と IA-32 アーキテクチャにおける基本データ型は同じような用語を使っていますが、
意味が異なるため注意が必要です。
C 言語におけるデータ型は、
データを格納する「変数の型」を意味しますが、
一方 IA-32 アーキテクチャにおける基本データ型は、
まとまった「データの大きさ」に付けられた名称です。
例えば、
C 言語における ~short~ は変数の型を表しており、
~short~ 型の変数は、
多くの処理系では 16 ビットで表現されています。
しかし IA-32 アーキテクチャにおける「ワード」はデータの大きさを表すため、
ワードは、
16 ビット (2 バイト) を意味します。

最後に、
GNU アセンブラ (GAS) で用いられるデータ型を表 [[fig:gas-data-type]] に示します。
GAS におけるデータの大きさの名称と、
それぞれの意味、
そして IA-32 アーキテクチャにおけるビット数と、
命令のニーモニックの接尾部 ([[sec:gas/syntax]] 節) を示しています。

#+caption: GNU アセンブラ (GAS) におけるデータ型
#+label: fig:gas-data-type
#+attr_latex: :environment maxtabular
| 名称          | 意味                       | IA-32におけるビット数 | 接尾部(サフィックス) |
|---------------+----------------------------+-------+--------|
| byte          | 8ビット                    | ←    | b      |
| word, short   | コンピュータの word と同じ | 16    | w      |
| int, long     | コンピュータの int と同じ  | 32    | l      |
| quad          | 64ビット                   | ←    | q      |
| octa          | 128ビット                  | ←    |        |
| float, single | 単精度                     | 32    | s      |
| double        | 倍精度                     | 64    | d      |
| 2byte         | 16ビット                   | ←    |        |
| 4byte         | 32ビット                   | ←    |        |
| 8byte         | 64ビット                   | ←    |        |

[[ch:gas]] 章で述べるように、
GAS は多数の CPU やアーキテクチャをサポートしています。
このため、
GAS における ~short~ が何ビットを表すかは、
GAS が対象とするコンピュータによります。
GAS における ~word~ や ~short~ (~word~ の別名) は、
対象とするコンピュータの word と同じサイズとなり、
また、
GAS における ~int~ や ~long~ (~int~ の別名) は、
対象とするコンピュータの int と同じサイズになります。

ここからは、
特によく用いられるデータの大きさを表す用語を説明します。

**** バイト (byte)

通常、
1 バイトは 8 ビットを意味します。
[[sec:number/binary]] 節で述べたように、
1 バイトが 8 ビットではないコンピュータも存在しますが、
ほとんどの場合、
1 バイトは 8 ビットです。
データの大きさが 1 バイトの場合、
エンディアンネス ([[sec:mem/endianness]] 節) も問題になりません (エンディアンネスを考える必要があるのは 2 バイト以上の場合です)。

#+begin_quote
要点: 「バイト」は 8 ビットを意味する (ただし例外あり)
#+end_quote

**** ワード (word)

一般的には、
コンピュータが取り扱うデータの単位を *ワード (word)* と呼びます。
日本語では、
カタカナで表記して「ワード」と呼んだり、
漢字で「語」と呼んだりします。
コンピュータが取り扱うデータの単位なので、
1 ワードが何バイトかは、
そのコンピュータの CPU やアーキテクチャによります。

IA-32 アーキテクチャの CPU の場合、
CPU のレジスタの大きさは 32 ビットですが、
レジスタやメモリにアクセスする単位は、
8 ビット、
16 ビット、
32 ビットのいずれも可能です。
「こういったコンピュータでは、
取り扱うデータの単位はいくつだろう?」
と疑問に思いますが、
IA-32 アーキテクチャでは、
表 [[fig:ia32-data-type]] のようにデータの大きさの用語を定めています。

「ワード」が何ビットを意味するかはコンピュータによって異なりますが、
「1 ワード = 16 ビット」のことが多いようです。
ただし、
ARM アーキテクチャ ([[ch:arm]] 章) のように、
ワードが 32 ビットを表すこともあります。

「1 ワード = 16 ビット」の場合には、
エンディアンネスにも注意する必要があります。
「ワード」はデータの大きさを表しているだけで、
データをメモリに格納するときのエンディアンネスは表していません。

#+begin_quote
要点: 多くの場合、
「ワード」は 16 ビットを意味する
#+end_quote

**** ショート (short)

C 言語で *ショート (short)* と言えば ~short int~ 型を意味します。
~short int~ 型は 16 ビット以上であることが規格で定められています。
幸いなことに、
多くの処理系 (C コンパイラ) では ~short int~ は 16 ビットのようです。

GAS では、
~short~ は ~word~ の別名です。
GAS の ~short~ が何ビットを意味するかも、
GAS が対象とするコンピュータによって異なります。
IA-32 アーキテクチャの場合は「ワード」が 16 ビットなので、
GAS における ~short~ も 16 ビットを意味します。

ショートも、
ワードと同じようにデータの大きさのみを表しています。
エンディアンネスは表していません。

#+begin_quote
要点: 多くの場合、
「ショート」は 16 ビットを意味する
#+end_quote

**** ロング (long)

C 言語で *ロング (long)* と言えば ~long int~ 型を意味します。
~long int~ 型は 32 ビット以上であることが規格で定められていますが、
実際に何ビットかは環境によります (図 [[fig:c-data-type]])。
とはいえ通常、
32 ビット環境であれば 32 ビット、
64 ビット環境であれば 64 ビットです。

GAS では、
~long~ は ~int~ の別名です。
GAS の ~int~ が何ビットを意味するのかも、
GAS が対象とするコンピュータによって異なります。
IA-32 アーキテクチャの場合は int が 32 ビットなので、
GAS における ~int~ は 32 ビットを意味します。

なおロングも、
ワードやショートと同じようにデータの大きさのみを表しており、
エンディアンネスは表していません。

#+begin_quote
要点: 多くの場合、
「ロング」は 32 ビット (32 ビット環境の場合) または 64 ビット (64 ビット環境の場合) を意味する
#+end_quote

**** シングル (single)

ショートやロングと似た単語ですが、
*シングル (single)* は整数ではなく、
浮動小数点数のデータの大きさを表すことが多いようです。
浮動小数点数の精度を表す *単精度 (single precision)* の single (シングル) です。
C 言語でも、
IA-32 アーキテクチャでも、
GAS でも、
「シングル」と言えば単精度の浮動小数点数を意味します。

#+begin_quote
要点: 「シングル」は単精度の浮動小数点数を意味する
#+end_quote

**** ダブル (double)

*ダブル (double)* は少し注意が必要です。

シングルの場合と同じように、
多くの場合、
ダブルと言えば、
それは *倍精度の浮動小数点数* を意味します。
倍精度 (double precision) の double (ダブル) です。
C 言語でも、
GAS でも、
「ダブル」と言えば倍精度の浮動小数点数を意味します。

ただし、
IA-32 アーキテクチャでは、
ダブルと言えば、
「ダブルワード (double word)」もしくは「倍精度 (double precision)」のどちらかを意味します。
整数のデータサイズの話をしているのか、
浮動小数点数のデータサイズの話をしているのかによって、
「ダブル」の意味が異なります。

また、
ややこしいことに、
ARM アーキテクチャ ([[ch:arm]] 章) のように、
「ダブルワード」が 64 ビットを表す場合もあります。

#+begin_quote
要点: ダブルは倍精度の浮動小数点数を意味することが多いが、
ダブルワード (32 ビットや 64 ビット) のことかもしれない
#+end_quote

以上をまとめると以下のとおりです。

#+attr_latex: :environment maxtabular
| 名称              | データサイズ(ビット数)                                                          |
|-------------------+---------------------------------------------------------------------------------|
| バイト (byte)     | 8 ビット (例外あり)                                                             |
| ワード (word)     | 多くの場合、16 ビット                                                           |
| ショート (short)  | 多くの場合、16 ビット                                                           |
| ロング (long)     | 32 ビット環境では 32 ビット、64 ビット環境では 64 ビット (例外あり)             |
| シングル (single) | 単精度浮動小数点数 32 ビット                                                    |
| ダブル (double)   | 倍精度浮動小数点数 64 ビット (ダブルワード (32 ビットや 64 ビット)かもしれない) |

** CPU 処理の抽象モデル
<<sec:mem/cpu-model>>

フォン・ノイマン・アーキテクチャのコンピュータの動作を、
CPU の処理を *抽象化したモデル* を用いて説明しましょう。

結局のところ、CPU ができるのは、
- レジスタに定数を代入する
- レジスタに、他のレジスタの値をコピーする
- メモリに格納されている値をレジスタに読み込む
- レジスタに格納されている値をメモリに書き込む
- レジスタを用いて算術演算・論理演算を行う
- 直前の算術演算・論理演算の結果に応じてプログラムカウンタを変更する
くらいです。

それぞれの処理を記号を用いて説明します。

$i$ 番目の *レジスタ* を \r{i}、
*定数* を $c$ と表記します。
レジスタが 8 個あれば、
それらのレジスタを \r{1}〜\r{8} と表記します。
また、
定数 $c$ を *アドレス* と見なし、
そのアドレスに格納されている値を [$c$] と表記します。
このため、
例えば、
[0x1234] はメモリの 0x1234 番地に格納されている値を意味します。

- レジスタに定数を代入する
  #+begin_quote
  \r{i} ← $c$
  #+end_quote

  例: レジスタ \r{1} に 0x7a を代入する
  #+begin_quote
  \r{1} ← 0x7a
  #+end_quote

- レジスタに、他のレジスタの値を代入する

  #+begin_quote
  \r{i} ← \r{j}
  #+end_quote

  例: レジスタ \r{1} に、レジスタ \r{2} の値を代入する
  #+begin_quote
  \r{1} ← \r{2}
  #+end_quote

- メモリに格納されている値をレジスタに読み込む

  #+begin_quote
  \r{i} ← [$c$]
  #+end_quote

  例: レジスタ \r{1} に、メモリの 0x1234 番地に格納されている値を読み込む
  #+begin_quote
  \r{1} ← [0x1234]
  #+end_quote

  メモリから読み出すアドレスは、他のレジスタの値で指定することもできます。
  #+begin_quote
  \r{i} ← [\r{j}]
  #+end_quote

  例: レジスタ \r{1} に、メモリの \r{2} 番地 (レジスタ \r{2} に格納されている
  値のアドレス) に格納されている値を読み込む
  #+begin_quote
  \r{1} ← [\r{2}]
  #+end_quote

- レジスタに格納されている値をメモリに書き込む

  #+begin_quote
  [$c$] ← \r{i}
  #+end_quote

  例: レジスタ \r{1} の値を、メモリの 0x1234番地に書き込む
  #+begin_quote
  [0x1234] ← \r{1}
  #+end_quote

  メモリに書き込むアドレスは、他のレジスタの値で指定することもできます。
  #+begin_quote
  [\r{j}] ← \r{i}
  #+end_quote

  例: レジスタ \r{1} の値を、メモリの \r{2} 番地 (レジスタ \r{2} に格納されて
  いる値のアドレス) に書き込む
  #+begin_quote
  [\r{2}] ← \r{1}
  #+end_quote

- レジスタを用いて *算術演算・論理演算* を行う

  #+begin_quote
  \r{i} ← <op> $c$
  #+end_quote

  ここで op は算術演算・論理演算の *演算子 (operator)* です。
  例えば、
  op は + (加算)、- (減算)、
  ~&~ (論理積)、
  ~|~ (論理和) などです。
  「\r{i} op c を計算し、
  計算結果を \r{i} に格納する」ことを意味します。

  例: レジスタ \r{1} に 0x3f を加える
  #+begin_quote
  \r{1} ← <+> 0x3f
  #+end_quote

  *オペランド (operand; 被演算子)* にレジスタを指定することもできます。
  #+begin_quote
  \r{i} ← <op> \r{j}
  #+end_quote

  例: レジスタ \r{1} に、レジスタ \r{2} の値を加える
  #+begin_quote
  \r{1} ← <+> \r{2}
  #+end_quote

  被演算子にメモリに格納されている値を用いることもできます。
  #+begin_quote
  \r{i} ← <op> (c)
  #+end_quote

  例: レジスタ \r{1} から、
  メモリの 0x1234 番地に格納されている値を引く
  #+begin_quote
  \r{1} ← <-> [0x1234]
  #+end_quote

さらに、
プログラムカウンタとフラグレジスタを導入します。

*プログラムカウンタ (program counter)* は \pc と表記し、
「CPU が次に実行する命令が格納されているアドレス」を格納しています。
例えば、
多くの CPU では、
CPU 起動後の \pc の値は 0 であり、
CPU はメモリの 0 番地に格納されているプログラムを読み込んで実行します。
命令語の大きさを 2 とすれば、
最初の命令の読み出し後に \pc の値が 2 になります。
このため、
CPU は次にメモリの 2 番地に格納されているプログラムを読み込んで実行します。

*フラグレジスタ (flag register)* としては \zf (ゼロフラグ) と \sf (符号フラグ) を考えます。
なお、
これらのフラグレジスタは、
直前の算術演算や論理演算によって、
以下のように自動的に設定されるとします。

まず \zf は以下のように設定されます。
- 直前の算術演算や論理演算の結果がゼロであれば \zf = 1 となる
- 逆に、ゼロでなければ \zf = 0 となる

同様に、\sf は以下のように設定されます。
- 直前の算術演算や論理演算の結果が負であれば \sf = 1 となる
- 逆に、負でなければ (正またはゼロであれば) \sf = 0 となる

これらの記号を用いて、
CPU の処理をさらに説明します。

- プログラムカウンタを変更する (ジャンプする)

  CPU が次に実行する命令が格納されているアドレスである \pc を書き換えることにより、
  プログラムの実行を制御できます。
  プログラムの実行が特定のアドレスに移るので、
  *ジャンプ (jump)* と呼ばれます。
  #+begin_quote
  \pc ← $c$
  #+end_quote

  例: 0x1234 番地にジャンプする
  #+begin_quote
  \pc ← 0x1234
  #+end_quote

- 直前の算術演算・論理演算の結果に応じてプログラムカウンタを変更する

  先ほどのジャンプと同じですが、
  ある特定の条件を満たした場合のみジャンプします。
  直前の算術演算・論理演算の結果に応じて、
  \zf や \sf が設定されていることを利用します。
  #+begin_quote
  \pc ← $c$ if $cond$
  #+end_quote

  $cond$ は *条件 (condition)* を表します。
  $cond$ に指定した条件が満たされた場合にのみ \pc を変更します。
  $cond$ の例を以下に示します。
  - \zf == 0
  - \zf == 1
  - \sf == 0
  - \sf == 1

  例: レジスタ \r{1} と \r{2} が等しければ 0x1234 番地にジャンプ
  #+begin_quote
  \r{1} ← <-> \r{2} \\
  \pc ← 0x1234 if \zf == 0
  #+end_quote

CPU のアーキテクチャによってはもっと複雑な処理ができるものもありますが、
上で説明した処理が CPU の基本となっています。

#+begin_note
ここでは、
説明の簡単化のため、
レジスタ \r{i} や定数 $c$ の記憶領域の大きさ (ビット数) は考慮していません。

実際には、
例えば、
レジスタ \r{1} の大きさが 16 ビットであれば、
#+begin_quote
\r{1} ← 0x1234
#+end_quote
における定数 0x1234 も 16 ビットであることが一般的です。

同様に、
レジスタ \r{1} の大きさが 16 ビットであれば、
#+begin_quote
\r{1} ← [0x1234]
#+end_quote
において読み込まれるメモリの値も 16 ビットであることが一般的です。
例えば、
メモリのアドレスがバイト (8 ビット) 単位であれば、
0x1234 番地と 0x1235 番地の 2 バイトにまたがって格納されている値が読み込まれます。
#+end_note

以下、
レジスタが 2 個 (レジスタ \r{1} および \r{2}) の場合を考えます。

上記の処理を組み合わせれば、
以下のような複雑な処理が可能になります。

- 123 + 456 を計算し、結果を 0x789a 番地に格納する
  #+begin_src asm
  r1       ← 123
  r1       ← <+> 456   # r1 ← 123 + 456
  [0x789a] ← r1
  #+end_src
  ~#~ 以降はコメント (注釈) です。

  「\r{1} ← <+> 456」は、
  レジスタ \r{1} に +456 を格納するのではなく、
  レジスタ \r{1} に 456 を追加することに注意してください。
  上の例では、
  合計 3 命令で計算できています。

  レジスタを 2 つとも使って以下のように計算することもできます。
  #+begin_src asm
  r1       ← 123
  r2       ← 456
  r1       ← <+> r2   # r1 ← 123 + 456
  [0x789a] ← r1
  #+end_src
  レジスタを 2 つ使った場合、
  合計 4 命令です。
  ちなみに今回の例であれば、
  レジスタを 2 つ使うメリットはありません。

- (123 + 456) / 789 を計算し、結果を 0xabcd 番地に格納する

  この場合、
  レジスタ \r{1} だけを使って計算することもできます。
  #+begin_src asm
  r1       ← 123
  r1       ← <+> 456   # r1 ← 123 + 456
  r1       ← </> 789   # r1 ← (123 + 456) / 789
  [0xabcd] ← r1
  #+end_src

- 789 / (123 + 456) を計算し、結果を 0xabcd 番地に格納する

  上の例とは異なり、
  この場合はレジスタ \r{1} だけでは計算できません。
  123 + 456 をレジスタ \r{2} に代入し、
  その後で 789 / \r{2} を計算すれば可能です。
  #+begin_src asm
  r1       ← 789
  r2       ← 123
  r2       ← <+> 456   # r2 ← 123 + 456
  r1       ← </> r2    # r1 ← 789 / (123 + 456)
  [0xabcd] ← r1
  #+end_src

- (12 + 34) / ((56 + 78) \times (90 - 10)) を計算し、結果を 0xabcd 番地に格納する

  同じように計算してみましょう。
  #+begin_src asm
  r1       ← 12
  r1       ← <+> 34	# r1 ← 12 + 34
  r2       ← 56
  r1       ← <+> 78	# r2 ← 56 + 78
  			# レジスタが足りない!
  #+end_src
  レジスタ \r{1} と \r{2} を使ってしまったので、
  90 - 10 を計算できなくなってしまいました。

  レジスタが \r{1} と \r{2} の 2 つしかないので、
  レジスタの値をいったんメモリに退避して、
  あとで取り出すようにしましょう。
  #+begin_src asm
  r1       ← 12
  r1       ← <+> 34	# r1 ← 12 + 34
  r2       ← 56
  r2       ← <+> 78	# r2 ← 56 + 78
  [0x8000] ← r1	# 0x8000 番地に退避
  r1       ← 90
  r1       ← <-> 10	# r1 ← 90 - 10
  r2       ← <*> r1	# r2 ← (56 + 78) * (90 - 10)
  r1       ← [0x8000]
  r1       ← </> r2	# r1 ← (12+34) / ((56+78) * (90-10)
  #+end_src
  上記の例では、
  メモリの 0x8000 番地が空いている (自由に使ってよい) ことを仮定しています。

このように、
レジスタの数が少なくても、
レジスタの値をいったんメモリに退避してやれば、
複雑な計算を行うことができます。
上記の例ではレジスタ数が 2 の場合でしたが、
レジスタ数が 8〜16 程度あっても、
やはり少ないレジスタをどうやりくりするかを考える必要があります。
例えば、
- 計算の途中結果をどのレジスタに持たせるのか
- いつレジスタの値をメモリに退避するのか
- いつレジスタの値をメモリから戻せばよいのか
などです。

少数のレジスタと、
ALU と、
メモリ空間を使えばどんな計算でも可能になります。
ただし、
アセンブリ言語でプログラムを書く場合には、
レジスタのやりくりや、
メモリのやりくりを、
プログラマが考えなければなりません。
限られた数のレジスタと、
限られた命令で、
どのように複雑な処理を実現すればよいかを考えるのは、
ある意味パズルを解くのに近いものがあります。

** 章末問題
<<sec:mem/quiz>>

1. 自身が使用しているコンピュータの、キャッシュメモリおよび主記憶装置
   の容量を調べよ。

   #+begin_answer
   いろいろな方法あるが、
   GNU/Linux オペレーティングシステムであれば、
   例えば ~lshw~ コマンドによって確認できる。
#+begin_src sh
     *-memory
          description: System Memory
          physical id: 3
          slot: System board or motherboard
          size: 16GiB
        *-bank:0
             description: Row of chips LPDDR3 Synchronous Unbuffered (Unregistered) 2133 MHz (0.5 ns)
             product: K4EBE304EB-EGCG
             vendor: Samsung
             physical id: 0
             serial: 55000000
             slot: ChannelA-DIMM0
             size: 8GiB
             width: 64 bits
             clock: 2133MHz (0.5ns)
        *-bank:1
             description: Row of chips LPDDR3 Synchronous Unbuffered (Unregistered) 2133 MHz (0.5 ns)
             product: K4EBE304EB-EGCG
             vendor: Samsung
             physical id: 1
             serial: 55000000
             slot: ChannelB-DIMM0
             size: 8GiB
             width: 64 bits
             clock: 2133MHz (0.5ns)
     *-cache:0
          description: L1 cache
          physical id: 7
          slot: L1 Cache
          size: 256KiB
          capacity: 256KiB
          capabilities: synchronous internal write-back unified
          configuration: level=1
     *-cache:1
          description: L2 cache
          physical id: 8
          slot: L2 Cache
          size: 1MiB
          capacity: 1MiB
          capabilities: synchronous internal write-back unified
          configuration: level=2
     *-cache:2
          description: L3 cache
          physical id: 9
          slot: L3 Cache
          size: 8MiB
          capacity: 8MiB
          capabilities: synchronous internal write-back unified
          configuration: level=3
#+end_src
   これより、
   搭載メモリ量は 16 G バイト、
   L1、
   L2、
   L3 キャッシュが、
   それぞれ 256 K バイト、
   1 M バイト、
   8 M バイトであることがわかる。
   #+end_answer

2. 「アドレス」、「番地」、「アドレスマップ」、「アドレッシング」の意
   味を、それぞれの違いがわかるように説明せよ。

   #+begin_answer
   「アドレス」、
   「番地」はどちらも、
   データが格納されている場所を表す。
   「アドレスマップ」はメモリ中に格納されているデータの様子を図示したものである。
   「アドレッシング」はアドレスを指定することを意味する。
   #+end_answer

3. 自身が使用しているコンピュータのエンディアンネスを信頼できる情報源
   を使用して調べよ。調べた結果が正しいかを、実験によって確認せよ。

   #+begin_answer
   例えば、
   デバッガで 32 ビットの符号なし整数が格納されているメモリをダンプすればエンディアンネスが確認できる。
   #+end_answer

4. 10 進数の 12 345 を、16 ビット、32 ビット、64 ビットの符号付き整数
   としてリトルエンディアンのコンピュータに格納した時のバイト列を答え
   よ。

   #+begin_answer
   39 30、
   39 30 00 00、
   39 30 00 00 00 00 00 00 (すべて 16 進数)
   #+end_answer

5. 10 進数の -12 345 を、16 ビット、32 ビット、64 ビットの符号付き整数
   としてビッグエンディアンのコンピュータに格納した時のバイト列を答え
   よ。

   #+begin_answer
   cf c7、
   ff ff cf c7、
   ff ff ff ff ff ff cf c7 (すべて 16 進数)
   #+end_answer

6. 符号付き整数をリトルエンディアンのコンピュータに格納したところ、
   0x80、0x90、0xa0、0xb0 というバイト列であった。この整数の値を 10 進
   数で答えよ。

   #+begin_answer
   -1 331 654 528
   #+end_answer

7. 符号なし整数をビッグエンディアンのコンピュータに格納したところ、
   0x11、0x33、0x55、0x77 というバイト列であった。この整数の値を 10 進
   数で答えよ。

   #+begin_answer
   288 576 887
   #+end_answer

8. ネットワークオーダが本当にビッグエンディアンであることを実験によっ
   て確認せよ。

   #+begin_answer
   例えば、
   tcpdump コマンド等を用いてパケットをキャプチャし、
   IP パケットの IP ヘッダの「パケット長」フィールド (16 ビット) がビッグエンディアンであることを確認すればよい。
   #+end_answer

9. 自身が使用している C コンパイラにおける、char、int、short、long、
   long long、float、double、long double のデータサイズを実験によって
   確認せよ。

   #+begin_answer
   C 言語では、
   ~sizeof~ 演算子を使えばデータの大きさ (バイト単位) を取得できる。
   #+end_answer

10. 「123 / 456 + 789」の計算手順を CPU 処理の抽象モデルで記述せよ。

    #+begin_answer
    | r1 ← 123     |
    | r1 ← </> 456 |
    | r1 ← <+> 789 |
    #+end_answer

11. 「123 + 456 / 789」の計算手順を CPU 処理の抽象モデルで記述せよ。

    #+begin_answer
    レジスタを 2 つ使用する場合:
    | r1 ← 123     |
    | r2 ← 456     |
    | r2 ← </> 789 |
    | r1 ← <+> r2  |
    #+end_answer

12. 「12 - 34 + 56 + 78 + 90 / 10」の計算手順を CPU 処理の抽象モデルで
    記述せよ。

    #+begin_answer
    レジスタを 2 つ使用する場合:
    | r1 ← 12     |
    | r1 ← <-> 34 |
    | r1 ← <+> 56 |
    | r1 ← <+> 78 |
    | r2 ← 90     |
    | r2 ← </> 10 |
    | r1 ← <+> r2 |
    #+end_answer

13. 「(12 - 34 + 56 + 78 + 90) / 10」の計算手順を CPU 処理の抽象モデル
    で記述せよ。

    #+begin_answer
    | r1 ← 12     |
    | r1 ← <-> 34 |
    | r1 ← <+> 56 |
    | r1 ← <+> 78 |
    | r1 ← <+> 90  |
    | r1 ← </> 10
    #+end_answer

14. 「(12 - 34) \times 56 / (78 + 90 - 10)」の計算手順を CPU 処理の抽
    象モデルで記述せよ。

    #+begin_answer
    レジスタを 2 つ使用する場合:
    | r1 ← 12     |
    | r1 ← <-> 34 |
    | r1 ← <*> 56 |
    | r2 ← 78     |
    | r2 ← <+> 90 |
    | r2 ← <-> 10 |
    | r1 ← </> r2 |
    #+end_answer
