# -*- Org -*-
# 
# Copyright (c) 2021, Hiroyuki Ohsaki.
# All rights reserved.
# 

# This document is licensed under a Creative Commons
# Attribution-NonCommercial-ShareAlike 4.0 International License (CC
# BY-NC-SA 4.0).

# This document is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# Creative Commons License for more details.

# You should have received a copy of the license along with this work.
# If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

* 64 ビット CPU の例: x86-64
<<ch:x86-64>>

** Intel 64 アーキテクチャの概要
<<sec:x86-64/overview>>

*** AMD 64、Intel 64、x86-64 の関係

IA-32 アーキテクチャは、
その名前が表す通り 32 ビットの命令セットアーキテクチャです。
32 ビットのアーキテクチャなので、
汎用レジスタやプログラムカウンタ、
スタックポインタの大きさはすべて 32 ビットであり、
アドレス空間の大きさも 32 ビットです ([[sec:cpu/ia32-register]] 節)。

*Intel 64* は 2004 年に登場した、
IA-32 アーキテクチャを拡張した 64 ビットの命令セットアーキテクチャです。
64 ビットのアーキテクチャなので、
汎用レジスタやプログラムカウンタ、
スタックポインタの大きさはすべて 64 ビットであり、
またアドレス空間の大きさも 64 ビットなのですが、
IA-32 アーキテクチャを大幅に変更することなく、
64 ビットの命令セットアーキテクチャへの拡張を実現しています。

IA-32 アーキテクチャは、
インテルが長い年月をかけて設計・発展させてきた命令セットアーキテクチャですが、
実はその 64 ビット拡張を設計したのはインテルではなく AMD です。
AMD が x86 アーキテクチャを拡張した、
64 ビットの命令セットアーキテクチャが *AMD64* です。
インテルの Intel 64 アーキテクチャは、
AMD が設計した AMD64 とほとんど同じです。
AMD が 64 ビットアーキテクチャを AMD64 と呼んでいることから、
インテルは自身の 64 ビットアーキテクチャを Intel 64 と呼んでいるようです。

x86 アーキテクチャの 64 ビット拡張である AMD64 や Intel 64 は、
*x86-64*、
*x64*、
*~x86_64~* とも呼ばれています。
AMD64 と Intel 64 はほとんど同一であるため、
これら 2 つの 64 ビット拡張を総称して x86-64、
x64、
~x86_64~ などと呼びます。
なお、
インテルは Intel 64 のことを *IA-32e (IA-32 extensions)* や *EM64T (Extended Memory 64 Technology)* と呼んでいたこともあります。

#+begin_note
例えば、
32 ビット版の Debian GNU/Linux は Debian GNU/Linux (*i386*) と呼ばれています。
「i386」は、
IA-32 アーキテクチャ (インテルの 80386 シリーズの CPU のアーキテクチャ) を意味します。
同様に、
64 ビット版の Debian GNU/Linux のは Debian GNU/Linux (*amd64*) と呼ばれています。
「amd64」は、
AMD の AMD64 を意味しています。
Debian GNU/Linux (amd64) は、
AMD の CPU だけでなく、
インテルの (Intel 64 アーキテクチャに対応した) CPU 上でも動作します。
#+end_note

#+begin_note
なお、
*IA-64* という名前の命令セットアーキテクチャも存在しますが、
x86-64 とはまったく別物なので注意してください。
「IA-32 アーキテクチャが 32 ビットなのだから、
IA-64 はその 64 ビット拡張なのだろう」と想像しますが、
まったく違います。

IA-64 アーキテクチャは、
インテルが設計した 64 ビットの命令セットアーキテクチャですが、
IA-32 とは互換性がありません。
インテルが、
IA-64 アーキテクチャの CPU の出荷を 2021 年に終了すると発表したこともあり、
今後、
皆さんが IA-64 アーキテクチャの CPU を利用する機会はほとんどないでしょう。
#+end_note

*** IA-32 アーキテクチャとの主な違い

IA-32 アーキテクチャは驚くほど複雑な命令セットアーキテクチャですが、
幸いなことに、
その 64 ビット拡張である Intel 64 はそれほど複雑ではありません。
筆者の感覚では、
IA-32 アーキテクチャの複雑さを 100 とすると、
IA-32 アーキテクチャ + 64 ビット拡張の複雑さは 110 程度です。
IA-32 アーキテクチャに、
10 % 程度の複雑さを足しただけで 64 ビット化を実現している、
というイメージです (あくまで筆者の主観ですが)。

IA-32 アーキテクチャのことを知らずに、
Intel 64 アーキテクチャを理解しようとすると、
何がどうなっているのかまったくわからないかもしれません。
Intel 64 アーキテクチャでは、
32 ビットと 64 ビットの概念が混在しているため、
IA-32 アーキテクチャの理解が不可欠です。

しかし、
IA-32 アーキテクチャを理解していれば、
それほど苦労せずに Intel 64 アーキテクチャも理解できるでしょう。
Intel 64 アーキテクチャを一言で表現すれば、
「Intel 64 アーキテクチャは、
基本的に IA-32 アーキテクチャと同じ。
ただし、
アドレスはすべて 64 ビットになっていて、
64 ビットのレジスタや 64 ビットのオペランドも使える。」
と言えます。

Intel 64 アーキテクチャは、
64 ビットのアーキテクチャなので、
基本的に 32 ビットのアドレスは使用せず、
*64 ビットのアドレスのみ* を使用します。
アドレスはほぼ完全に 64 ビット化されていますが、
*データサイズは 32 ビットと 64 ビットを併用* します。
もちろん、
64 ビットのレジスタを使用した 64 ビットの演算も可能ですが、
*データサイズのデフォルトは 32 ビット* です。

後ほど、
アセンブリ言語プログラムの実例を通して説明しますが、

- Intel 64 アーキテクチャにおけるデータサイズのデフォルトは 32 ビット
- Intel 64 アーキテクチャでは、C 言語の ~int~ 型の大きさは 32 ビット

だということもあり、
C 言語で普通にプログラムを書いている限りは、
IA-32 アーキテクチャでも、
Intel 64 アーキテクチャでも、
ほぼ同じような機械語プログラムになります。

** Intel 64 アーキテクチャ
<<sec:x86-64/arch>>

#+caption: Intel 64 アーキテクチャの特徴
#+label: tab:x86-64/intel64
#+attr_latex: :environment maxtabular
| 命令セットの種別     | CISC                                                                                        |
| レジスタの大きさ     | 64 ビット (32 ビット、16 ビット、8 ビットでのアクセスも可)                                  |
| 汎用レジスタ数       | 16                                                                                          |
| プログラムカウンタ   | RIP レジスタ                                                                                |
| スタックポインタ     | RSP レジスタ                                                                                |
| 特殊レジスタ         | セグメントレジスタ、FPU レジスタ、MMX レジスタ                                              |
|                      | XMM レジスタ、YMM レジスタ、各種制御レジスタ                                                |
| フラグレジスタ       | RFLAGS レジスタ                                                                             |
|                      | OF フラグ、SF フラグ、ZF フラグ、PF フラグ、AF フラグ、ほか 6 種類                          |
| 命令数               | 500 以上 (ニーモニック数)                                                                   |
| 命令語の大きさ       | 1～15 バイト                                                                                |
| データサイズ         | 64 ビット (クワッドワード)、32 ビット (ダブルワード)、16 ビット (ワード)、8 ビット (バイト) |
| 浮動小数点演算命令   | あり                                                                                        |
| SIMD 命令            | MMX テクノロジ、SSE、SSE2、SSE3、AVX、AVX2、AVX-512 (CPU のモデルによる)                    |
| メモリアドレス       | 64 ビット                                                                                   |
| エンディアンネス     | リトルエンディアン                                                                          |
| メモリ保護           | あり                                                                                        |
| ハードウェア割り込み | あり                                                                                        |
| ソフトウェア割り込み | あり                                                                                        |

*** 互換モードと 64 ビットモード

IA-32 アーキテクチャの 64 ビット拡張である Intel 64 の動作モードは *IA-32e* と呼ばれています。
さらに IA-32e には、
*互換モード (compatibility mode)* と *64 ビットモード (64-bit mode)* と呼ばれる 2 種類のモードがあります。

互換モードは、
IA-32 アーキテクチャの機械語をそのまま実行します。
一方、
64 ビットモードは、
64 ビットのアドレスを使用し、
64 ビットのレジスタや 64 ビットの命令を使用できます。
これらの 2 種類のモードは、
コードセグメントごとに、
どちらのモードであるかが設定されます。
このため例えば、
64 ビット版のオペレーティングシステムでは、
「あるプロセスは 32 ビット版のプログラムを互換モードで実行し、
別のプロセスは 64 ビット版のプログラムを 64 ビットモードで実行する」といったことも可能です。

IA-32e の互換モードは IA-32 アーキテクチャとほぼ同じなので、
以下では IA-32e の 64 ビットモードを説明します。

*** IA-32 アーキテクチャとの違い

IA-32 アーキテクチャと Intel 64 アーキテクチャの主な違いを表 [[tab:x86-64/comparison]] に示します。
Intel 64 アーキテクチャでは、
メモリのアドレスに関係する処理は完全に 64 ビット化されています。
アドレスが 64 ビットなので、
$2^{64}$ バイトもの広大なアドレス空間を利用できます。
基本的に 64 ビットのアドレスを使用するため、
*プログラムカウンタもスタックポインタも 64 ビット* です。
同様に、
アドレスが 64 ビットなので、
ジャンプ命令やコール命令の *ジャンプ先アドレスも 64 ビット* です。

#+caption: IA-32 アーキテクチャ (x86) と Intel 64 アーキテクチャ (x86-64、64 ビットモード) の主な違い
#+label: tab:x86-64/comparison
#+attr_latex: :environment maxtabular
|                                   | IA-32 (x86)   | Intel 64 (x86-64、64ビットモード)            |
|-----------------------------------+---------------+----------------------------------------------|
| アドレス                          | 32 ビット     | *64 ビット*                                  |
| プログラムカウンタの大きさ        | 32 ビット     | *64 ビット*                                  |
| スタックポインタの大きさ          | 32 ビット     | *64 ビット*                                  |
| ジャンプ命令/コール命令のアドレス | 32 ビット     | *64 ビット*                                  |
|-----------------------------------+---------------+----------------------------------------------|
| 汎用レジスタの大きさ              | 32 ビット     | *64 ビット*                                  |
| フラグレジスタの大きさ            | 32 ビット     | 64 ビット (ただし上位32ビットは未使用)       |
| 汎用レジスタの数                  | 8             | *16*                                         |
| SIMD 命令用レジスタの数           | 8 (XMM, YMM)  | *16* (XMM, YMM)                              |
|-----------------------------------+---------------+----------------------------------------------|
| オペランドのデータサイズ          | 32 ビットまで | *64 ビットまで* (ただしデフォルトは32ビット) |
| 命令ポインタ相対アドレス指定      | 不可          | *可能*                                       |
| オペランドの即値                  | 32 ビット     | 32 ビット (64 ビットにゼロ拡張/符号拡張)     |
| 間接メモリ参照の変位              | 32 ビット     | 32 ビット (64 ビットに符号拡張)              |

さらに、
Intel 64 アーキテクチャでは、
汎用レジスタや SIMD 命令用のレジスタが大幅に強化されています。
汎用レジスタの大きさは、
32 ビットから 64 ビットになっています。
また汎用レジスタの大きさが倍になっただけでなく、
*汎用レジスタの数も倍 (8 から 16)* に増えています。
これにより IA-32 アーキテクチャにおける最大の弱点の 1 つであった、
汎用レジスタの少なさが改善されています。
さらに、
*SIMD 命令のレジスタ (レジスタ XMM および YMM) の数も倍* に増えています。

このように、
Intel 64 アーキテクチャでは、
IA-32 アーキテクチャと比較して、
アドレス幅とレジスタが大幅に強化されました。
32 ビットのアーキテクチャから、
64 ビットのアーキテクチャへと正統に進化したといえるでしょう。

一方、
64 ビットでの算術演算や論理演算が可能になってはいますが、
Intel 64 アーキテクチャにおける機械語のオペコードやオペランドは、
IA-32 アーキテクチャのものから大きく変化していません。
命令語の構成を大きく変えることなく、
ほとんどの命令のデータサイズを 64 ビット化しているのです。

また、
アドレス指定モードに、
*命令ポインタ相対アドレス指定 (instruction-pointer relative-addressing)* が新しく追加されました。
これにより、
IA-32 アーキテクチャでは苦労して実現していた PIC (Position Independent Code; 位置非依存のコード) ([[sec:asm/asm-to-machine]] 節) が簡単に書けるようになりました。

ただし、
命令語の構成を大きく変えなかったこともあり、
オペランドに指定できる即値や、
間接メモリ参照における変位 (ディスプレイスメント) に指定できる値は *32 ビットのまま* です。
このあたりの制限については後ほど説明します。

*** レジスタ

Intel 64 アーキテクチャの汎用レジスタを図 [[fig:x86-64/regs.png]] に示します。
汎用レジスタの大きさは IA-32 アーキテクチャの倍である 64 ビット、
汎用レジスタの数も IA-32 アーキテクチャの倍である 16 です。
Intel 64 アーキテクチャにおける 64 ビットの汎用レジスタは、
RAX、
RBX、
RSI、
RBP、
R8 のように *R から始まる名前* が付いています。
例えば、
EAX、
EBX、
ESI、
EBP などの 32 ビットレジスタに対応した 64 ビットレジスタはそれぞれ RAX、
RBX、
RSI、
RBP という具合です。

#+caption: Intel 64 アーキテクチャの汎用レジスタ
#+label: fig:x86-64/regs.png
#+attr_latex: :width \columnwidth
[[./figure/x86-64/regs.png]]

IA-32 アーキテクチャでは、
32 ビットの汎用レジスタ (例： EAX ) の下位 16 ビットや下位 8 ビットに、
別のレジスタ名 (例： AX、
AL ) でアクセスできました。
これと同じように、
Intel 64 アーキテクチャにおける 64 ビットレジスタの下位 32 ビット、
下位 16 ビット、
下位 8 ビットにも *別のレジスタ名でアクセス* 可能です。
例えば、
レジスタ RAX の下位 32 ビットはレジスタ EAX としてアクセスできます。

IA-32 アーキテクチャでは、
32 ビットの汎用レジスタの下位 8 ビットにアクセスできるのは、
レジスタ EAX、
EBX、
ECX、
EDX に限定されていました。
つまり、
レジスタ EAX、
EBX、
ECX、
EDX 以外の汎用レジスタ (例えばレジスタ ESI や ESP) の下位 8 ビットには別のレジスタとしてアクセスできませんでした。
一方 Intel 64 アーキテクチャでは、
すべての汎用レジスタの下位 8 ビットに別のレジスタとしてアクセスできます。
例えば、
レジスタ RSI、
RDI、
EBP (ベースポインタ)、
RSP (スタックポインタ) の下位 8 ビットにも、
レジスタ SIL、
DIL、
BPL、
SPL という名前でそれぞれアクセスできるのです。

もちろん、
Intel 64 アーキテクチャにおいて新しく追加された 64 ビットレジスタ R8〜R15 の下位 32 ビット、
下位 16 ビット、
下位 8 ビットにもアクセスできます。
例えば、
レジスタ R8 の下位 32 ビット、
下位 16 ビット、
下位 8 ビットにはそれぞれレジスタ R8D、
R8W、
R8B としてアクセスできます。

ただし、
下位 32 ビットのレジスタへのアクセスと、
下位 16 ビットおよび 8 ビットのレジスタのアクセスでは挙動が異なるため注意が必要です。
具体的には、
64 ビットの汎用レジスタの下位ビットに書き込むと、
レジスタの値は以下のように変化します。

- 下位 32 ビットのレジスタに書き込むと、上位 32 ビットの値は *ゼロでク
  リア* される
- 下位 16 ビットのレジスタに書き込んでも、上位 48 ビットの値は *変わら
  ない* (書き込む前の値が保持される)
- 下位 8 ビットのレジスタに書き込んでも、上位 56 ビットの値は *変わら
  ない* (書き込む前の値が保持される)

例えば、
レジスタ RAX の値が 0x1234 5678 9abc def0 のときに、
レジスタ EAX、
AX、
AL にそれぞれ書き込むと、
レジスタ RAX の値は以下のように変化します。

| 実行する命令             | 命令実行後の RAX の値 | 説明                         |
|--------------------------+-----------------------+------------------------------|
| ~movl $0x12345678, %eax~ |    0x0000 0000 1234 5678 | 上位 32 ビットがクリアされる |
| ~movl $0x1234, %ax~      |    0x1234 5678 9abc 1234 | 上位 48 ビットは変化しない   |
| ~movl $0x12, %al~        |    0x1234 5678 9abc de12 | 上位 56 ビットは変化しない   |

IA-32 アーキテクチャのスタックポインタは ESP レジスタであり、
プログラムカウンタ (命令ポインタ) は EIP レジスタでした。
Intel 64 アーキテクチャでは、
アドレスは 64 ビットなので、
スタックポインタは *64 ビットの RSP レジスタ*、
プログラムカウンタも *64 ビットの RIP レジスタ* です。

*フラグレジスタ RFLAGS* も、
プログラムカウンタや汎用レジスタと同じく 64 ビットです。
フラグレジスタ RFLAGS の下位 32 ビットは、
IA-32 アーキテクチャにおける EFLAGS と同じです。
RFLAGS の大きさは 64 ビットですが、
上位 32 ビットは未使用であり、
将来のために予約されています。

IA-32 アーキテクチャでは、
レジスタ EAX、
EBX、
ECX、
EDX の下位 16 ビットの上位 8 ビット (8〜15 ビット) は、
レジスタ AH、
BH、
CH、
DH としてアクセスできました。
これらのレジスタ名は Intel 64 アーキテクチャでも残っていますが、
新しく用意された下位 8 ビットのレジスタ (SIL、
SPL、
SPL、
R8B など) と同時に使用できないという制約があります。
このため、
例えば
#+begin_src asm
	movb	%ah, %r8b		# 書けない!
#+end_src
のようには書けません。

*** 命令のオペランド

Intel 64 アーキテクチャにおける命令のオペランドは、
IA-32 アーキテクチャからそれほど変わっていません。
    
まず、
汎用レジスタもアドレスも 64 ビット化されたので、
当然、
オペランドに 64 ビットのレジスタやメモリロケーションを指定できます。
例えば、
#+begin_src asm
	movb	%bl, %al		# AL ← BL (8 ビット)
	movw	%bx, %ax		# AX ← BX (16 ビット)
	movl	%ebx, %eax		# EAX ← EBX (32 ビット)
	movq	%rbx, %rax		# RAX ← RBX (64 ビット)
#+end_src
によって、
8 ビット、
16 ビット、
32 ビット、
64 ビットのレジスタ間のコピーが可能です。
movq の q は *Quadword (クワッドワード = 64 ビット)* を意味する GAS の接尾部 (サフィックス) ([[sec:gas/ia32-specific]] 節) です。

もちろん、
Intel 64 アーキテクチャで新しく導入された汎用レジスタも使用できます。
#+begin_src asm
	movb	%al, %r8b		# R8B ← AL (8 ビット)
	movw	%r9w, %r8w		# R8W ← R9W (16 ビット)
	movl	%r9d, %r8d		# R8D ← R9D (32 ビット)
	movq	%r9, %r8		# R8 ← R9 (64 ビット)
#+end_src

アドレスは基本的に 64 ビットなので、
メモリロケーションは 64 ビットで計算されます。
例えば、
#+begin_src asm
	movb	(%rbx), %al		# AL ← [RBX] (8 ビット)
#+end_src
によって、
レジスタ RBX が指すアドレスに格納されている 1 バイトの値がレジスタ AL に読み込まれます。
同様に、
#+begin_src asm
	movq	(%rbx), %rax		# RAX ← [RBX] (64 ビット)
#+end_src
によって、
レジスタ RBX が指すアドレスに格納されている 8 バイトの値がレジスタ RAX に読み込まれます。
このように、
Intel 64 アーキテクチャは、
IA-32 アーキテクチャの 64 ビット拡張として自然な形でオペランドが 64 ビット化されています。

ただし、
オペランドが即値や変位 (ディスプレイスメント) を含む場合は少し注意が必要です。

IA-32 アーキテクチャは CISC だけあり、
#+begin_src asm
	addl	$0x12345678, %eax
#+end_src
のようにオペランドに 32 ビットの即値が記述できます。
RISC である AVR アーキテクチャや Armv8-A アーキテクチャでは命令語長が基本的に固定であるため、
オペランドにこのように大きな即値は記述できません。
一方、
IA-32 アーキテクチャでは、
命令語長が可変長なので、
上記のような巨大な即値が記述できます。

このため Intel 64 アーキテクチャでも、
オペランドに 64 ビットの即値が記述できそうな気がしますが、
基本的に (IA-32 アーキテクチャと同じ) 32 ビットまでの即値しか指定できません。

例えば、
IA-32 アーキテクチャでは、
#+begin_src asm
	movb	$0x12, %al		# AL ← 0x12
	addb	$0x34, %al		# AL ← <+> 0x34
	movw	$0x1234, %ax		# AX ← 0x1234
	addw	$0x5678, %ax		# AX ← <+> 0x5678
	movl	$0x12345678, %eax	# EAX ← 0x123456768
	addl	$0x9abcdef0, %eax	# EAX ← <+> 0x9abcdef0
#+end_src
のようにオペランドに即値を記述できました。
Intel 64 アーキテクチャでは
#+begin_src asm
	movq	$0x123456789abcdef0, %rax # RAX ← 0x123456789abcdef0
#+end_src
のように、
MOV 命令の出所オペランドには 64 ビットの即値を指定できます。

「なるほど、
Intel 64 アーキテクチャはさすが 64 ビットだ」と考えて、
同じように
#+begin_src asm
	addq	$0x123456789abcdef0, %rax # 書けない!
#+end_src
のように他の命令のオペランドに 64 ビットの即値を指定したくなりますが、
このような記述は *できません*。
オペランドに 64 ビットの即値を記述できるのは MOV 命令だけです。
MOV 命令以外のすべての命令は、
*32 ビットまでの即値* しか指定できません。
したがって、
例えば、
64 ビットの即値をレジスタ RAX に加算する場合は、
#+begin_src asm
	movq	$0x123456789abcdef0, %rbx # RBX ← 0x123456789abcdef0
	addq	%rbx, %rax
#+end_src
などのように書く必要があります。

また、
オペランドが 64 ビットの値を期待している箇所に 32 ビットの即値を記述した場合、
即値の値は 64 ビットに *符号拡張 (sign extension)* されることに注意が必要です。
例えば、
#+begin_src asm
	addq	$0x80000000, %rax
#+end_src
と書くと、
「レジスタ RAX の値が 0x800 0000 (= 約 21 億) だけ大きくなる」ことを期待しますが、
実際には、
レジスタ RAX の値が約 21 億だけ小さくなります。
0x8000 0000 は符号付き整数では -2 147 483 648 (約 -21 億) であるため、
64 ビットに符号拡張されて 0xffff ffff 8000 0000 となるからです。

#+begin_note
幸いなことに、GAS は、
#+begin_src asm
	addq	$0x80000000, %rax
#+end_src
のように記述すると「Error: operand type mismatch for `add'」のようにエラーを表示します。
これは、
即値の値が、
32 ビットの符号なし整数として有効な値に入っているかをチェックしているためです。
#+end_note

ただし、
オペランドが 64 ビットのアドレスを期待している箇所に 32 ビットの即値を記述した場合は、
即値の値は 64 ビットに符号拡張されるのではなく、
64 ビットに *ゼロ拡張 (zero extension)* されます。
例えば、
#+begin_src asm
	addq	%rax, (0x80000000)
#+end_src
と書くと、
期待どおり、
メモリの 0x0000 0000 8000 0000 番地にレジスタ RAX の値を書き込みます。
32 ビットの 0x8000 0000 を 64 ビットに符号拡張した、
0xffff ffff 8000 0000 番地に書き込むのではありません。

*** アドレス指定モード

Intel 64 アーキテクチャでは、
さらに、
アドレス指定モードのうち、
*間接メモリ参照 (indirect memory reference)* が強化されました。
間接メモリ参照とは、
ベースレジスタ、
インデックスレジスタ、
倍率、
変位 (ディスプレイスメント) の 4 つを組み合わせて
\begin{align}
アドレス = ベースレジスタの値 + インデックスレジスタの値 \times 倍率 + 変位
\end{align}
のようにアドレスを指定する方法でした ([[sec:gas/ia32-specific]] 節)。

Intel 64 アーキテクチャでは、
間接メモリ参照のベースレジスタに、
プログラムカウンタであるレジスタ RIP が指定できるようになりました。
この方法は、
*命令ポインタ相対アドレス指定* と呼ばれます。
ベースレジスタがプログラムカウンタ (レジスタ RIP) ですので、
これは、
「現在のプログラムカウンタの値を基準とする相対メモリ参照が可能になった」ことを意味します。

例えば、
#+begin_src asm
        movl    123(%rip), %eax		# EAX ← [RIP + 123]
#+end_src
のように書くと、
レジスタ EAX に、
現在のプログラムカウンタが指すアドレスの 123 バイト後に格納されている 32 ビットの値が読み込まれます。

さらに、
命令ポインタ相対アドレス指定の例を見てみましょう (図 [[fig:x86-64/rip-rel.s]])。

#+caption: x86-64/rip-rel.s
#+label: fig:x86-64/rip-rel.s
#+include: "code/x86-64/rip-rel.s" src raw

このプログラムでは、
ラベル ~v~ に格納されている 0x1234 5678 をレジスタ EAX に読み込んでいます。
まず、
#+begin_src sh
1:      movl    v, %eax                 # EAX ← [v]
#+end_src
は、
ラベル ~v~ の *絶対アドレス* をオペランドに記述しています。
ラベル ~v~ の値はアセンブラやリンカによって解決されます。
次の
#+begin_src asm
        movl    -17(%rip), %eax         # EAX ← [RIP - 17]
#+end_src
は *命令ポインタ相対アドレス指定* を使っています。
ラベル ~v~ のアドレスが、
この MOV 命令の直後から 17 バイト前に位置しているため、
ベースレジスタにレジスタ RIP を、
変位ん -17 を指定しています。
最後の
#+begin_src asm
        movl    v(%rip), %eax           # EAX ← [RIP + (v - RIP)]
#+end_src
も命令ポインタ相対アドレス指定を使っています。
ただし、
変位の値をオペランドに直接記述するのではなく、
変位にはラベル ~v~ を指定しています。
実際の変位の値は GAS がアセンブル時に自動的に計算します。

#+begin_note
なお、最後の
#+begin_src asm
        movq    $60, %rax               # exit システムコールは 60 番
        syscall                         # システムコール呼び出し
#+end_src
は、
64 ビット版の Linux カーネルの exit システムコールを呼び出しています。
32 ビット版の Linux カーネルでは INT 命令でシステムコールを呼び出しますが、
64 ビット版では、
Intel 64 アーキテクチャで新しく追加された *SYSCALL 命令* を使います。
64 ビット版の Linux カーネルでは、
exit システムコールには 60 番が割り当てられています。

システムコールの番号は、
例えば、
C 言語のヘッダファイルである ~unistd_32.h~ や ~unistd_64.h~ などを見ればわかります (筆者の環境では ~/usr/include/x86_ 64-linux-gnu/asm~ 以下に格納されていました)。
#+end_note

「ベースレジスタにプログラムカウンタであるレジスタ RIP が指定できるようになった」というのが Intel 64 アーキテクチャの相対アドレス参照の大きな変化です。
相対アドレス参照の「倍率」と「変位」は、
IA-32 アーキテクチャから変化していません。
つまり、
倍率に指定できるのは 1、
2、
4、
8 のいずれかの値で、
変位に指定できるのは *32 ビットの符号付き整数* です。
64 ビットの変位は指定できないことに注意してください。

# p. 147
*** 追加された命令と削除された命令

Intel 64 アーキテクチャの 64 ビットには、
新しく以下のような命令が追加されました (文献 \cite{Intel20:IA32} の 5.21 64-BIT MODE INSTRUCTIONS より抜粋、
日本語訳は筆者による)。

#+attr_latex: :environment maxtabular
| CDQE           | Convert doubleword to quadword.                                               |
|                | ダブルワードをクワッドワードに変換する。                                      |
| CMPSQ          | Compare string operands.                                                      |
|                | 文字列オペランドを比較する。                                                  |
| CMPXCHG16B     | Compare RDX:RAX with m128.                                                    |
|                | RDX:RAX と m128 (メモリ上の 128 ビット) を比較する。                          |
| LODSQ          | Load qword at address (R)SI into RAX.                                         |
|                | アドレス (R)SI のクワッドワードを RAX にロードする。                          |
| MOVSQ          | Move qword from address (R)SI to (R)DI.                                       |
|                | アドレス (R)SI から (R)DI にクワッドワードをコピーする。                      |
| MOVZX (64-bit) | Move bytes/words to doublewords/quadwords, zero-extension.                    |
|                | バイト/ワードをダブルワード/クアッドワードにゼロ拡張する。                    |
| STOSQ          | Store RAX at address RDI.                                                     |
|                | RAX をアドレス RDI に格納する。                                               |
| SWAPGS         | Exchanges current GS base register value with value in MSR address C0000102H. |
|                | 現在の GS ベースレジスタの値と MSR アドレス C0000102H の値を交換する。        |
| SYSCALL        | Fast call to privilege level 0 system procedures.                             |
|                | 特権レベル 0 のシステム手続きを高速に呼び出す。                               |
| SYSRET         | Return from fast systemcall.                                                  |
|                | 高速なシステムコールから復帰する。                                            |

一方、
IA-32 アーキテクチャにおける以下の命令は、
Intel 64 アーキテクチャの 64 ビットモードでは利用できなくなっています。
#+begin_quote
AAA AAD AAM AAS DAA DAS BOUND PUSHAD POPAD PUSHA POPA
#+end_quote

** よく使われる命令ランキングと ABI (Application Binary Interface)

IA-32 アーキテクチャにおける命令の使用頻度ランキングを [[sec:x86regs/ranking]] 節で紹介しました。
以下では、
[[sec:x86regs/ranking]] 節と同じ方法で求めた Intel 64 アーキテクチャにおける命令の使用頻度ランキングを示します (表 [[tab:x86-64/ranking]])。
筆者が使っている 64 ビット版の Debian GNU/Linux (amd64) における、
~/usr/bin~ 以下のすべての ELF 形式の実行ファイルを対象としました。

#+caption: Debian GNU/Linux (amd64) の /usr/bin 以下の実行ファイルで使用されている命令ランキング
#+label: tab:x86-64/ranking
#+attr_latex: :environment longtable
| 順位 | 出現率 | 命令   |
|------+--------+--------|
|    1 | 30.835 | mov    |
|    2 |  8.345 | call   |
|    3 |  6.753 | jmp    |
|    4 |  6.691 | lea    |
|    5 |  4.674 | test   |
|    6 |  4.636 | xor    |
|    7 |  4.633 | cmp    |
|    8 |  4.351 | je     |
|    9 |  4.290 | push   |
|   10 |  3.556 | nop    |
|   11 |  3.484 | pop    |
|   12 |  3.138 | jne    |
|   13 |  2.731 | add    |
|   14 |  1.716 | sub    |
|   15 |  1.584 | ret    |
|   16 |  1.088 | movzx  |
|   17 |  0.662 | and    |
|   18 |  0.437 | movsxd |
|   19 |  0.364 | ja     |
|   20 |  0.360 | or     |
|   21 |  0.352 | jbe    |
|   22 |  0.321 | xchg   |
|   23 |  0.307 | data16 |
|   24 |  0.271 | js     |
|   25 |  0.268 | movaps |
|   26 |  0.258 | shl    |
|   27 |  0.250 | shr    |
|   28 |  0.250 | jle    |
|   29 |  0.202 | movups |
|   30 |  0.185 | sete   |
|   31 |  0.182 | jg     |
|   32 |  0.165 | movsx  |
|   33 |  0.151 | cmove  |
|   34 |  0.144 | jae    |
|   35 |  0.136 | movabs |
|   36 |  0.119 | sbb    |
|   37 |  0.115 | movdqa |
|   38 |  0.109 | sar    |
|   39 |  0.103 | setne  |
|   40 |  0.102 | jb     |

IA-32 アーキテクチャの命令ランキング (表 [[tab:x86regs/ranking]]) と Intel 64 アーキテクチャの命令ランキング (表 [[tab:x86-64/ranking]]) はおおよそ似たような傾向であることがわかります。
ただし、
IA-32 アーキテクチャと比べると、
Intel 64 アーキテクチャにおける命令の使用頻度は以下のような違いがあることもわかります。

- MOV 命令の出現率が増えている
  - Intel 64 アーキテクチャでも、やはり MOV 命令が最も良く使用される命
    令だが、MOV 命令の出現率が IA-32 アーキテクチャよりもさらに増えて
    いる。
- PUSH 命令の出現率が大幅に減っている
  - Intel 64 アーキテクチャでは PUSH 命令はそれほど多くは使用されてい
    ない (2 位 (IA-32) から 9 位 (Intel 64) へと大幅に低下している)。
- JMP 命令と XOR 命令の出現率が増えている
  - IA-32 アーキテクチャと比べると、Intel 64 アーキテクチャでは JMP 命
    令と XOR 命令が多く使用されている (JMP 命令は 7 位 (IA-32) から3位
    (Intel 64) へ、XOR 命令は 13 位 (IA-32) から 6 位 (Intel 64)へと低
    下している)。

[[sec:x86regs/ranking]] 節でも議論したように、
こういったランキングは、
IA-32 アーキテクチャと Intel 64 アーキテクチャの違いだけでなく、
さまざまな要因の影響を受けます。
例えば、
使用しているコンパイラの特性や、
オペレーティングシステムの *ABI (Application Binary Interface)* ([[sec:stack/abi]] 節) などの影響も受けます。

さきほどの、
IA-32 アーキテクチャと Intel 64 アーキテクチャの命令ランキングの違いは、
32 ビット環境と 64 ビットの環境における ABI の違いの影響が大きいと思われます。
というのも、
32 ビット版の GNU/Linux の ABI では、
関数への引数渡しには *スタックを使用* します。
一方、
64 ビット版の GNU/Linux の ABI では、
関数への引数渡しには主に *レジスタを使用* します。

このため、
32 ビット環境では、
関数の呼び出し側は、
関数を呼び出すときに、
毎回、
PUSH 命令を使用してスタックに引数を積みます。
例えば、
32 ビットの整数 3 つを引数に取る関数 ~func~ に、
0、
123、
456 という引数を渡す場合を考えます。
この場合、
呼び出し側は
#+begin_src asm
	pushl	$456
	pushl	$123
	pushl	$0
	call	func
#+end_src
のようにして関数 ~func~ を呼び出します。

一方、
64 ビット環境では、
汎用レジスタや SIMD 命令用レジスタの数が増えていることもあり、
整数やアドレスなどの 64 ビット以下のデータや、
単精度や倍精度の浮動小数点数を引数として渡す場合は、
レジスタを積極的に使用します。
例えば、
引数の型が整数の場合、
6 個のレジスタ RDI、
RSI、
RDX、
RCX、
R8、
R9 をこの順に使用していき、
引数が 6 個を超える場合に初めて、
7 番目以降の引数をスタックに積んでいきます。
したがって、
さきほどの関数 ~func~ の例では、
呼び出し側は
#+begin_src asm
        movl    $456, %edx
        movl    $123, %esi
        movl    $0, %edi
        call    func
#+end_src
のようにして関数 ~func~ を呼び出すことになります。
このため、
Intel 64 アーキテクチャでは、
PUSH 命令の使用頻度が減り、
MOV 命令の使用頻度がさらに増えているのだと考えられます。

なお、
上の例において、
レジスタ EDI にゼロを格納している \inst{movl $0, %edi} は、
#+begin_src asm
	xorl	%edi, %edi
#+end_src
のように書けます。
MOV 命令に 32 ビットの即値を指定すると 5 バイトの機械語になりますが、
XOR 命令を使えば 2 バイトの機械語で済みます。

このため、
多くの場合、
コンパイラは MOV 命令ではなく XOR 命令を使用します。
Intel 64 アーキテクチャにおいて XOR 命令の使用頻度が多いのは、
このことが原因のようです。
つまり、
- 64 ビット環境では関数への引数渡しにレジスタが主に用いられる
- 関数への引数にゼロが含まれることも多い
- その場合、XOR 命令を使用してレジスタにゼロが格納される (ことが多い)
という理由で、
XOR 命令が頻繁に利用されていると思われます。

** コードリーディング
<<sec:x86-64/reading>>

*** 64 ビット環境向けの GCC および GNU binutils

Intel 64 アーキテクチャ向けのアセンブリ言語プログラムをいくつか読んでみましょう。

これまでは 32 ビット版の Debian GNU/Linux (i386) 上の GCC や GNU binutils を使用していましたが、
本章では *64 ビット版* の Debian GNU/Linux (amd64) 上の GCC や GNU binutils を使います。
64 ビット版のコンパイラやアセンブラ、
リンカなどを使う必要があることに注意してください。

まず、
64 ビット環境上で、
64 ビット版のツールを使っていることを確認します。
#+begin_src sh
$ uname -r
5.10.0-7-amd64 ← 64 ビット (amd64) 版のカーネルが動作している
$ dpkg -l binutils gcc-10
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name           Version      Architecture Description
+++-==============-============-============-==========================================
ii  binutils       2.35.2-2     amd64        GNU assembler, linker and binary utilities
ii  gcc-10         10.2.1-6     amd64        GNU C compiler
$ gcc -dumpmachine              ↑ 64ビット (amd64) 版のパッケージがインストールされている
x86_64-linux-gnu ← GCC の対象となるコンピュータは x86_64-linux-gnu
$ as --version
GNU assembler (GNU Binutils for Debian) 2.35.2
Copyright (C) 2020 Free Software Foundation, Inc.
This program is free software; you may redistribute it under the terms of
the GNU General Public License version 3 or later.
This program has absolutely no warranty.
This assembler was configured for a target of `x86_64-linux-gnu'. ← GAS の対象となるコンピュータも同じ
#+end_src
オペレーティングシステムのアーキテクチャが amd64 で、
GCC や GNU binutils の対象とするコンピュータのアーキテクチャが ~x86_64~ であることがわかります。

*** レジスタ変数を用いた加算

これまでも何度か登場しているプログラム ~add.c~ (図 [[fig:x86-64/add.c]]) をコンパイルし、
アセンブリ言語のプログラムを生成します。
64 ビット環境になっても、
コンパイラやアセンブラの使い方は 32 ビット環境の場合と同じです。
以下のようにして、
C 言語で書かれたプログラム ~add.c~ をコンパイルし、
アセンブリ言語プログラム ~add.s~ を生成します。
#+begin_src sh
$ gcc -fno-pic -fomit-frame-pointer -S add.c
#+end_src

# -O0
#+caption: x86-64/add.c
#+label: fig:x86-64/add.c
#+include: "code/x86-64/add.c" src C

#+begin_note
64 ビット環境では ~-fno-pic~ オプションは付けなくてもよいのですが、
32 ビット環境とそろえるためにあえて付けてあります。
Intel 64 アーキテクチャでは「命令ポインタ相対アドレス指定」が可能になったので、
64 ビット環境向けの GCC は、
位置非依存のコード (PIC) であっても簡潔なアセンブリ言語プログラムを生成します。
#+end_note

Intel 64 アーキテクチャの特徴を見るために、
アセンブリ言語プログラム ~add.s~ を、
32 ビット環境向けにコンパイルしたもの ~add-32.s~ と比較しましょう。
64 ビット版の GCC は、
以下のように ~-m32~ オプションを指定することによって、
*32 ビット環境向けにも* コンパイルできます。
#+begin_src sh
$ gcc -m32 -fno-pic -fomit-frame-pointer -S -o add-32.s add.c
#+end_src
ここでは、
~-o~ オプションを指定して、
生成するアセンブリ言語プログラムのファイル名を ~add-32.s~ と指定しています。

以下では、
C 言語で書かれたプログラム ~foo.c~ を、
64 ビット環境および 32 ビット環境向けにコンパイルして得られたアセンブリ言語プログラムに、
それぞれ ~foo.s~ や ~foo-32.s~ のようなファイル名を付けています。
また、
これまでと同じように、
GCC が生成したアセンブリ言語プログラムから、
内容の把握に直接必要ないと思われる疑似命令等を削除し、
筆者がコメントを付けたものに、
~foo.ss~ や ~foo-32.ss~ のようなファイル名を付けています。

以下に、
32 ビット版の ~add-32.ss~ (図 [[fig:x86-64/add-32.ss]]) と 64 ビット版の ~add.ss~ (図 [[fig:x86-64/add.ss]]) を示します。

#+caption: x86-64/add-32.ss
#+label: fig:x86-64/add-32.ss
#+include: "code/x86-64/add-32.ss" src asm

#+caption: x86-64/add.ss
#+label: fig:x86-64/add.ss
#+include: "code/x86-64/add.ss" src asm

「あれ、
何かの間違いかな?」
と思うほど 2 つのファイルはそっくりです。
~add.ss~ (図 [[fig:x86-64/add.ss]]) は 64 ビット環境でコンパイルしたものですが、
64 ビットらしさがほとんど見られません。

32 ビット版と 64 ビット版で使用されているレジスタが違いますが、
これは本質的な違いではありません。
例えば、
2 つのファイルの中の対応する ADD 命令を見ると、
32 ビット版では
#+begin_src asm
	addl	$1, %esi		# ESI ← <+> 1
#+end_src
ですが、
64 ビット版では
#+begin_src asm
	addl	$1, %ebp		# EBP ← <+> 1
#+end_src
となっています。
使用されているレジスタが違いますが、
プログラムのロジックとしてはどちらも同じです。

#+begin_note
64 ビット環境の ABI では、
関数の呼び出し側はレジスタ RBX、
RBP、
R12〜R15 を破壊してはいけない (関数の呼び出し前後で値を書き換えてはいけない) という約束になっています。
このため 64 ビット版の GCC は、
レジスタ RBP と RBX を退避するレジスタに選択している (その結果として、
ADD 命令が使用するレジスタ名が変更になっている) と思われます。
#+end_note

32 ビット版と 64 ビット版での意味のある違いは、
関数 ~main~ の入口と出口でプッシュおよびポップしているレジスタの大きさです。
Intel 64 アーキテクチャでは汎用レジスタの大きさが 64 ビットですので、
64 ビット版 (図 [[fig:x86-64/add.ss]]) では、
64 ビットのレジスタ RBP および RBX をプッシュおよびポップしています。

つまりこれは、
アセンブリ言語プログラムのレベルで見れば、
C 言語で書かれたプログラム ~add.c~ を 64 ビット環境でコンパイルしても、
64 ビット化のメリットは何もない (むしろデメリットだけがある) ということを意味します。
プログラム ~add.c~ は ~int~ 型の整数 (32 ビット) しか使っていませんが、
64 ビット環境ではレジスタの大きさが 64 ビットになっていますので、
レジスタの退避・復帰に要する処理が増えています。

こまでのところ、
あまり Intel 64 アーキテクチャの「64 ビットらしさ」は感じられませんが、
アセンブリ言語プログラムをアセンブルし、
機械語になれば変化が見られるでしょうか。
2 つのファイル ~add-32.ss~ および ~add.ss~ をアセンブルします。
これらのファイルは、
GCC が生成したアセンブリ言語プログラムから多くの疑似命令を削除したものですが、
このままアセンブルできます。

GAS でアセンブルし、
どのような機械語に変換されるのかを見てみます。
以下のように、
2 つのファイル ~add-32.ss~ および ~add.ss~ を GAS でアセンブルした時の、
アセンブル結果をそれぞれファイル ~add-32.lst~ (図 [[fig:x86-64/add-32.lst]]) および ~add.lst~ (図 [[fig:x86-64/add.lst]]) に保存します。
なお 32 ビット版の ~add-32.ss~ をアセンブルするときには GAS に ~-32~ オプションを付け、
32 ビット環境向けにアセンブルするよう指示します。
#+begin_src sh
$ as -32 -a add-32.ss >add-32.lst ← 32 ビット版は「-32」オプションを付ける
$ as -a add.ss >add.lst
#+end_src

#+caption: x86-64/add-32.lst
#+label: fig:x86-64/add-32.lst
#+include: "code/x86-64/add-32.lst" src asm

#+caption: x86-64/add.lst
#+label: fig:x86-64/add.lst
#+include: "code/x86-64/add.lst" src asm

32 ビット版と 64 ビット版のそれぞれにおいて、
アセンブリ言語の命令が、
どのような機械語に変換されているかを見てみましょう。
例えば、
ファイル ~add-32.lst~ 中の
#+begin_src asm
   3 0000 56       		pushl	%esi
   4 0001 53       		pushl	%ebx
   5              		## i = 123
   6 0002 BE7B0000 		movl	$123, %esi		# ESI ← 123
   6      00
#+end_src
は、
2 つの PUSH 命令と 1 つの MOV 命令が、
0x56、
0x53、
0xbe、
0x7b、
0x00、
0x00、
0x00 に変換されたことを示しています。
ファイル ~add.lst~ 中の上記に対応する箇所は
#+begin_src asm
   3 0000 55       		pushq	%rbp
   4 0001 53       		pushq	%rbx
   5              		## i = 123
   6 0002 BD7B0000 		movl	$123, %ebp		# EBP ← 123
   6      00
#+end_src
となっており、
2 つの PUSH 命令と 1 つの MOV 命令が、
0x55、
0x53、
0xbd、
0x7b、
0x00、
0x00、
0x00 に変換されたことを示しています。

2 つのファイルをじっくり比較すると、
「32 ビット版も 64 ビット版も、
生成される機械語は同じようなもの」であることがわかります。
機械語のバイト列は異なりますが、
これは 32 ビット版と 64 ビット版で使用されているレジスタが異なるからです。
32 ビット版も 64 ビット版も、
どちらも機械語の長さは合計 21 バイトです。
32 ビット版も 64 ビット版で、
プッシュおよびポップしているレジスタの大きさが異なっていましたが、
機械語レベルで見れば、
例えば、
32 ビット版では
#+begin_src asm
   4 0001 53       		pushl	%ebx
#+end_src
となっているのに対し、
64 ビット版では
#+begin_src asm
   4 0001 53       		pushq	%rbx
#+end_src
となっており、
*どちらも同じ機械語* の 0x53 になっています。

*** 機械語の構成と REX プレフィックス

IA-32 アーキテクチャ (32 ビット) と Intel 64 アーキテクチャ (64 ビット) で、
機械語がほとんど変わらない、
というのはどういう仕組みなのでしょうか?
Intel 64 アーキテクチャでは、
レジスタの数も倍の 16 に増えて、
命令のオペランドも 64 ビット化されたはずです。
おまけに、
「命令ポインタ相対アドレス指定」のような新しいアドレス指定モードも追加されました。
オペコードや命令語の構成を変更せずに、
このような拡張が実現できるはずはありません。

そこで、
オペランドの種類や大きさが異なる MOV 命令や ADD 命令が、
どのような機械語にアセンブルされるのかを見てみましょう。
ここではそのための例として、
さまざまな MOV 命令や ADD 命令を並べたプログラムを 2 種類作成しました。
これらのプログラムのアセンブル結果を ~ex-32.lst~ (32 ビット版、
図 [[fig:x86-64/ex-32.lst]]) および ~ex.lst~ (64 ビット版、
図 [[fig:x86-64/ex.lst]]) に示します。

#+caption: x86-64/ex-32.lst
#+label: fig:x86-64/ex-32.lst
#+include: "code/x86-64/ex-32.lst" src asm

#+caption: x86-64/ex.lst
#+label: fig:x86-64/ex.lst
#+include: "code/x86-64/ex.lst" src asm

これらのファイルを比較すると、
MOV 命令や ADD 命令であれば、
32 ビットでも 64 ビットでも *まったく同じ機械語になっている* ことがわかります。
例えば、
32 ビット版において、
レジスタに即値を加算する
#+begin_src asm
  11 0012 0412                  addb    $0x12, %al              # AL ← <+> 0x12
  12 0014 66053412              addw    $0x1234, %ax            # AX ← <+> 0x1234
  13 0018 05785634              addl    $0x12345678, %eax       # EAX ← <+> 0x12345678
  13      12
#+end_src
は、
64 ビット版における
#+begin_src asm
  13 001f 0412                  addb    $0x12, %al              # AL ← <+> 0x12
  14 0021 66053412              addw    $0x1234, %ax            # AX ← <+> 0x1234
  15 0025 05785634              addl    $0x12345678, %eax       # EAX ← <+> 0x12345678
  15      12
#+end_src
とまったく同じ機械語になっています (2 つのファイル中に記述されている命令数が異なるため、
機械語が配置されたアドレスは異なっています)。

では本題である、
Intel 64 アーキテクチャにおける 64 ビット命令の機械語を見てみましょう。
ファイル ~ex.lst~ 中における 64 ビットの MOV 命令は、
例えば
#+begin_src asm
   7 000b 48B8F0DE              movq    $0x123456789abcdef0, %rax # RAX ← 0x123456789abcdef0
   7      BC9A7856 
   7      3412
#+end_src
という箇所です。
MOV 命令は 64 ビットの即値を記述できる唯一の命令であり、
当然ながら MOV 命令の機械語中に即値である 0x1234 5678 9abc def0 が埋め込まれていることがわかります。
後半の 8 バイトが即値なので、
どうやら最初の 2 バイト (0x48、
0xb8) が 64 ビットの MOV 命令のようです。

ファイル ~ex.lst~ 中の機械語の列を眺めていると、
Intel 64 アーキテクチャにおける機械語の規則性が見えてきます。
特に、
即値を指定しない、
レジスタどうしのデータ転送や算術演算の箇所がわかりやすいでしょう。
#+begin_src asm
   8 0015 88C3                  movb    %al, %bl                # BL ← <+> AL
   9 0017 6689C3                movw    %ax, %bx                # BX ← <+> AX
  10 001a 89C3                  movl    %eax, %ebx              # EBX ← <+> EAX
  11 001c 4889C3                movq    %rax, %rbx              # RBX ← <+> RAX
	:
	:
  17 002a 00C3                  addb    %al, %bl                # BL ← <+> AL
  18 002c 6601C3                addw    %ax, %bx                # BX ← <+> AX
  19 002f 01C3                  addl    %eax, %ebx              # EBX ← <+> EAX
  20 0031 4801C3                addq    %rax, %rbx              # RBX ← <+> RAX
#+end_src
ここから、
バイト (8 ビット) やダブルワード (32 ビット) の MOV 命令や ADD 命令の命令語は 2 バイトであり、
ワード (16 ビット) やクワッドワード (64 ビット) の MOV 命令や ADD 命令の命令語は 3 バイトであることがわかります。

そして、こうした命令語のパターンから、
- MOV 命令のオペコードは 0x88 と 0x89 だろう
- ADD 命令のオペコードは 0x00 と 0x01 だろう
- 0xc3 は「AL/AX/EAX/RAX と BL/BX/EBX/RBX」というオペランドの組み合わせ
  を表しているのだろう
- オペランドがワード (16 ビット) の場合は、命令語の先頭に 0x66 が追加
  されるのだろう
- オペランドがクワッドワード (64 ビット) の場合は、命令語の先頭に 0x48
  が追加されるのだろう
ということがわかってきます。

オペランドがワード (16 ビット) のときの 0x66 は、
IA-32 アーキテクチャにおける *オペランドサイズ・プレフィックス (operand-size prefix)* であり、
CPU のデフォルトのオペランドサイズが 32 ビットのときに、
直後の命令のオペランドの大きさが 16 ビットであることを意味しています。
なおこれは Intel 64 アーキテクチャ固有のプレフィックスではなく、
IA-32 アーキテクチャにもともとあるものです。

オペランドがクワッドワード (64 ビット) のときの 0x48 は、
Intel 64 アーキテクチャにおける *REX プレフィックス (REX prefix)* です。
また上の例における REX プレフィックス (0x48) は、
直後の命令のオペランドの大きさが 64 ビットであることを意味しています。
なお、
REX プレフィックスは、
0x48 だけではなく、
0x40〜0x4f のいずれかを取り、
REX プレフィックスの下位 4 ビット (0〜3 ビット) は表 [[tab:x86-64/rex]] のような意味を持っています。

#+caption: Intel 64 アーキテクチャにおける REX プレフィックス
#+label: tab:x86-64/rex
| ビット | 名称  | 意味                                                           |
|--------+-------+----------------------------------------------------------------|
|      3 | REX.w | オペランドの大きさを 64 ビットにする                           |
|      2 | REX.r | ModR/M の reg フィールドの 4 ビット目                          |
|      1 | REX.x | SIB の index フィールドの 4 ビット目                           |
|      0 | REX.b | ModR/M の r/m フィールドや SIB の base フィールドの 4 ビット目 |

つまり、
Intel 64 アーキテクチャは、
オペコードや命令語の構成を大幅に変更することなく、
REX プレフィックスの導入によって、
オペランドの 64 ビット化やレジスタ数の倍増を実現しています。

#+begin_note
IA-32 アーキテクチャには汎用レジスタは 8 個しかないため、
命令語中にレジスタを指定する箇所は 3 ビットしかありません。
そこで、
REX プレフィックス中の REX.r ビットもあわせて使用することで、
レジスタ指定に 4 ビットを使えるようにしています。
これにより、
Intel 64 アーキテクチャにおいて、
使用できる汎用レジスタの数が 16 に増えています。
#+end_note

*** 大域変数を用いた加算

さきほどのプログラム ~add.c~ (図 [[fig:x86-64/add.c]]) はレジスタ変数を使用していましたが、
次はプログラムを大きく変えずに、
変数の格納先をメモリにしてみましょう。
変数 ~i~ および ~j~ を大域変数として確保するプログラム ~add-static.c~ (図 [[fig:x86-64/add-static.c]]) です。
これまでと同じように、
GCC による最適化を抑止するために、
変数宣言に ~volatile~ キーワードを付けています。

# -Og
#+caption: x86-64/add-static.c
#+label: fig:x86-64/add-static.c
#+include: "code/x86-64/add-static.c" src C

プログラム ~add-static.c~ を GCC によってコンパイルすることによって生成したアセンブリ言語プログラム ~add-static-32.ss~ (32 ビット、
図 [[fig:x86-64/add-static-32.ss]]) および ~add-static.ss~ (64 ビット、
図 [[fig:x86-64/add-static.ss]]) です。
プログラム ~add.c~ と同じように、
32 ビット環境および 64 ビット環境でそれぞれコンパイルし、
生成されたアセンブリ言語プログラムの疑似命令の多くを削除して、
筆者がコメントを追加してあります。
またここでは、
読みやすく、
キレイなコードを生成するように、
最適化オプション ~-Og~ を追加した、
以下のコンパイル時オプションを使用しています。
#+begin_src raw
-fno-pic -fomit-frame-pointer -Og -S
#+end_src
以降のプログラムでも、
特に断りのない限り上記のコンパイル時オプションを使用しています。

#+caption: x86-64/add-static-32.ss
#+label: fig:x86-64/add-static-32.ss
#+include: "code/x86-64/add-static-32.ss" src asm

#+caption: x86-64/add-static.ss
#+label: fig:x86-64/add-static.ss
#+include: "code/x86-64/add-static.ss" src asm

2 つのプログラムを比較すると、
ほとんど同じプログラムであることがわかります。
ただし、
32 ビット版と 64 ビット版で、
MOV 命令のオペランドの *アドレス指定モード* が異なっています。
32 ビット版の ~add-static-32.ss~ では、
#+begin_src sh
	movl	i, %eax			# EAX ← [i]
	movl	j, %edx			# EDX ← [j]
#+end_src
のような絶対アドレスを使用しています。
一方、
64 ビット版の ~add-static.ss~ では
#+begin_src asm
	movl	i(%rip), %eax		# EAX ← [i]
	movl	j(%rip), %edx		# EDX ← [j]
#+end_src
のような *命令ポインタ相対アドレス指定* を使用しています。
前述のとおり ~i(%rip)~ というオペランドは、
通常の間接メモリ参照のような「アドレス = ベースレジスタ RIP + 変位 ~i~」という意味ではありません。
現在のプログラムカウンタから、
ラベル ~i~ までのオフセットを GAS がアセンブル時に計算するため、
「アドレス = ベースレジスタ RIP + ラベル ~i~ までのオフセット」を意味します。

これらのプログラム ~add-static-32.ss~ (32 ビット版) と ~add-static.ss~ (64 ビット版) を機械語にアセンブルすると、
機械語のプログラムの大きさはそれぞれ 56 バイトと 61 バイトになりました。
Intel 64 アーキテクチャでは、
オペランドの大きさが 64 ビットのときは、
機械語に REX プレフィックスを含む必要があるため、
同じようなプログラムであればどうしても 64 ビット版のほうがサイズが大きくなってしまいます。

*** 64 ビットの大域変数を用いた加算

これまでのところ Intel 64 アーキテクチャの良さがほとんど感じられませんが、
32 ビットを超えるデータを扱う場合には 64 ビットのレジスタが役立ちます。

さきほどのプログラム ~add-static.c~ とほとんど同じですが、
変数 ~i~ および ~j~ の型を ~int~ から ~long long~ に変更したプログラム ~add-longlong.c~ です (図 [[fig:x86-64/add-longlong.c]])。
通常、
64 ビット環境では、
~int~ 型の大きさが 32 ビットで、
~long long~ 型の大きさが 64 ビットです。

# -Og
#+caption: x86-64/add-longlong.c
#+label: fig:x86-64/add-longlong.c
#+include: "code/x86-64/add-longlong.c" src C

これまでと同じように、
GCC が生成したアセンブリ言語プログラムの重要な箇所のみを抜粋し、
筆者がコメントを付けたものを ~add-longlong-32.ss~ (32 ビット版、
図 [[fig:x86-64/add-longlong-32.ss]]) および ~add-longlong-32.ss~ (64 ビット版、
図 [[fig:x86-64/add-longlong.ss]]) に示します。

#+caption: x86-64/add-longlong-32.ss
#+label: fig:x86-64/add-longlong-32.ss
#+include: "code/x86-64/add-longlong-32.ss" src asm

#+caption: x86-64/add-longlong.ss
#+label: fig:x86-64/add-longlong.ss
#+include: "code/x86-64/add-longlong.ss" src asm

これらの 2 つのプログラムを比較すると、
ある意味当然ですが、
プログラム中で扱うデータサイズが大きい場合に Intel 64 アーキテクチャが有効だということがわかります。
IA-32 アーキテクチャはレジスタの大きさが 32 ビットなので、
64 ビットの加算は、
#+begin_src asm
	addl	%ecx, %eax		# EAX ← <+> ECX
	adcl	%ebx, %edx		# EDX ← <+> (EBX + CF)
#+end_src
のように、
下位 32 ビットと上位 32 ビットをそれぞれ別々に加算しなければなりません。
#+begin_note
キャリーなしの ADD 命令と、
キャリーありの ADC 命令の組み合わせは、
桁数の多いデータを加算する時の定型処理 ([[sec:x86arith/arithmetic]] 節、
[[sec:avr/reading]] 節) です。
#+end_note

32 ビットの IA-32 アーキテクチャで、
64 ビットの ~long long~ 型を扱うというのは、
ちょうど、
8 ビットの AVR アーキテクチャで、
16 ビットの ~int~ 型を扱うのと似ています。
16 ビットを扱う AVR アーキテクチャのアセンブリ言語プログラムが長かったのと同じように、
64 ビットを扱う IA-32 アーキテクチャのアセンブリ言語プログラムも長くなっています。

*** 関数呼び出しの例 (階乗の計算)

Intel 64 アーキテクチャの利点は 64 ビットのデータを扱えるという点だけではありません。
Intel 64 アーキテクチャは、
IA-32 アーキテクチャと比較してレジスタ数が倍に増えました。
この結果、
関数呼び出しがかなり軽量化されています。

実際のプログラムを見てみましょう。
これまで何度か登場した、
階乗を計算するプログラム ~fact.c~ です (図 [[fig:x86-64/fact.c]])。

# -Og
#+caption: x86-64/fact.c
#+label: fig:x86-64/fact.c
#+include: "code/x86-64/fact.c" src C

これを同じようにコンパイルし、
生成されたアセンブリ言語プログラムを抜粋し、
コメントを付けたものが ~fact-32.ss~ (32 ビット版、
図 [[fig:x86-64/fact-32.ss]]) および ~fact.ss~ (64 ビット版、
図 [[fig:x86-64/fact.ss]]) です。

#+caption: x86-64/fact-32.ss
#+label: fig:x86-64/fact-32.ss
#+include: "code/x86-64/fact-32.ss" src asm

#+caption: x86-64/fact.ss
#+label: fig:x86-64/fact.ss
#+include: "code/x86-64/fact.ss" src asm

さきほどのプログラム ~add-longlong.c~ とは異なり、
データの大きさは 32 ビットの ~int~ 型のままです。
それにもかかわらず、
64 ビット版のアセンブリ言語プログラムのほうが、
全体的に短かくなっていることがわかります。

64 ビット版のプログラムが簡潔になっている最大の原因は、
関数 ~fact~ の引数を *レジスタで渡している* ことです。
32 ビット版のプログラム ~fact-32.ss~ では、
#+begin_src asm
        pushl   $3                      # ESP ← <-> 4, [ESP] ← 3
        call    fact                    # ESP ← <-> 4, [ESP] ← EIP, EIP ← fact
#+end_src
のように、
関数 ~fact~ への引数 ~n~ を毎回スタックに積んでいますが、
これは、
IA-32 アーキテクチャ向け UNIX の ABI でそう定められているからです ([[sec:stack/abi]] 節)。

このように、関数への引数をスタックで渡す場合は、
1. 呼び出し側が引数をスタックに積む必要がある
2. 呼び出された側がスタックから引数を取り出す必要がある
3. 呼び出し側に戻った後、スタックに積んだ引数を片付ける必要がある
ために、
プログラムがどうしても長くなってしまいます。

#+begin_note
他の誰も関数 ~fact~ を使わないのであれば必ずしも ABI に従わなくてもよいのですが、
今回のプログラムでは次のような理由から、
必ず ABI に従わなければなりません。
- 関数 ~fact~ の ~fact~ は大域シンボルである
- ~fact~ は大域シンボルであるから他から呼び出されるかもしれない
- 他から呼び出される可能性があるなら ABI に従わないといけない
#+end_note

一方、
64 ビット版のプログラム ~fact.ss~ では、
関数 ~fact~ への引数 ~n~ を
#+begin_src asm
        movl    $3, %edi                # EDI ← 3
        call    fact                    # RSP ← <-> 8, [RSP] ← RIP, RIP ← fact
#+end_src
のようにレジスタ EDI 経由で渡しています。
これも、
x86-64 向けの GNU/Linux の ABI でそう定められているからです。
64 ビット環境向けの ABI で、
64 ビット以下の整数はレジスタ RDI、
RSI、
RDX、
RCX、
R8、
R9 をこの順に使用すると定められています。
関数の引数をレジスタ経由で渡す場合は、
1. 呼び出し側が引数をレジスタに格納するのは簡単 (すでに格納済みかもし
   れない)
2. 呼び出された側がレジスタの値を参照するのも簡単
3. 呼び出し側に戻ったあと、レジスタに格納したあとの片付けは不要
のように、
よいことばかりだといえます。

必ずしも「IA-32 アーキテクチャと比較して、
Intel 64 アーキテクチャでは関数呼び出しが軽量化されている」というわけではないのですが、
単純化すると、
#+begin_quote
Intel 64 アーキテクチャでは汎用レジスタが 16 個に増えた。
SIMD 命令用の XMM レジスタも必ず利用可能であり、
しかもレジスタ数が 16 に増えている。\\ 
\rightarrow したがって、
関数への引数 (整数および浮動小数点数) をレジスタ経由で渡せる余裕がある。\\ 
\rightarrow そのため、
関数への引数を主にレジスタで渡すように ABI を決めることができた。\\ 
\rightarrow その結果、
64 ビット環境では関数呼び出しが軽量になった。
#+end_quote
という関係になっているのです。

なお、
32 ビット版の ~fact-32.ss~ 中の関数 ~main~ の最初と最後で、
#+begin_src asm
main:
        leal    4(%esp), %ecx           # ECX ← ESP + 4
        andl    $-16, %esp              # ESP ← <&> 0xfffffff0
        pushl   -4(%ecx)                # ESP ← <-> 4, [ESP] ← ECX - 4
	:
	:
        movl    -4(%ebp), %ecx          # ECX ← [EBP - 4]
        leave                           # ESP ← EBP, EBP ← [ESP], ESP ← <+> 4
        leal    -4(%ecx), %esp          # ESP ← ECX - 4
        ret                             # EIP ← [ESP], ESP ← <+> 4
#+end_src
のような、
一見するとよくわからない処理を行っていますが、
これはスタックの *アライメント (alignment)* をそろえるためのもので、
関数 ~fact~ を呼び出すときに、
スタックポインタの値が 16 の倍数となるように調整しています。
関数 ~fact~ を呼び出すだけであればアライメントをそろえる必要はないのですが、
GCC はデフォルトでアライメントをそろえるような機械語プログラムを生成するようです。

#+begin_note
ここでは、
GCC の最適化オプションとして ~-Og~ を使用しています。
32 ビット版でも、
GCC の最適化のレベルを上げていくことで、
省略できるスタック操作は省略されるため、
32 ビット版と 64 ビット版の差はもっと小さくなります。
GCC のコンパイル時オプションの設定によっては、
まったく違って見えるようなアセンブリ言語プログラムが生成されることもあります。
#+end_note

*** 浮動小数点数演算の例 (ユークリッド距離の計算)

Intel 64 アーキテクチャの良さが感じられる例をもう 1 つ見てみましょう。
浮動小数点数を扱うプログラム ~dist.c~ です。
[[sec:x86fp/x87-inst]] 節で紹介したプログラム ~dist-c.c~ (図 [[fig:x86fp/dist-c.c]]) と同じものです。
2 次元平面上の点 ($x$, $y$) の原点からのユークリッド距離を計算するプログラムです。

# -Og -ffast-math
#+caption: x86-64/dist.c
#+label: fig:x86-64/dist.c
#+include: "code/x86-64/dist.c" src C

ここでは、
以下のコンパイル時オプションを使用して、
C 言語で書かれたプログラム ~dist.c~ をアセンブリ言語プログラムに変換します。
#+begin_src raw
-fno-pic -fomit-frame-pointer -ffast-mat -Og 
#+end_src
これまでに登場していないオプションは ~-ffast-math~ です。
このオプションは、
浮動小数点数の演算に対して、
演算結果の精度が変化する可能性のあるような (積極的な) 最適化を有効にします。

これまでと同じように、
生成されたアセンブリ言語プログラムを抜粋し、
筆者がコメントを付けたものを ~dist-32.ss~ (32 ビット版、
図 [[fig:x86-64/dist-32.ss]]) および ~dist.ss~ (64 ビット版、
図 [[fig:x86-64/dist.ss]]) に示します。

#+caption: x86-64/dist-32.ss
#+label: fig:x86-64/dist-32.ss
#+include: "code/x86-64/dist-32.ss" src asm

#+caption: x86-64/dist.ss
#+label: fig:x86-64/dist.ss
#+include: "code/x86-64/dist.ss" src asm

まず、
32 ビット版と 64 ビット版で、
*使用されている命令がまったく違う* ことがわかります。
これは、
[[sec:x86simd/ia32]] 節で述べたように、
Intel 64 アーキテクチャでは浮動小数点数演算には、
x87 FPU 命令ではなく、
*SIMD 命令を使う* からです。

つまり、
32 ビット版のプログラム ~dist-32.ss~ (図 [[fig:x86-64/dist-32.ss]]) は x87 FPU 命令 ([[sec:x86fp/x87-inst]] 節) を使って、
倍精度浮動小数点数の演算を行っています。
32 ビット環境では、
SSE 以降の SIMD 拡張が利用できるとは限らないため、
GCC は x87 FPU 命令を使用するような機械語プログラムを生成します。

#+begin_note
もちろん、
GCC のコンパイル時オプションに、
例えば
#+begin_src raw
-msse -mfpath=sse
#+end_src
などを追加すれば、
32 ビット環境であっても浮動小数点数演算に SIMD 命令を使うこともできます。
#+end_note

一方、
64 ビット版のプログラム ~dist.ss~ (図 [[fig:x86-64/dist.ss]]) は SSE 拡張の SIMD 命令を使用して倍精度浮動小数点数の演算を行っています。
Intel 64 アーキテクチャの CPU では、
SSE2 までの SIMD 拡張が必ず利用できるので、
GCC は *SIMD 命令を使用するような機械語プログラムを生成* します。

#+begin_note
32 ビット環境でも、
コンパイル時オプションを指定すれば SIMD 命令を使えるのと同じように、
64 ビット環境でも x87 FPU 命令を使うことはできます。
GCC のコンパイル時オプションに、
例えば
#+begin_src raw
-mfpmath=387
#+end_src
などを追加すれば、
64 ビット環境であっても浮動小数点数演算に x87 FPU 命令を使います。
ただし、
一般には SSE 命令を用いた浮動小数点数演算のほうが、
x87 FPU 命令を用いたものよりも高速なので、
x87 FPU 命令を使うメリットはほとんどありません。
#+end_note

さきほどの ABI の違いと同じように、
x87 FPU 命令の代わりに SIMD 命令を使うというのも、
Intel 64 アーキテクチャそのものが直接の原因ではありません。
IA-32 アーキテクチャと Intel 64 アーキテクチャの違いではなく、
「64 ビット環境であれば SSE2 拡張まで利用できる」ことに起因しています。
とはいえ、
Intel 64 アーキテクチャでは、
32 ビットのと時と比べてレジスタ XMM および YMM の数が倍に増えているためで、
やはり 64 ビット環境のメリットは大きいといえるでしょう。

さて、
2 つのプログラム (図 [[fig:x86-64/dist-32.ss]] と図 [[fig:x86-64/dist.ss]]) をもう少し詳しく見てみましょう。

まず、
2 つのプログラムにおいて、
ユークリッド距離を計算している箇所は *どちらも 7 命令* です。
x87 FPU 命令でも、
SIMD 命令でも、
- ラベル ~x~ および ~y~ からのデータの読み込みにそれぞれ 1 命令ずつ
- $x$ および $y$ の値の 2 乗にそれぞれ 1 命令ずつ
- 2 乗した値の和の計算に 1 命令
- 平方根の計算に 1 命令
- 計算結果をメモリに書き戻すのに 1 命令
という 7 命令で構成されています。

ここで、
*平方根の計算がたったの 1 命令* (x87 FPU では FSQRT 命令、
SSE 命令では SQRTSD 命令) で実行できているのは、
GCC のコンパイル時オプションに ~-ffast-math~ を指定しているからです。
C 言語で書かれたプログラム ~dist.c~ では、
平方根の計算は C 言語の標準ライブラリに含まれる関数 ~sqrt~ を呼び出しています。
このため、
通常は、
GCC は関数 ~sqrt~ を呼び出すアセンブリ言語プログラムを生成します。
ここでは、
~-ffast-math~ オプションを指定しているため、
GCC は、
「必ずしも演算結果が同一にならないかもしれない」けれどもより高速なプログラムへとコンパイルしています。

また、
32 ビット版のプログラム (図 [[fig:x86-64/dist-32.ss]]) は、
[[sec:x86fp/x87-inst]] 節で説明した x87 FPU のアセンブリ言語プログラム ~dist.s~ (図 [[fig:x86fp/dist.s]]) とほぼ同じであることがわかります。
GCC のコンパイル時オプションに ~-ffast-math~ を指定した結果、
筆者が書いた x87 FPU のアセンブリ言語プログラム (図 [[fig:x86fp/dist.s]]) と同じプログラムが得られています。

ただし、
64 ビットのプログラム (図 [[fig:x86-64/dist.ss]]) は、
[[sec:x86simd/trace]] 節で説明した SIMD 命令のアセンブリ言語プログラム ~dist.s~ (図 [[fig:x86simd/sse-dist/dist.s]]) ほど最適化されていません。
XMM レジスタの大きさは 128 ビットなので、
倍精度の浮動小数点数であれば 2 つまとめて格納できます。
このため、
SIMD 命令を使えば図 [[fig:x86simd/sse-dist/dist.s]] のように 5 命令でユークリッド距離の計算が可能です。

なお、
C 言語で書かれたプログラムにおける
#+begin_src C
double x = 1.23;
#+end_src
が、アセンブリ言語プログラムでは
#+begin_src asm
x:	## double x = 1.23
        .long   2061584302
        .long   1072934420
#+end_src
のようになっており、
初めて見ると何がどうなっているのかわからないかもしれません。
これは、
64 ビットの浮動小数点数を、
*32 ビットの符号なし整数 2 つ* で表現しているためです。

C 言語の ~double~ 型は 64 ビットの倍精度浮動小数点数です。
1.23 を倍精度の浮動小数点数として符号化すると 0x3ff3ae147ae147ae という 64 ビットの値になりますが、
この上位 32 ビットと下位ビットは、
それぞれ 0x3ff3 ae14 および 0x7ae1 47ae です。
これらの値を符号付き整数として解釈すると、
それぞれ 1 072 934 420 および 2 061 584 302 となります。
GCC は、
64 ビットの倍精度浮動小数点数を、
2 つの 32 ビットの符号付き整数として解釈したアセンブリ言語プログラムを生成しています。

** 章末問題
<<sec:x86-64/quiz>>

1. レジスタ RAX の値を、レジスタ RBX と R8 の両方にコピーするアセンブリ
   言語プログラムを示せ。

   #+begin_answer
   プログラムの例: ~copy.s~ ([[fig:x86-64/ex/copy.s]])
   #+caption: x86-64/ex/copy.s
   #+label: fig:x86-64/ex/copy.s
   #+include: "code/x86-64/ex/copy.s" src asm
   #+end_answer

2. レジスタ RAX の値の下位 32 ビットを、レジスタ RBX の下位 32 ビット
   にコピーするアセンブリ言語プログラムを示せ。ただし、レジスタ RBX の
   上位 32 ビットは変化させないこと。

   #+begin_answer
   64 ビットのレジスタの下位 32 ビットだけを操作する場合には、
   COMET II ([[sec:comet/quiz]] 節)、
   AVR アーキテクチャ ([[sec:avr/quiz]] 節)、
   Armv8-A アーキテクチャ ([[sec:arm/quiz]] 節) 等と同じように、
   論理積 (AND 命令) と論理和 (OR 命令) を組み合せればよい。

   プログラムの例: ~copy-low.s~ ([[fig:x86-64/ex/copy-low.s]])
   #+caption: x86-64/ex/copy-low.s
   #+label: fig:x86-64/ex/copy-low.s
   #+include: "code/x86-64/ex/copy-low.s" src asm

   Intel 64 アーキテクチャでは、
   AND 命令のオペランドに 64 ビットの即値を記述できない。
   このため、
   上のプログラムでは、
   ビットマスクの値 (0xffffffff00000000) をいったん ECX レジスタに格納してから、
#+begin_src asm
        and     %rcx, %rbx                # RBX ← <&> RCX
#+end_src
   によってレジスタ RBX の上位 32 ビットを取り出している。

   また、
#+begin_src asm
        mov     %eax, %eax                # EAX ← EAX
#+end_src
   によって、
   レジスタ RAX の上位 32 ビットをゼロでクリアしている。
   Intel 64 アーキテクチャでは、
   32 ビットのレジスタに書き込むと 64 ビットレジスタの上位 32 ビットがゼロでクリアされる。
   この性質を利用し、
   レジスタ EAX の値をそれ自身にコピーすることによって、
   レジスタ RAX の上位 32 ビットをゼロでクリアしている。
   #+end_answer

3. レジスタ RAX の値の下位 32 ビットを、レジスタ RBX の下位 32 ビット
   にコピーするアセンブリ言語プログラムを示せ。ただし、レジスタ RBX の
   上位 32 ビットはゼロでクリアすること。

   #+begin_answer
   Armv8-A アーキテクチャの場合 ([[sec:arm/quiz]] 節) と同じように、
   対応する 32 ビットレジスタに書き込めば、
   64 ビットレジスタの上位 32 ビットがゼロでクリアされる。
   したがって、
   レジスタ EBX に書き込めば、
   レジスタ RBX の上位 32 ビットは自動的にクリアされる。

   プログラムの例: ~copy-low-clear.s~ ([[fig:x86-64/ex/copy-low-clear.s]])
   #+caption: x86-64/ex/copy-low-clear.s
   #+label: fig:x86-64/ex/copy-low-clear.s
   #+include: "code/x86-64/ex/copy-low-clear.s" src asm
   #+end_answer

4. レジスタ RAX と R8 の値を交換するアセンブリ言語プログラムを示せ。

   #+begin_answer
   IA-32 アーキテクチャ [[(sec:x86trans/transfer]] 節) と同じく、
   Intel 64 アーキテクチャでもレジスタの値を交換する XCHG 命令が利用できる。

   プログラムの例: ~swap.s~ ([[fig:x86-64/ex/swap.s]])
   #+caption: x86-64/ex/swap.s
   #+label: fig:x86-64/ex/swap.s
   #+include: "code/x86-64/ex/swap.s" src asm
   #+end_answer

5. スタックポインタ (レジスタ RSP) の値をレジスタ RAX にコピーするアセ
   ンブリ言語プログラムを示せ。

   #+begin_answer
   Intel 64 アーキテクチャでは、
   スタックポインタ (レジスタ RSP) は汎用レジスタの 1 つであるため、
   MOV 命令によってスタックポインタの値をコピーできる。

   プログラムの例: ~copy-sp.s~ ([[fig:x86-64/ex/copy-sp.s]])
   #+caption: x86-64/ex/copy-sp.s
   #+label: fig:x86-64/ex/copy-sp.s
   #+include: "code/x86-64/ex/copy-sp.s" src asm
   #+end_answer

6. プログラムカウンタ (レジスタ RIP) の値をレジスタ RAX にコピーするア
   センブリ言語プログラムを示せ。

   #+begin_answer
   IA-32 アーキテクチャでは、
   プログラムカウンタ (レジスタ EIP) の値を取得するには一工夫必要であった ([[sec:x86ctrl/quiz]] 節) が、
   Intel 64 アーキテクチャでは LEA 命令と命令ポインタ相対アドレス指定を使用すれば簡単に取得できる。

   LEA 命令は、
   出所オペランドに指定したメモリロケーションの実効アドレスを、
   宛先オペランドに指定したレジスタに格納する命令である。
   メモリロケーション「~(%rip)~」の実効アドレスはレジスタ RIP の値と等しい。

   プログラムの例: ~copy-pc.s~ ([[fig:x86-64/ex/copy-pc.s]])
   #+caption: x86-64/ex/copy-pc.s
   #+label: fig:x86-64/ex/copy-pc.s
   #+include: "code/x86-64/ex/copy-pc.s" src asm
   #+end_answer

7. C 言語で書かれた、数十行程度の短いプログラムを作成するか、または入
   手せよ。[[sec:x86-64/reading]] 節の方法を真似て、そのプログラムを、32
   ビット環境および 64 ビット環境向けにコンパイルして得られたアセンブ
   リ言語プログラムを比較・分析せよ。

