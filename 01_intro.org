# -*- Org -*-
# 
# Copyright (c) 2021, Hiroyuki Ohsaki.
# All rights reserved.
# 

# This document is licensed under a Creative Commons
# Attribution-NonCommercial-ShareAlike 4.0 International License (CC
# BY-NC-SA 4.0).

# This document is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# Creative Commons License for more details.

# You should have received a copy of the license along with this work.
# If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

* はじめに
<<ch:intro>>

** はじめに

本書では、アセンブリ言語による低レベルのプログラミングを通して、
- コンピュータはどのように動いているのか
- コンピュータはどこが、どのようにすごいのか
- どうすればコンピュータの可能性を引き出せるのか
などを体系的に学びます。

アセンブリ言語プログラミングにおける、
- あれをしなければいけない
- これをしてはいけない
- それはこういう決まりになっている
などの HOW (どうすればいいか) よりもむしろ、
- なぜしなければいけないのか?
- なぜしてはいけないのか?
- なぜそういう決まりになっているのか?
などの WHY (なぜそうなのか) をできるだけ解説するよう心掛けました。
このため、
本書を通じて、
コンピュータやアセンブリ言語プログラミングの概念・仕組み・原理を理解しながら学ぶことができます。

本書の特徴の 1 つは、
8 ビットから 64 ビットまで、
特徴がまったく異なる CPU の命令セットアーキテクチャを、
統一的な視点から解説しているという点です。
具体的には、
現在広く使われている、
以下の 5 種類の命令セットアーキテクチャを取り上げます。
- インテル IA-32 アーキテクチャ (x86) (32 ビット、CISC)
- インテル Intel 64 アーキテクチャ (x86-64) (64 ビット、CISC)
- 仮想コンピュータ COMET II (16 ビット、CISC)
- Atmel AVR アーキテクチャ (8 ビット、RISC)
- Arm Armv8-A アーキテクチャ (64 ビット、RISC)
それぞれのアーキテクチャにおいて何が共通で、
何が異なっているのかを、
俯瞰 (ふかん) した形で眺めることにより、
アセンブリ言語プログラミングを「深く」学ぶことができます。

さらに、
以下のような発展的なアセンブリ言語プログラミングについても説明します。
- 浮動小数点数演算命令 (x87 FPU)
- SIMD 命令 (MMX/SSE/SSE2/AVX/AVX2/AVX-512)

本書を通してアセンブリ言語プログラミングを習得し、
ぜひ、
「自分が書きたいプログラム」をアセンブリ言語で書いてみてください。
CPU が持つ潜在能力を最大限に引き出せるとともに、
「ああ、
コンピュータとはこういうものだったのか!」という実感が得られると思います。

なお、
本書のサポートページは以下にあります。
本書に掲載しているプログラムのソースコードや、
本書の内容に関する関連情報や掲示板を用意しています。

- https://github.com/h-ohsaki/asm

最後に、
本書の執筆に力を貸してくださったすべての方々に心から感謝いたします。

Enjoy!

** プログラムのソースコードや実行結果のファイルについて

本書に掲載しているプログラムのソースコードは、
以下のサポートサイトからダウンロードできます。

- https://github.com/h-ohsaki/asm

上記のページから、
「リスト < リスト番号 > ファイル名」 (例: リスト 1.2 ~asm/add.s~) のように、
リストとして掲載しているすべてのファイルをダウンロードすることができます。
例えば、
「リスト 1.2 ~asm/add.s~」の場合、
~asm/add.s~ がファイルのパス名です。
ディレクトリ ~asm~ 以下にある、
~add.s~ という名前のファイルです。
すべてのテキストファイルは、
文字エンコーディングが UTF-8 で
改行コードが LF です ([[ch:char]] 章)。

本書に掲載しているファイルの拡張子には以下のようなものがあります。

| 拡張子 | 説明                                                                           |
|--------+--------------------------------------------------------------------------------|
| ~.s~   | アセンブリ言語プログラムのソースコード (COMET II 以外のすべてのアーキテクチャ) |
| ~.ss~  | GCC が生成したアセンブリ言語プログラムを抜粋したもの                           |
| ~.lst~ | アセンブリ言語プログラムのアセンブル結果                                       |
| ~.cas~ | アセンブリ言語プログラムのソースコード (COMET II のみ)                         |
| ~.com~ | CASL II アセンブラが出力した機械語ファイル (COMET II のみ)                     |
| ~.c~   | C 言語で書かれたプログラムのソースコード                                       |
| ~.py~  | Python 言語で書かれたプログラム (スクリプト)                                   |
| ~.pl~  | Perl 言語で書かれたプログラム (スクリプト)                                     |
| ~.sh~  | シェルスクリプト (sh 系のシェル (例: GNU Bash))                                |
| ~.txt~ | テキストファイル                                                               |
| ~.csv~ | CSV ((Comma-Separated Values) 形式のファイル                                   |
| ~.tsv~ | TSV (Tab-Separated Values) 形式のファイル                                      |

#+begin_note
なお、
本書では、
書籍のレイアウトの都合上、
上記のファイルを一部編集したものを掲載しています。
例えば、
プログラムリストがページ幅に収まるように、
元々のプログラムのインデントを一部削除しています。
#+end_note

** 動作確認環境

本書に掲載しているプログラムは、
以下の環境で動作確認しました。

- Debian GNU/Linux 11.0 (bullseye) (i386 および amd64)
- GNU GCC バージョン 10.2.1 20210110
- GNU binutils バージョン 2.35.2
- GNU GDB バージョン 10.1.90.20210103-git
- casl バージョン 1.0 (https://pypi.org/project/casl/)

本書の内容の大部分は、
GNU のツールチェイン (https://en.wikipedia.org/wiki/GNU_toolchain) が利用できる環境であれば、
GNU/Linux 以外のオペレーティングシステム (Windows や macOS 等) 上でも同じように実行できると思います。

ただし、
AVR アーキテクチャや Armv8-A アーキテクチャ向けのクロスコンパイル/アセンブル環境の構築や、
AVR シミュレータや ARM AArch64 エミュレータのインストール/セットアップは大変かもしれません。

そのため、
本書で使用しているツールやライブラリ一式をインストールした Docker コンテナを、
Docker Hub で公開しています。

- Debian GNU/Linux (bullseye) (i386) 
  - https://hub.docker.com/r/hohsaki/asm-i386
- Debian GNU/Linux (bullseye) (amd64)
  -  https://hub.docker.com/r/hohsaki/asm

Docker が利用できる環境であれば、
Debian 以外の GNU/Linux でも、
また、
Windows や macOS 上でも上記のコンテナを利用できます。
ただし、
コンテナのアーキテクチャが i386 および amd64 ですので、
インテルもしくは AMD の CPU を搭載したコンピュータが必要です。

Intel 64 アーキテクチャ ([[ch:x86-64]] 章) 以外のすべての演習には、
32 ビット版のコンテナ (asm-i386) が使用できます。
Docker エンジンを動作させているホストコンピュータが 64 ビット (x86-64/amd64) でも、
32 ビット版のコンテナを動作させることが可能です。
したがって、
例えば 64 ビット版の Windows 上で、
上記の 32 ビット版 (i386) の Docker コンテナ (asm-i386) を利用できます。

ただし、
Intel 64 アーキテクチャの演習には、
当然ですが 64 ビット版 (amd64) の Docker コンテナ (asm) が必要です。

** 本書の構成

本書は 18 章で構成されています。
本書は教科書のような構成になっているため、
後半の章の説明は、
それ以前の章の内容を理解していることを前提としています。
このため、興味のある章を選んで読むのではなく、
1 章から順番に読んでゆくことをおすすめします。

各章では、
実際のアセンブリ言語プログラムの例を示しながら、
コンピュータのしくみや、
アセンブリ言語プログラミングの基礎から応用までを幅広く学びます。

本書に掲載されているプログラムのソースコードや、
それぞれのプログラムの実行結果を眺めるだけでも有益だとは思います。
しかし、
ぜひ実際に自分で手を動かして、
アセンブリ言語プログラムをアセンブルし、
デバッガを使って機械語プログラムの動作をトレースしてください。
アセンブリ言語を使った低レベルプログラミングの楽しさを、
ぜひ実際に体感してください。

** 本書における表記法
<<sec:intro/conventions>>

本書では、
重要な語句や、
特に強調すべき箇所は *ゴシックフォント* で示しています (例: *ゴシック (Gothic)* とは、
活字の書体の一つです。
太く、
角ばった書体のことです。)

また、
プログラムのファイル名や、
プログラムのソースコード中のシンボルやラベルは ~固定幅フォント~ で表記しています (例: ファイル ~add.c~ 中の関数 ~main~ は大域的なシンボルです)。

シェルの実行例も、以下のように ~固定幅フォント~ で示しています。
#+begin_src sh
$ ls
arm/  avr/   comet/  inline/  stack/   tr-regs/   x86-64/    x86ctrl/  x86regs/  x86trans/
asm/  char/  gas/    number/  tr-mem/  tr-stack/  x86arith/  x86fp/    x86simd/
#+end_src
先頭のドル記号 (~$~) はシェルのプロンプトです (入力するコマンドの一部ではありません)。

UNIX のマニュアルページや GNU のドキュメント (info) は /イタリック/ で表記しています。
UNIX のマニュアルページは /プログラム (数字)/ のように (例: /ls(1)/)、
また、
GNU のドキュメントは /(名前) セクション/ のように表記しています (例: /(as)Invoking/)。

** 本書に関する FAQ (よくある質問とその答え)

何かについて学びたい時は、
早い段階で FAQ (Frequently Asked Questions; よくある質問) を見るというのが、
多くの場合、
効率的な方法です。

そこで、
本書について理解する上で役立つと思われる、
「本書に関する FAQ」を用意しました。

#+begin_note
FAQ は Frequently Asked Questions の略ですので、
本来の言葉の意味は Questions (質問の複数形) です。
しかし、
多くの場合、
質問とそれに対する回答がセットになっています。
#+end_note

**** Q. この本を読めば、何が学べますか?

機械語やアセンブリ言語を用いた低レベルのプログラミングを通して、
「コンピュータがどう動いているのか」、
「コンピュータはどのようにすごいのか、
また逆に大したことないのか」、
「どうすればコンピュータの可能性を引き出せるのか」を深く学ぶことができます。

単なる知識の断片をどれだけ吸収してもほとんど無意味です (そういった情報が必要なら Web の検索エンジンやリファレンスマニュアルで十分です)。

本書では、
単に大量の知識を伝えるのではなく、
それらの背後にある「知恵」を伝えることを目的としています。

**** Q. この本は誰に向けて書かれたものですか?

情報系の大学生・大学院生や、
IT エンジニアを対象として書きました。
すべての読者を対象にして書いた本は、
誰の役にも立たないと思いますので、
本書は上記の方々をターゲットにしています。

このため、
中学生・高校生の方には内容が難しすぎる箇所があると思います。
逆に、
ベテランのエンジニアの方には、
くどくど説教臭い箇所もあると思います。

中学生・高校生の方なら、
今の段階で理解できるところだけでも読んでみてください。
ただし、
今の段階では十分理解できないと思いますので、
あと何年かして、
自身のスキルが上がってから、
再度本書に挑戦してみてください。

**** Q. アセンブリ言語は時代遅れだと聞きました。これから学ぶ若者は Web とか Python のような軽量言語を学ぶべきですね?

Yes であり No でもあります。
C 言語を学んだばかりの初心者の方なら、
アセンブリ言語プログラミングよりも、
まずは Python やシェルスクリプトのような軽量言語を学ぶほうがよいでしょう。

一方、
今はやっている技術は、
「すぐに使えなくなる技術」でもあります。
今、
トレンドになっている技術「ナントカ (カタカナのカッコいい名前の技術)」は、
30 年後にはおそらく使われていない技術になっているでしょう。
アセンブリ言語や、
機械語、
コンピュータの仕組みなどは、
コンピュータサイエンスの基盤です。
30 年後には、
CPU の命令セットアーキテクチャは大きく変化しているでしょうが、
本書で学ぶ「知恵」の多くは 30 年後にも役立つと思います。

**** Q. 私にこの本が読めるでしょうか? 

わかりません。

読者を限定せずに、
「本書はあなたにもスラスラ読めます」、
「本書を読めば、
読むだけで驚くほどレベルアップします」と謳っている本があれば、
それはほぼ間違いなく虚偽広告です。

本書に書いてある日本語は読める (日本語の文法解釈はできる) でしょうが、
本書に書かれている内容を理解できるか、
著者である私が伝えようとしている概念を吸収できるかはみなさん次第です。

**** Q. 私はプログラミングが苦手です。そんな私でも大丈夫でしょうか?

情報科学やコンピュータサイエンスを専攻している学生の方や、
コンピュータ技術を専門とする社会人の方であれば、
それは「大丈夫ではない」と思います。

本書が読める/読めない、
本書が役立つ/役立たないの前に、
「プログラミングが苦手なのに、
コンピュータを専門にしている」というのは大変不健全な状況だと思います。

おそらく
#+begin_quote
プログラムがうまく書けない
→ プログラミングが楽しくない
→ プログラミングを学ぶ気になれない
→ だからプログラムがうまく書けな い→ ……
#+end_quote
という負の連鎖に陥っているのではと想像します。
簡単なシェルスクリプトでもいいし、
エディタのマクロでもいいので、
ぜひ簡単なものから始めてください。

プログラミングが苦手な状況で本書を読むと、
かえってアレルギーが増すかもしれません (もちろん、
まるで目が覚めたかのようにプログラミング好きになる可能性もあります)。

**** Q. UNIX を使ったことがないのですが、この本の内容は私に役立ちますか?

はい。

本書では主に UNIX の世界で発展してきた、
GNU のコンパイラや開発ツールを利用してアセンブリ言語プログラミングを説明します。
GNU のツールは、
UNIX 以外のオペレーティングシステム (例えば macOS や Windows) でも利用できるようになりましたが、
やはり UNIX 上で使うのがベストです。

macOS や Windows 上でも、
本書で使用している開発環境を簡単に導入するしくみ (開発のためのツールが揃った Debian GNU/Linux の Docker イメージ) も用意しています。

先人たちの努力のおかげで、
高性能なさまざまな開発ツールが「自由ソフトウェア」として公開されていますし、
これらの導入も非常に簡単になっています。
先人たちの努力に感謝しつつ、
これらの環境をぜひ活用してみてください。

**** Q. この内容で、この価格は高いと思います。安くなりませんか?

なりません。

筆者である私自身は、
金銭的な利益を得ることにはそれほど興味はありませんが、
出版社から書籍を販売するためには、
多くの方々の労力がかっています。
編集、
構成、
図の作成、
レイアウト、
デザイン、
組版、
印刷などに、
多くの方々が関わる多数の工程を経ています。

コンピュータ関連の良質な書籍が世に出るためには、
「良い出版社」が出版活動を継続できる必要があります。
そのためには、
出版にかかった費用に対する正当な対価が支払われることが大切です。

**** Q. この本を読んでアセンブリ言語プログラムを学べば、進学/就職/転職に有利ですか?

有利かもしれませんが、
そういった目的のために学んでも面白くないと思います。

アセンブリ言語プログラミングは、
プログラミングの中ではより高度な技術に分類されます。
低レベルプログラミングを知らなくても、
ある程度のプログラムでは書けますので、
アセンブリ言語のプログラムが書ける人は相対的にどんどん減っています。
アセンブリ言語プログラミングができる人材の数が減っていますので、
相対的にそういった方々の市場価値は高くなるでしょう。

ですが、
「大学受験のための勉強」がつまらないのと同じ理由で、
「進学/就職/転職のための勉強」もつまらないと思います。

アセンブリ言語プログラミングは「はまるとやみつきになる」面白いテーマですので、
勉強ためではなく、
「CPU のしくみを知りたい」、
「アセンブリ言語でプログラムを書いてみたい」、
「逆アセンブラが使えるようになりたい」という純粋な興味をぜひ大切にしてください。

**** Q. この本を一通り読めば、他の本やマニュアルは読まなくても大丈夫ですか?

いいえ。

コンピュータサイエンスや、
コンピュータ、
プログラミング、
その中でさらに限定してアセンブリ言語プログラミングだけを取り上げても、
ワクワクするような広大な世界がみなさんを待っています。

本書だけを読んで「アセンブリ言語プログラミングの学習はおしまい」というのは大変「もったいない」と思います。
本書で学んだことをきっかけの一つとして、
アセンブリ言語プログラミングはもちろんのこと、
さらに奥深くコンピュータやプログラミングを学んでください。

本書は、
個々の CPU のアーキテクチャの詳細ではなく、
「CPU とはそもそも何なのか?
アセンブリ言語プログラミングのエッセンスは何か?」
を伝えることを目指しています。
本書で学ぶことにより、
個々の CPU アーキテクチャを対象にした専門書やリファレンスマニュアルが (なんとなくでも) 読めるようになると思います。

**** Q. この本ではアセンブリ言語プログラミングのすべてが解説されていますか?

いいえ。

上の回答にもあるように、
本書は、
個々の CPU のアーキテクチャの詳細ではなく、
「CPU とはそもそも何なのか?
アセンブリ言語プログラミングのエッセンスは何か?」
を伝えることに焦点を当てています。

したがって、
例えば本書では、
主にユーザレベルのアセンブリ言語プログラミングのみを扱っています。
つまり、
GNU Linux や macOS などのオペレーティングシステムが稼働しているコンピュータ上で動作させるプログラムが主な対象です。

ハードウェアを直接制御するようなアセンブリ言語プログラミングはほとんど扱っていません。
例えば、
オペレーティングシステムを作成するためには、
コンピュータのハードウェアに密着した低レベルプログラミングが不可欠ですが、
本書を読んでもオペレーティングシステムは作成できるようになりません (そういう内容は扱っていません)。

また本書では、
それぞれの CPU アーキテクチャの個々の命令 (MOV 命令や ADD 命令など) の詳細はほとんど説明していません。
主要な、
よく使われる命令の概要のみを紹介しています。
個々の命令の詳細についてはリファレンスマニュアルを参照してください。
本書では、
「ベンダのリファレンスマニュアルが自分で読める」までの知識を提供しています。

**** Q. この本の説明がわからなかったら、直接メールで質問すれば教えてもらえますか?

いいえ。

私の時間が無限にあれば、
個別の質問にもすべて回答したいところではあります。

しかし私の時間は有限ですので、
残念ながらみなさんの個々の質問に回答することは物理的に不可能です。

本書のサポートページを Github 上に設けていますので、
そこに出版後に判明した誤りや追加情報を随時掲載しています。
質問のための掲示板も用意していますので、
そちらに投げてもらえれば誰かから返信を得られるかもしれません。

**** Q. この本の内容は、IA-32/COMET II/AVR/Armv8-A 以外の○○のアーキテクチャにも役立ちますか?

はい。

本書の特徴の一つは、
複数の命令セットアーキテクチャ (インテルの IA-32 アーキテクチャ、
情報処理推進機構の仮想コンピュータ COMET II、
Atmel のマイクロコントローラ向け AVR アーキテクチャ、
Arm 社の低消費電力プロセッサの Armv8-A 64 ビットアーキテクチャ) を、
統一的な視点から、
俯瞰 (ふかん) した形で解説しているという点です。

それぞれのアーキテクチャで共通のもの (世界中の CPU に共通のもの) は何で、
それぞれのアーキテクチャの独自性があるのは何なのかを、
体系的に理解することができます。

これらの異なるアーキテクチャのそれぞれの違いを横断的に理解することができれば、
他のアーキテクチャの理解がとても楽になると思います。

ただし、
本書に限らず、
「(知識 *が*) 役立つ」のではなく「(みなさん *が* 知識を) 役立てる」ものです。
主役は知識ではなく、
あくまでみなさん自身です。
学んだ知識 *が* (自動的に、
知らずしらずのうちに勝手に) 役立ってくれるのではなく、
みなさん *が* (工夫して、
努力して) 知識を役立てるものです。

**** Q. この本の「ネタ」はどこから持ってきましたか? 英語の書籍か、海外のブログか何かですか?

特に「ネタ本」や「ネタサイト」はありませんが、
先人たちのさまざまな書籍や一部のブログを参考にしました。

本書の執筆の過程で、
先人たちが書かれて、
アセンブリ言語プログラミングに関するありとあらゆる書籍を (手に入るだけ) 入手して読みました。
日本語の主だったものは大抵入手して読みましし、
英語の書籍も何冊か読みました。

特に役立ったのは、
ベンダが発行している、
英語版のリファレンスマニュアルやデータシートです。
あとは、
GNU のツールはマニュアルやソースコードが役立ちました。

先人たちが書かれた書籍も参考に、
ただし先人たちと同じ視点でアセンブリ言語プログラミングをとらえても仕方がない (し、
そもそもできない) ため、
基本的には、
私自身の視点で、
私自身が「面白い」と思ったことを中心に書いてあります。

「この本を読めば、
他のアセンブリ言語プログラミングの本は不要」という訳ではなく、
むしろ「この本を読んで、
あわせて他のアセンブリ言語プログラミングの本も楽しむ」とさらに理解の幅が広がると思います。

**** Q. COMET II のことだけ学びたいのですが、20 章だけ読めばいいですか?

いいえ。

本書は、
ある意味、
教科書のような構成になっています。
$n$ 章を理解するためには、
1〜$n - 1$ 章までの説明を理解していることを前提としています。

アセンブリ言語プログラミングに詳しくない人が、
20 章だけ読んでも、
まったく何のことか理解できないと思います。

**** Q. この本の内容に誤りを見つけました。どうすればいいですか?

誤りに気づいたということは、
あなたが本書を真剣に読んで、
ここに書かれている事を理解した (もしくは著者である私よりもより深く理解した) ということを意味します。

すばらしいことですね。
まずは自分自身を賞賛してあげてください。

そもそも人間は間違う生き物です。
私は、
本書の執筆に膨大な時間を費やしましたが、
それでも誤りはゼロにはできません。
世界中にバグのないソフトウェアが存在しないのと同じように、
世界中に誤りのない書籍は存在しません。

誤りを見つけた場合は、
上記のサポートサイトからぜひ報告してください。
他の読者の方々からも見える形で正誤表をできる限り掲載したいと思います。

** 対象とする読者
<<sec:intro/target>>

本書は、以下のような方々を対象としています。

- アセンブラ、逆アセンブラ、デバッガなどを使った低レベルプログラムができるようになりたい人
- さまざまな CPU の哲学や設計思想の違いを具体的に学びたい人
- 自作のプログラムを高速化したい人
- CISC や RISC など CPU のアーキテクチャに興味がある人
- 情報処理関係の資格を取りたい人
- 英語のリファレンスマニュアルを読めるようになりたい人
- C 言語の原因不明のエラーの原因を知って、直せるようになりたい人

また逆に、本書は以下のような方々は対象外です。

- 高校レベルの数学を (まだ) 学んでいない人
- C 言語のプログラムを書けない人
- コマンドラインのツールが使えない人
