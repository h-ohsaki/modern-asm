# -*- Org -*-
# 
# Copyright (c) 2021, Hiroyuki Ohsaki.
# All rights reserved.
# 

# This document is licensed under a Creative Commons
# Attribution-NonCommercial-ShareAlike 4.0 International License (CC
# BY-NC-SA 4.0).

# This document is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# Creative Commons License for more details.

# You should have received a copy of the license along with this work.
# If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

* x86 命令セット (SIMD 命令)
<<ch:x86simd>>

** SIMD (Single Instruction stream, Multiple Data streams) とは
<<sec:x86simd/overview>>

*** フリンの分類基準

コンピュータアーキテクチャを分類する際の基準の 1 つに、
以下のような *フリンの分類基準 (Flynn's taxonomy)* というものがあります。
- *SISD (Single instruction stream, Single data stream)*
- *SIMD (Single instruction stream, Multiple data streams)*
- *MISD (Multiple instruction streams, Single data stream)*
- *MIMD (Multiple instruction streams, Multiple data streams)*

本章で扱う SIMD (Single Instruction stream, Multiple Data stream) は、
フリンの分類基準の 1 つであり、
もともとは並列処理の手法として生まれた、
*単一の命令 (Single Instruction stream)* で、
*複数のデータ (Multiple Data stream)* を処理するという手法です。

[[ch:cpu]] 章で説明したように、
フォン・ノイマン型のコンピュータは、
メモリに格納されている機械語プログラムを 1 つずつ読み込んで順番に実行していきます。
その際、
それぞれの命令は、
[[sec:mem/cpu-model]] 節で CPU 処理の抽象モデルを使って説明したように、
レジスタとメモリの間でデータをコピーしたり、
レジスタやメモリに格納されているデータに対して算術演算や論理演算を行ったりします。

このように、
古典的な CPU は、
単一の命令 (Single Instruction stream) で単一のデータ (Single Data stream) だけを処理するため、
先ほどのフリンの分類基準では SISD として分類されます (図 [[fig:x86simd/sisd]])。
IA-32 アーキテクチャの場合、
例えば、
#+begin_src asm
	movl	$123, %eax
#+end_src
という単一の命令で、
123 がレジスタ EAX に格納されますが、
ここで登場しているのは、
単一の命令 (MOV 命令) と、
単一のデータ (123) だけです。

#+caption: SISD (Single instruction stream, Single data stream)
#+label: fig:x86simd/sisd
#+attr_latex: :width .7\columnwidth
[[./figure/x86simd/sisd.png]]

SIMD も、
SISD と同じように、
一度に実行する命令は 1 つだけ (Single Data stream) ですが、
複数のデータ (Multiple Data streams) をまとめて処理するという点が異なります (図 [[fig:x86simd/simd]])。
機械語の命令は 1 つだけですが、
複数のデータに対して、
同時にデータ転送や算術演算・論理演算などを行います。
例えば、
IA-32 アーキテクチャの場合、
#+begin_src asm
	paddw	%xmm1, %xmm0
#+end_src
という単一の命令で、
128 ビットのレジスタ XMM1 に格納されている 8 個の整数を、
別の 128 ビットのレジスタ XMM0 に格納されている 8 個の整数にそれぞれ加算します。
先ほどの SISD の例とは異なり、
ここでは単一の命令 (PADDW 命令) と複数のデータ (8 個の整数) が記述されています。

#+caption: SIMD (Single instruction stream, Multiple data streams)
#+label: fig:x86simd/simd
#+attr_latex: :width .7\columnwidth
[[./figure/x86simd/simd.png]]

#+begin_note
たった 1 つの命令だけで、
8 個の整数の加算が同時にできるとは、
確かにすごいことだといえます。
技術の進歩により、
スパコンでも何でもない一般のパソコンに搭載されている CPU でこのような高度な処理ができるのです。
#+end_note

最近の CPU では、
複数のコアを持っているものも珍しくありません。
例えば、
インテルの Core i9 シリーズの CPU は 8 個のコアを持っていますが、
このように CPU が複数のコアを持つことで、
単一の CPU で、
複数の命令を同時に実行することができます。
複数のコアを持つ最近の CPU は、
フリンの分類基準によれば MIMD として分類できます (図 [[fig:x86simd/mimd]])。
それぞれのコアが異なる命令やデータを処理するため、
CPU 全体として見れば、
複数の命令 (Multiple instruction streams) で複数のデータ (Multiple data streams) を処理しているからです。

#+caption: MIMD (Multiple instruction streams, Multiple data streams)
#+label: fig:x86simd/mimd
#+attr_latex: :width .7\columnwidth
[[./figure/x86simd/mimd.png]]

#+begin_note
もともと SIMD は「Single Instruction stream, Multiple Data streams」の略称ですが、
最近は stream を削除した、
「Single Instruction, Multiple Data」の略称としても使われています。

英語の data は、
「datum という単数形の名詞の複数形」ですので、
「Multiple Data」は不自然に聞こえます。
「複数あるから data と呼んでいるのに、
わざわざ multiple を付けるのは冗長では?」
とも思えます。
ただし、
特にコンピュータの分野において、
data を単数扱いすることは英語表現として広く定着しています \cite{OLDA}。
#+end_note

*** SIMD 命令の動作をトレースしてみる

IA-32 アーキテクチャの SIMD 命令を説明する前に、
まず、
デバッガを使って、
CPU における SIMD 命令の実際の動作をトレースしてみましょう。

以下は、
SIMD 命令を使って、
8 個の整数の演算を行うプログラム ~add-mul.s~ です (図 [[fig:x86simd/add-mul.s]])。

#+caption: x86simd/add-mul.s
#+label: fig:x86simd/add-mul.s
#+include: "code/x86simd/add-mul.s" src asm

MOVDQA 命令、
PADDW 命令、
PMULLW 命令という見慣れない命令が登場しています。
これらが IA-32 アーキテクチャの SIMD 命令です。
とはいえ命令のニーモニックに、
MOV、
ADD、
MUL という 3 文字が含まれていることから、
これらの命令はそれぞれデータ転送命令、
加算命令、
乗算命令だろうと容易に想像できます。

.data セクション直後の .align は、
ドット (~.~) から始まるため GAS の疑似命令です。
メモリのアライメント (alignment; 整列) を 16 の倍数とするよう GAS に指示しています。

これまでと同じように、
作業ディレクトリに GDB の初期化ファイル ~.gdbinit~ (図 [[fig:x86simd/.gdbinit]]) を作成しておきます。

#+caption: x86simd/.gdbinit
#+label: fig:x86simd/.gdbinit
#+include: "code/x86simd/.gdbinit" src gdb

break コマンドや display コマンドの用法はこれまでどおりです。
break コマンドによってラベル ~_start~ にブレークポイントを設定し、
display コマンドによってプログラムカウンタ ~$pc~ から 4 命令の逆アセンブル結果を表示させています。

見慣れない記述は以下の 2 行です。
#+begin_src gdb
display $xmm0.v8_int16
display $xmm1.v8_int16
#+end_src
これらもデバッガのステップ実行中に値を表示する display コマンドではあるのですが、
ここでは、
レジスタとして、
後ほど説明する XMM レジスタを指定しています。
GDB では、
~$eax~ や ~$ecx~ のように、
レジスタ名の先頭にドル記号 (~$~) を付けますが、
レジスタ XMM0 と XMM1 も同様に ~$xmm0~ や ~$xmm1~ と表記します。
レジスタ名のあとの ~.v8_int16~ は値の表示形式を指定しています。
ここでは、
8 個 (~v8~) の 16 ビットの符号付き整数 (~int16~) として表示しています。

これまでと同じように、
プログラム ~add-mul.s~ をアセンブルおよびリンクしたあと、
生成された実行ファイル ~add-mul~ をデバッガの監視下で実行してみます。
#+begin_src sh
$ as -a -o add-mul.o add-mul.s
$ ld -o add-mul add-mul.o
$ gdb -q add-mul
Reading symbols from add-mul...
(No debugging symbols found in add-mul)
Breakpoint 1 at 0x8049000
(gdb) r ← run コマンドの短縮形
Starting program: /home/ohsaki/code/x86simd/add-mul

Breakpoint 1, 0x08049000 in _start ()
1: $xmm0.v8_int16 = {0, 0, 0, 0, 0, 0, 0, 0}
2: $xmm1.v8_int16 = {0, 0, 0, 0, 0, 0, 0, 0}
3: x/4i $pc
=> 0x8049000 <_start>:  movdqa 0x804a000,%xmm0
   0x8049008 <_start+8>:        movdqa 0x804a010,%xmm1
   0x8049010 <_start+16>:       paddw  %xmm0,%xmm1
   0x8049014 <_start+20>:       pmullw %xmm1,%xmm0
#+end_src

ラベル ~_start~ のアドレスで一時停止し、
レジスタ XMM0 および XMM1 の値が
#+begin_src gdb
1: $xmm0.v8_int16 = {0, 0, 0, 0, 0, 0, 0, 0}
2: $xmm1.v8_int16 = {0, 0, 0, 0, 0, 0, 0, 0}
#+end_src
のように表示されています。
ここから、
レジスタ XMM0 も XMM1 も、
どちらも値は 8 個のゼロであることがわかります。

最初に実行する命令は \inst{movdqa 0x804a000, %xmm0} です。
MOVDQA 命令は、
メモリに格納されている 128 ビットの値をレジスタ XMM0 に読み込むものです (図 [[fig:x86simd/add-mul-1]])。
また、
その際の出所オペランドはメモリアドレス 0x804a000 で、
宛先オペランドはレジスタ %xmm0 となっています。

#+caption: 2 つの MOVDQA 命令の動作
#+label: fig:x86simd/add-mul-1
[[./figure/x86simd/add-mul-1.png]]

1 命令だけステップ実行します。
#+begin_src gdb
(gdb) si ← stepi コマンドの省略形
0x08049008 in _start ()
1: $xmm0.v8_int16 = {0, 1, 2, 3, 4, 5, 6, 7} ← メモリから 8 個の整数が読み込まれた
2: $xmm1.v8_int16 = {0, 0, 0, 0, 0, 0, 0, 0}
3: x/4i $pc
=> 0x8049008 <_start+8>:        movdqa 0x804a010,%xmm1
   0x8049010 <_start+16>:       paddw  %xmm0,%xmm1
   0x8049014 <_start+20>:       pmullw %xmm1,%xmm0
   0x8049018 <_start+24>:       mov    $0x1,%eax
(gdb) 
#+end_src
レジスタ XMM0 に、
メモリ上に格納されている 0〜7 の 8 個の整数が読み込まれました。

次の命令は \inst{movdqa 0x804a010, %xmm1} ですが、
これも先ほどと同じ MOVDQA 命令であり、
オペランドの形式も似ています。
これにより、
0x804a010 番地から格納されている 128 ビットの値がレジスタ XMM1 に読み込まれます。
早速実行して確かめてみましょう。
#+begin_src gdb
(gdb) ← リターンキーを押す (直前の stepi コマンドの繰り返し)
0x08049010 in _start ()
1: $xmm0.v8_int16 = {0, 1, 2, 3, 4, 5, 6, 7}
2: $xmm1.v8_int16 = {1, -1, 2, -2, 3, -3, 4, -4} ← メモリから 8 個の整数が読み込まれた
3: x/4i $pc
=> 0x8049010 <_start+16>:       paddw  %xmm0,%xmm1
   0x8049014 <_start+20>:       pmullw %xmm1,%xmm0
   0x8049018 <_start+24>:       mov    $0x1,%eax
   0x804901d <_start+29>:       int    $0x80
(gdb) 
#+end_src
確かに、
レジスタ XMM1 に 1 から -4 までの 8 個の整数が読み込まれました (図 [[fig:x86simd/add-mul-1]])。

次の命令は \inst{paddw %xmm0, %xmm1} です。
PADDW 命令は SIMD の加算命令であり、
今回は出所オペランドが XMM0 で、
宛先オペランドが XMM1 なので、
レジスタ XMM0 の値がレジスタ XMM1 に加算されます (図 [[fig:x86simd/add-mul-2]])。
早速実行してみましょう。
#+begin_src gdb
(gdb) ← リターンキーを押す (直前の stepi コマンドの繰り返し)
0x08049014 in _start ()
1: $xmm0.v8_int16 = {0, 1, 2, 3, 4, 5, 6, 7}
2: $xmm1.v8_int16 = {1, 0, 4, 1, 7, 2, 10, 3} ← XMM0 の値が XMM1 に加算された
3: x/4i $pc
=> 0x8049014 <_start+20>:       pmullw %xmm1,%xmm0
   0x8049018 <_start+24>:       mov    $0x1,%eax
   0x804901d <_start+29>:       int    $0x80
   0x804901f:   add    %al,(%eax)
(gdb) 
#+end_src

たった 1 つの PADDW 命令を実行しただけで、
0 + 1 = 1、
1 + (-1) = 0、
2 + 2 = 4、
3 + (-2) = 1、
4 + 3 = 7、
5 + (-3) = 2、
6 + 4 = 10、
7 + (-4) = 3 という 8 個の加算が一度に実行され、
計算結果がレジスタ XMM1 に格納されました。
まさに SIMD (単一命令、
複数データ) 命令ですね。

#+caption: PADDW 命令の動作
#+label: fig:x86simd/add-mul-2
[[./figure/x86simd/add-mul-2.png]]

加算だけではそれほど驚かないかもしれませんが、
次の命令は \inst{pmullw %xmm1,%xmm0} という乗算命令です。
この命令はレジスタ XMM1 の 8 個の符号付き整数を、
レジスタ XMM0 の 8 個の符号付き整数にそれぞれ掛け、
計算結果をレジスタ XMM0 に格納します (図 [[fig:x86simd/add-mul-3]])。
それではさらに 1 命令実行してみましょう。
#+begin_src gdb
(gdb) ← リターンキーを押す (直前の stepi コマンドの繰り返し)
0x08049018 in _start ()
1: $xmm0.v8_int16 = {0, 0, 8, 3, 28, 10, 60, 21} ← XMM0 に XMM1 の値が掛けられた
2: $xmm1.v8_int16 = {1, 0, 4, 1, 7, 2, 10, 3}
3: x/4i $pc
=> 0x8049018 <_start+24>:       mov    $0x1,%eax
   0x804901d <_start+29>:       int    $0x80
   0x804901f:   add    %al,(%eax)
   0x8049021:   add    %al,(%eax)
#+end_src
なんと PMULLW 命令を 1 つ実行するだけで、
0 \times 1 = 0、
1 \times 0 = 0、
2 \times 4 = 8、
3 \times 1 = 3、
4 \times 7 = 28、
5 \times 2 = 10、
6 \times 10 = 60、
7 \times 3 = 21 という 8 個の乗算がまとめて実行され、
計算結果がレジスタ XMM0 に格納されています。

#+caption: PMULLW 命令の動作
#+label: fig:x86simd/add-mul-3
[[./figure/x86simd/add-mul-3.png]]

*** スカラー演算とベクトル演算

古典的なコンピュータの SISD 型の計算モデルとは大きく異なるため、
SIMD 型の計算モデルにはなかなか慣れないかもしれませんが、
数学的な表現を使えば、
SIMD 命令の処理は以下のように表現することもできます。
- 古典的なコンピュータ (SISD 命令のみ)
  - 単一の命令では *スカラー (scalar) 演算* しかできない
- 最近のコンピュータ (SIMD 命令あり)
  - 単一の命令で *ベクトル (vector) 演算* もできる

本来、
*スカラー (scalar)* とは「方向を持たず、
大きさだけで決まる量」を意味します。
例えば、
1 や -2.34、
\pi などのような、
いわゆる「数」のことです。
一方、
*ベクトル (vector)* とは「大きさだけでなく方向を持つ量」を意味し、
例えば、
(1, 2) とか (-2.34, 5.67, 8.90) とか (1, 0, 0, 0) のようなものが含まれます。
「ベクトル」という概念は、
もともとは 2 次元平面や、
3 次元空間を扱うために生まれたものなので、
「大きさだけでなく方向を持つ量」として定義されました。
しかし、
2 次元ベクトルや 3 次元ベクトルのような人間が認知できる平面や空間に対応したベクトルだけでなく、
$(x_1, x_2, \dots, x_{100})$ のような 100 次元ベクトルや、
$(x_1, x_2, \dots, x_{10000})$ のような 1 万次元ベクトルなども同じように定義できることから、
ベクトルは「複数の値を縦とか横に並べたもの」という意味も持つことになりました。

したがって、
上記の「単一の命令でベクトル (vector) 演算もできる」は、
「方向を扱う演算もできる」という意味よりはむしろ、
「複数の値を並べたもの (ベクトル) の演算ができる」という意味でとらえるとよいでしょう。

例えば、
C 言語における
#+begin_src C
char c = 'A';
int i = 123;
double x = -4.567;
#+end_src
などの変数は、
数学的にはスカラーに分類でき、
以下のような配列変数
#+begin_src C
char s[] = "Hello";
int a[] = {123, 456, 789};
double v[] = {-4.56, 78.9, 0.123};
#+end_src
は、
数学的にはベクトルに分類できます。

C 言語では「配列変数どうしの加算」などの演算はできませんが、
C++ 言語や Python 言語などの高級言語などには可能なものもあります。
ただし、
多くの高級言語でも SIMD 型の演算はできません。
例えば Python 言語では、
配列に対して 2 項演算子のプラス (~+~) を使って、
#+begin_src python
$ python3
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> a + b
[1, 2, 3, 4, 5, 6]
>>> 
#+end_src
のように書けますが、
単に 2 つの配列が連結されるだけです。

もちろん、
高級言語によってはベクトル演算ができるものもありますし、
Python 言語でも NumPy (https://numpy.org/) のようなモジュールを使えばベクトル演算は可能です。
ただし、
もともと CPU が実行できる命令が SISD 命令ばかりであったこともあり、
CPU が持つの SIMD 命令の能力を十分に発揮できるように設計された高級言語は (少なくとも本書執筆時点では) ほとんどありません。

** IA-32 アーキテクチャにおける SIMD 命令
<<sec:x86simd/ia32>>

*** IA-32 アーキテクチャにおける SIMD 拡張

[[sec:x86regs/cpu]] 節で説明したように、
IA-32 アーキテクチャは、
長い時間をかけて少しずつ発展してきた命令セットアーキテクチャです。
その長い歴史が物語るように、
IA-32 アーキテクチャは大変複雑であり、
同様に IA-32 アーキテクチャの SIMD 命令も大変複雑になっています。
しかも、
本書の執筆時点においてなお、
IA-32 アーキテクチャの SIMD 命令は現在進行形で発展し続けています。

そのように、
本書の限られた紙面で IA-32 アーキテクチャの SIMD 命令セットを詳細に説明することは不可能なので、
ここからは「IA-32 アーキテクチャの SIMD 命令とは結局何なのか」という点に絞って説明していきます。

#+begin_note
SIMD 命令の詳細については、
インテルのソフトウェア開発者マニュアル \cite{Intel20:IA32,Intel04:IA32J-1,Intel04:IA32J-2A,Intel04:IA32J-2B,Intel04:IA32J-3} を参照してください。
#+end_note

IA-32 アーキテクチャにおける SIMD 命令は、
最初は単純なものが追加され、
徐々に複雑で高機能なものが追加されてきました (現在も追加され続けています)。
2021 年 6 月の時点で、
IA-32 アーキテクチャにおける SIMD 命令の拡張には以下のようなものがあります (代表的なものだけを記載しています)。

- MMX (MultiMedia eXtension) テクノロジ
- SSE (Streaming SIMD Extensions)
- SSE2 (Streaming SIMD Extensions 2)
- SSE3 (Streaming SIMD Extensions 3)
- SSSE3 (Supplemental Streaming SIMD Extensions 3)
- SSE4 (Streaming SIMD Extensions 4)
- AVX (Advanced Vector eXtensions)
- AVX2 (Advanced Vector eXtensions 2)
- AVX-512

アルファベット数文字の頭字語ばかりで、
名称だけ見ても何なのか想像が付かないと思います。
上のリストでは、
IA-32 アーキテクチャにおける SIMD 拡張を、
古いものから新しいものへと順に並べています。
まずはこれらの用語と、
そのおおよその順番を覚えてください。

何度も書いているように、
IA-32 アーキテクチャは信じられないくらい複雑です。
その例にもれずに、
IA-32 アーキテクチャの SIMD 拡張も大変複雑です。
上記のように多数の SIMD 拡張が存在し、
なおかつ現在も新しい拡張が続けられていますが、
幸いなことに、
基本的には「SIMD 命令のためのレジスタが大きくなり、
より高速になって、
実行できる処理の種類が増えている」だけです。

最初の MMX テクノロジも、
原稿執筆時点で最新の AVX-512 も、
基本的な考え方は同じです。
1997 年に登場した MMX テクノロジでは、
64 ビットのベクトルデータに対する整数演算のみが可能でした。
その後 2013 年に登場した AVX-512 では、
512 ビットのベクトルデータに対して整数演算も浮動小数点数演算も可能になりました。
MMX テクノロジのレジスタは x87 FPU レジスタと共用で、
レジスタ数は 8 しかありません。
一方の AVX-512 は専用のレジスタを持っており、
レジスタ数は 32 もあります。

本書で説明するように、
8 ビットの CPU も、
64 ビットの CPU も、
レジスタの大きさやアドレスの大きさは違いますが、
CPU としては「どれも同じようなもの」です。
同じように、
64 ビットの SIMD 命令 (MMX 命令) も、
512 ビットの SIMD 命令 (AVX-512 命令) も、
SIMD 命令としては「どれも同じようなもの」と言えます。

そのため、
これから IA-32 アーキテクチャの SIMD 命令を学ぶ場合には、
それぞれの SIMD 拡張の違いをそこまで詳細に理解する必要はないといってもよいでしょう。

*** SIMD 拡張の特徴

以下では、
IA-32 アーキテクチャにおける、
それぞれの SIMD 拡張の特徴を説明します。

IA-32 アーキテクチャの 64 ビット拡張に対応した CPU は、
必ず SSE2 に対応しています。
したがって、
64 ビットモードで動作しているオペレーティングシステム上では、
通常 SSE2 までが利用可能です。
GNU/Linux でも、
Windows でも、
64 ビット版のオペレーティングシステムを使っているなら、
そのコンピュータの CPU は SSE2 までに対応しています。
また、
本書執筆時点 (2021 年) では、
販売されているコンピュータ (IA-32 アーキテクチャの CPU を搭載したもの) のほとんどは AVX2 に対応した CPU を搭載しています。

このため、
「一般的なコンピュータであれば SSE2 までは対応している」、
「新しいコンピュータであれば AVX2 までは対応している」と考えられます。

#+begin_note
もちろん、
一般ユーザを対象としたソフトウェアを開発するのであれば、
そのソフトウェアを実行する CPU が、
どの SIMD 拡張に対応しているかを意識したプログラムを書く必要があります。
使用している CPU がどの SIMD 拡張に対応しているかは、
[[sec:gas/with-c]] 節で紹介した CPUID 命令によって確認できます \cite{Intel20:IA32}。
#+end_note

では、
それぞれの SIMD 拡張の特徴を順番に説明します。

*** MMX (MultiMedia eXtension) テクノロジ

*MMX (MultiMedia eXtension) テクノロジ* は、
1997 年に登場した、
IA-32 アーキテクチャにおける、
初めての SIMD 拡張です。
約 50 個の命令ニーモニックが新たに追加されています。
当初は、
オーディオやビデオのエンコーディングでの利用が想定されていたため、
「MMX (MultiMedia eXtension) テクノロジ」という名称になっています。

#+begin_note
ここでは、
MMX テクノロジにおいて新たに追加された、
異なるオペコードを持つ命令の数ではなく、
アセンブラが解釈するニーモニックの数を記載しています。
#+end_note

MMX テクノロジでは、
8 個の *MMX レジスタ (64 ビット)* を使用した *整数演算* ができます (図 [[fig:x86simd/mmx-reg]])。
8 ビット (バイト)、
16 ビット (ワード)、
32 ビット (ダブルワード) の整数を、
それぞれ 8 個、
4 個、
2 個まとめて MMX レジスタに格納できます (図 [[fig:x86simd/mmx-data]])。
つまり、
64 ビットの MMX レジスタに、
2〜8 個の整数のベクトルデータを格納できます。
これらのベクトルデータに対する算術演算、
論理演算、
比較、
ビットシフトやローテートなどが可能です。

#+caption: MMX テクノロジの MMX レジスタ
#+label: fig:x86simd/mmx-reg
[[./figure/x86simd/mmx-reg.png]]

#+caption: MMX レジスタへの整数 (8ビット、16ビット、32ビット) の格納
#+label: fig:x86simd/mmx-data
[[./figure/x86simd/mmx-data.png]]

#+begin_note
インテルのソフトウェア開発者マニュアル \cite{Intel20:IA32} では、
例えば、
64 ビットの MMX レジスタに格納された 8 ビット整数を、
「64-bit packed byte integers (64 ビットに詰められたバイト整数)」と呼んでいます。
つまり、
64 ビットのような大きなレジスタに、
複数のデータを並べて配置した状態を *packed (詰められた)* と表現しているわけです。

実際、
命令のニーモニックにも、
命令セットのリファレンスマニュアルにも packed という単語が頻繁に登場するので、
ぜひ覚えておきましょう。
#+end_note

2021 年の視点で MMX テクノロジを眺めると、
「MMX レジスタは x87 FPU レジスタと共用である (SIMD 命令か x87 FPU 命令のどちらかしか実行できない)」、
「MMX レジスタの大きさが 64 ビットと小さい」、
「整数演算しかできない (浮動小数点数が扱えない)」という制限ばかりが見え、
実際、
これ以降の SIMD 拡張は、
こういった弱点を克服するように発展してきています。
しかし、
1997 年の時点では確かに、
MMX テクノロジは画期的な SIMD 拡張でした。

#+begin_note

ちなみに、
単一のレジスタに複数のデータを格納すること自体は新しい考え方ではありません。

例えば、
32 ビットのレジスタを 8 ビット \times 8 とみなせば、
32 ビットのレジスタに 8 個の数値を格納できます。
その考え方を用いると、
2 つのベクトル (0, 1, 2, 3) と (4, 5, 6, 7) は、
0x00010203 および 0x04050607 と符号化できます。
この場合、
図 [[fig:x86simd/no-simd.s]] のようなプログラムによって 2 つのベクトルの和 (4, 6, 8, 10) が単一の ADD 命令で計算できます。

#+caption: x86simd/no-simd.s
#+label: fig:x86simd/no-simd.s
#+include: "code/x86simd/no-simd.s" src raw

このような方法で、
加算だけでなく、
減算、
論理演算、
ビットシフトなどもできます。

ただし、
このような方法が使えるのは、
桁あふれ (キャリー) や桁借り (ボロー) が起こらない場合だけです。
もちろん、
桁あふれが発生する場合でも、
レジスタ内に複数のデータを詰めて配置するのではなく、
キャリーやボロー用のビットも含めて符号化すれば対応は不可能ではありません。

しかし、
こういった処理を行うのは大変ですし、
そもそもレジスタの大きさが 32 ビットなので多くのデータを格納できません。

SIMD 命令を使えば、
大きなレジスタ上に複数のデータを格納し、
こういった算術演算や論理演算を 1 命令で実行できます。
また、
上のような素朴な方法ではできない演算 (例えば乗算) も可能です。

#+end_note

*** SSE (Streaming SIMD Extensions)

*SSE (Streaming SIMD Extensions)* は 1999 年に登場した SIMD 拡張で、
MMX テクノロジの最大の弱点を克服するように設計されており、
約 60 個の命令ニーモニックが新たに追加されています。

また、
MMX レジスタとは別の新たな (MMX レジスタの倍の大きさである) *128 ビットの XMM レジスタ* が 8 個追加されました (図 [[fig:x86simd/sse-reg]])。
XMM レジスタは、
x87 FPU レジスタから独立しているため、
SSE 拡張による SIMD 命令と、
x87 FPU 命令を同時に利用できます。

#+caption: SSE で導入された 128 ビットの XMM レジスタと MXCSR レジスタ
#+label: fig:x86simd/sse-reg
[[./figure/x86simd/sse-reg.png]]

SSE 拡張は主に *浮動小数点数* を対象としていますが、
扱えるのは *単精度の浮動小数点数 (32 ビット) のみ* であり、
倍精度の浮動小数点数 (64 ビット) は扱えません。
したがって SSE 拡張では、
128 ビットの XMM レジスタは単精度の浮動小数点数専用で、
XMM レジスタを使用した整数演算はできません。
整数演算を行うためには、
従来の (MMX テクノロジの) 64 ビットの MMX レジスタを使うか、
SSE2 以降の SIMD 拡張を使う必要があります。

SSE で新しく追加された *MXCSR レジスタ* は、
XMM レジスタによる浮動小数点数演算の制御や、
浮動小数点数演算の結果の取得に用いられるレジスタです。

#+begin_note
文献 \cite{Intel20:IA32} には記述がありませんが、
おそらく MXCSR は Multimedia Extension Control and Status Register の頭字語だと考えられます。
#+end_note

MXCSR レジスタは、
x87 FPU の制御レジスタやステータスレジスタ ([[sec:x86fp/x87fpu]] 節) と同じような役割を果たします。
浮動小数点数演算において、
どの例外が発生したかを表す例外フラグや、
どのような例外の発生を発生させないか (例外を無視するか) を指定する例外マスク、
演算結果の丸め方法を指定する丸め制御などに用いられます。

*** SSE2 (Streaming SIMD Extensions 2)

*SSE2 (Streaming SIMD Extensions 2)* は 2000 年に登場した SIMD 拡張であり、
SSE 拡張をそのまま正統に発展させたものです。
約 70 個の命令ニーモニックが新たに追加されています。

SSE2 拡張により、
128 ビットの XMM レジスタを使用した、
*バイト、
ワード、
ダブルワードの整数演算* が可能になり、
さらに、
*倍精度の浮動小数点数* も扱えるようになりました。
ただし、
XMM レジスタは 128 ビットで、
倍精度の浮動小数点数の大きさが 64 ビットなので、
XMM レジスタには 2 個の倍精度浮動小数点数しか格納できません。

「倍精度の浮動小数点数をまとめて 2 つ演算できる」だけであればそれほどありがたみがないと思うかもしれませんが、
IA-32 アーキテクチャの歴史において SSE2 は重要な意味を持っています。
それは、
「SSE2 の登場によって、
IA-32 アーキテクチャにおける浮動小数点数演算の主役が x87 FPU から SSE2 に交代になった」からです。

前述のように、
IA-32 アーキテクチャの 64 ビット拡張に対応した CPU は、
必ず SSE2 に対応しています。
また最近の IA-32 アーキテクチャの CPU では、
x87 FPU による浮動小数点数演算よりも、
SIMD 命令を用いた浮動小数点数演算のほうが高速に動作するようです。
そのため、
64 ビットモード向けの C コンパイラは、
浮動小数点数演算に x87 FPU 命令を使用せず、
代わりに SIMD 命令を使用します。
例えば、
対象とするコンピュータが 64 ビットの x86-64 である GCC は、
浮動小数点数演算には x87 FPU 命令を使用せず、
SIMD 命令のみを使用します。

*** SSE3 (Streaming SIMD Extensions 3)

*SSE3 (Streaming SIMD Extensions 3)* は、
2004 年に登場した SIMD 拡張です。
MMX テクノロジ、
SSE、
SSE2 と比較すると、
非常に小規模な拡張で、
新たに追加された命令ニーモニックは 13 個だけです。

SSE3 拡張の特徴は、
XMM レジスタ内のデータに対する、
*水平方向への演算* が可能になったという点です。
SSE2 までの SIMD 命令では、
異なるレジスタ (例えば、
レジスタ XMM0 と XMM1) の、
対応する要素どうしで (垂直方向に) 演算を行うというのが基本でした。
SSE3 拡張では、
レジスタ内の要素どうしで (水平方向に) 加算や減算を行う命令が追加されています。

*** SSSE3 (Supplemental Streaming SIMD Extensions 3)

*SSSE3 (Supplemental Streaming SIMD Extensions 3)* は 2006 年に登場した SIMD 拡張です。
SSE3 と同じようにこれまでの SSE 拡張に対する小規模な拡張であり、
水平方向への加算・減算や絶対値を計算する命令など、
14 個の命令ニーモニックが新たに追加されています。

*** SSE4 (Streaming SIMD Extensions 4)

*SSE4 (Streaming SIMD Extensions 4)* は 2007 年に登場した SIMD 拡張です。
SSE4.1 と SSE4.2 という 2 つの SIMD 拡張を合わせて SSE4 と呼びますが、
そのうち SSE4.1 では 49 個の命令ニーモニックが、
SSE4.2 では 5 個の命令ニーモニックが新たに追加されています。
SSE3 や SSSE3 は比較的小規模な拡張でしたが、
SSE4 は追加されたニーモニック数も 54 と、
規模の大きな拡張といえます。

SSE4 の特徴は、
アプリケーションの用途を想定した SIMD 命令が追加されているという点です。
SSE4 以前は、
一般的な整数および浮動小数点数のベクトル演算のための SIMD 命令が次々に追加されていました。
SSE4 では、
メディア処理や画像処理、
3D 計算に役立つ命令が中心に追加されています。
例えば、
ベクトル中の指定した要素を取り出す (extract) 命令、
ベクトル中の特定の要素だけを置換する (insert) 命令、
2 つのベクトルの各要素を選択してマージする (blend) 命令、
内積 (dot product) を計算する命令などです。
そのため、
追加された命令の中には、
よく知らないと「これはどうやって使うんだろう?」
と思うようなものもあります。

*** AVX (Advanced Vector eXtensions)

*AVX (Advanced Vector eXtensions)* は 2011 年に登場した SIMD 拡張です。

「SSE なんとか」から「AVX なんとか」に SIMD 拡張のシリーズ名が変わっただけあり、
従来の MMX テクノロジや SSE から大きな変化がありました。
最大の特徴は、
レジスタの大きさが 128 ビットから 256 ビットに倍増したことです。
つまり、
レジスタが XMM (128 ビット) から *YMM (256 ビット)* に拡張されました。

256 ビットの YMM レジスタの下位 128 ビットが XMM レジスタとなっているのですが、
これはちょうど、
「32 ビットの EAX レジスタでは下位 16 ビットが AX レジスタである」のと同じような関係です。
ただし、
すべての SIMD 命令が 256 ビット化されたわけではなく、
256 ビットで演算できるのは *浮動小数点数のみ* です。

#+caption: AVX で導入された 256 ビットの YMM レジスタ
#+label: fig:x86simd/avx-reg
[[./figure/x86simd/avx-reg.png]]

#+begin_note
256 ビットで整数演算ができるようになるのは次の AVX2 拡張を待つことになります。
#+end_note

さらに、
従来の 128 ビットの XMM レジスタを使った演算で、
*オペランドの数が 2 から 3 に* 増えました。

例えば、
従来の SSE 拡張では
#+begin_src asm
	paddw	%xmm1, %xmm0		# XMM0 ← <+> XMM1
#+end_src
のように、
SIMD 命令のオペランドは 2 つ (出所オペランドと宛先オペランド) だったのに対し、
AVX 拡張では、
#+begin_src asm
	vpaddw	%xmm1, %xmm0, %xmm2	# XMM2 ← XMM0 + XMM1
#+end_src
のように、
オペランドを 3 つ指定します。

これにより、
演算に使用するレジスタと、
演算結果を格納するレジスタに、
異なるレジスタを指定できます。
RISC である Armv8-A アーキテクチャの算術演算命令 ([[sec:arm/arith]] 節) と同じような 3 オペランドの形式です。

#+begin_note
上の例 (PADDW 命令と VPADDW 命令) のように、
SSE 拡張における「なんとか」という命令のニーモニックは、
AVX 拡張において「v なんとか」というニーモニックになっています。
AVX の SIMD 命令以外では、
IA-32 アーキテクチャの命令のニーモニックで V から始まるのはごく少数です。
このため、
アセンブリ言語プログラム中に V から始まる命令があれば、
それはおそらく AVX 拡張の SIMD 命令だといえます。
#+end_note

*** AVX2 (Advanced Vector eXtensions 2)

*AVX2 (Advanced Vector eXtensions 2)* は 2013 年に登場した SIMD 拡張です。
先の AVX 拡張ではレジスタの大きさが 128 ビットから 256 ビットに倍増しましたが、
256 ビットで演算できるのは浮動小数点数のみでした。
一方この AVX2 では、
YMM レジスタを使った *256 ビットでの整数演算* も可能になりました。

他にも、
これまでなかった種類のベクトル操作命令が追加されています。
例えば、
収集 (gather) 命令は、
メモリ上にばらばらに配置されているデータをベクトルの要素として読み込むことができる命令です。
それぞれのデータの配置場所 (インデックス) を、
別のベクトルの各要素で指定できるというものです。

*** AVX-512

*AVX-512* は 2016 年に登場した SIMD 拡張です。

MMX テクノロジ→ SSE → AVX と進化するにつれ、
SIMD 命令用レジスタの大きさが 64 ビット (MMX レジスタ) → 128 ビット (XMM レジスタ) → 256 ビット (YMM レジスタ) と順調に倍増し、
レジスタの数も、
8 (MMX レジスタ) → 8(XMM レジスタ) → 16 (YMM レジスタ、
64 ビットモード) と増大してきました。

この AVX-512 でも、
レジスタの大きさ、
レジスタの数ともに、
これまでの AVX から倍に増えました (図 [[fig:x86simd/avx512-reg]])。
*レジスタ (ZMM レジスタ)* の大きさはなんと 512 ビットとなり、
レジスタの数も、
YMM レジスタ (64 ビットモード) の 16 個から倍増して 32 個になりました。

#+caption: AVX-512 で導入された 512 ビットの ZMM レジスタ
#+label: fig:x86simd/avx512-reg
#+attr_latex: :width \columnwidth
[[./figure/x86simd/avx512-reg.png]]

#+begin_note

ただし、
本書の執筆時点では、
AVX-512 をサポートしているのはハイエンド向けの CPU のみです。
デスクトップ向けコンピュータの CPU (Core シリーズなど) は AVX-512 拡張をサポートしていません。
#+end_note

** デバッガによるトレース
<<sec:x86simd/trace>>

IA-32 アーキテクチャの SIMD 命令は数百種類もあるため、
本書の限られた紙面でこれらのの命令を紹介するのは不可能です。

そこで本書では、
SIMD 命令を利用したアセンブリ言語プログラムの例をいくつか紹介していきます。
これらのプログラムを通して、
IA-32 アーキテクチャにおける SIMD 命令の特徴や、
SIMD 命令の利用法のイメージをつかんでください。

#+begin_note
SIMD 命令の詳細については文献 \cite{Intel20:IA32} を参照してください。
#+end_note

*** 整数の和の計算 (MMX 命令)

まずは、
IA-32 アーキテクチャに最初に導入された、
MMX テクノロジ拡張による SIMD 命令を使ったプログラムを取り上げます。
MMX テクノロジ以降にも、
SSE、
SSE2、
AVX、
AVX2 などの拡張が追加されていますが、
最も基本的な MMX テクノロジの SIMD 命令を使って、
どんな処理ができるのかを見てみましょう。

最初の例は、
複数の整数の和を計算するプログラム ~sum.s~ です。

#+caption: x86simd/mmx-sum/sum.s
#+label: fig:x86simd/mmx-sum/sum.s
#+include: "code/x86simd/mmx-sum/sum.s" src asm

MMX テクノロジの SIMD 命令を使うので、
*64 ビットの MMX レジスタ* を使用します。
今回のプログラムでは、
64 ビットの MMX レジスタに、
8 ビットの整数を 8 個格納します。
つまり、
MMX レジスタを、
要素数が 8 のベクトルとして使用します。

これらの 8 個の整数の和を SIMD 命令を使って計算します。
ただし、
MMX テクノロジの SIMD 命令には、
ベクトルの要素の和を計算するような命令はありません。

MMX テクノロジには以下のような SIMD 命令があります。
- レジスタとメモリ間でのデータ転送命令
- バイト・ワード・ダブルワード間の型変換命令
- 基本的な算術演算命令 (加算、減算、乗算、積和演算)
- 比較命令 (一致および大小比較)
- 論理演算命令 (論理積、否定、論理和、排他的論理和)
- シフトおよびローテート命令
- MMX 状態管理命令 (MMX レジスタの状態をクリア)
逆に言えば、
このくらいの単純な命令しかありません。
前述のとおり、
MMX テクノロジではレジスタの大きさは 64 ビットであり、
*整数演算のみ* が可能です (浮動小数点数は扱えません)。

プログラム ~sum.s~ では、
要素数が 8 のベクトルの要素の和を以下のように求めています (図 [[fig:x86simd/sum-idea.png]])。
ベクトルを同じ大きさの 2 つのベクトルに分割し、
これらの 2 つのベクトルの和を計算する、
という操作を、
ベクトルの長さが 1 になるまで繰り返すというアルゴリズムです。
ここではベクトルの長さは 8 なので、
3 回の操作で 8 つの要素の和を求められます。
一般に、
ベクトルの長さが $N$ のとき、
$\log_2 N$ 回の操作ですべての要素の和が計算できます。

#+caption: 長さ 8 のベクトルの要素の和の計算方法
#+label: fig:x86simd/sum-idea.png
#+attr_latex: :width .7\columnwidth
[[./figure/x86simd/sum-idea.png]]

プログラム ~sum.s~ の動作をデバッガでトレースして見てみましょう。
これまでと同じように、
以下のようにアセンブルおよびリンクします。
#+begin_src sh
$ as -o sum.o sum.s
$ ld -o sum sum.o
#+end_src

作業ディレクトリに、
以下のような ~.gdbinit~ ファイルを用意しておきます (図 [[fig:x86simd/mmx-sum/.gdbinit]])。

#+caption: x86simd/mmx-sum/.gdbinit
#+label: fig:x86simd/mmx-sum/.gdbinit
#+include: "code/x86simd/mmx-sum/.gdbinit" src gdb

冒頭のプログラム ~add-mul.s~ のトレースに使用した ~.gdbinit~ ファイル (図 [[fig:x86simd/.gdbinit]]) とほぼ同じ内容ですが、
表示するレジスタ名が異なっています。
今回は、
XMM レジスタではなく MMX レジスタを使用するので、
レジスタ名が ~%mm0~ や ~%mm1~ となっています。
また、
MMX レジスタには、
8 ビットの整数を 8 個格納しているため、
~v8_int8~ を指定しています。

これまでと同じように、
デバッガの監視下で実行します。
#+begin_src gdb
$ gdb -q sum
Reading symbols from sum...
(No debugging symbols found in sum)
Breakpoint 1 at 0x8049000
(gdb) r ← runコマンドの省略形
Starting program: /home/ohsaki/code/x86simd/mmx-sum/sum 

Breakpoint 1, 0x08049000 in _start ()
1: $mm0.v8_int8 = {0, 0, 0, 0, 0, 0, 0, 0}
2: $mm1.v8_int8 = {0, 0, 0, 0, 0, 0, 0, 0}
3: x/4i $pc
=> 0x8049000 <_start>:  movq   0x804a000,%mm0
   0x8049007 <_start+7>:        movq   %mm0,%mm1
   0x804900a <_start+10>:       psrlq  $0x20,%mm1
   0x804900e <_start+14>:       paddd  %mm1,%mm0
(gdb) 
#+end_src

SIMD 命令を使用して、
どのように 8 要素の和を求められるかを見てみましょう。
最初の命令は \inst{movq 0x804a000,%mm0} です。
メモリの 0x804a000 番地に格納されている 64 ビットのデータをレジスタ MM0 に読み込みます。
MOVQ 命令の末尾の Q は *Quadword (クワッドワード = 64 ビット)* を意味します。

1 命令ステップ実行します。
#+begin_src gdb
(gdb) si ← stepiコマンドの省略形
0x08049007 in _start ()
1: $mm0.v8_int8 = {1, 2, 3, 4, 5, 6, 7, 8} ← 1〜8の整数が読み込まれた
2: $mm1.v8_int8 = {0, 0, 0, 0, 0, 0, 0, 0}
3: x/4i $pc
=> 0x8049007 <_start+7>:        movq   %mm0,%mm1
   0x804900a <_start+10>:       psrlq  $0x20,%mm1
   0x804900e <_start+14>:       paddd  %mm1,%mm0
   0x8049011 <_start+17>:       movq   %mm0,%mm1
(gdb) 
#+end_src
レジスタ MM0 に 1〜8 の整数が読み込まれました。
デバッガの出力では
#+begin_src gdb
1: $mm0.v8_int8 = {1, 2, 3, 4, 5, 6, 7, 8}
#+end_src
のように表示されていますが、
レジスタ MM0 の *下位バイトから上位バイトの順番に* 表示されていることに注意してください。
例えば、
レジスタ MM0 の最下位バイト (0〜7 ビット) に格納されている値が 0x01 で、
レジスタ MM0 の最上位バイト (63〜56 ビット) に格納されている値が 0x08 です。

次の命令は \inst{movq %mm0,%mm1} です。
先ほどと同じ MOVQ 命令ですが、
2 つのオペランドがどちらも MMX レジスタになっています。
これは想像が付くように、
レジスタ MM0 の値をレジスタ MM1 にコピーする命令です。
早速 1 命令実行しましょう。
#+begin_src gdb
(gdb) ← リターンキーを押す (stpiコマンドの繰り返し)
0x0804900a in _start ()
1: $mm0.v8_int8 = {1, 2, 3, 4, 5, 6, 7, 8}
2: $mm1.v8_int8 = {1, 2, 3, 4, 5, 6, 7, 8} ← MM0 の値が MM1 にコピーされた
3: x/4i $pc
=> 0x804900a <_start+10>:       psrlq  $0x20,%mm1
   0x804900e <_start+14>:       paddd  %mm1,%mm0
   0x8049011 <_start+17>:       movq   %mm0,%mm1
   0x8049014 <_start+20>:       psrlq  $0x10,%mm1
(gdb) 
#+end_src

次の命令は \inst{psrlq $0x20,%mm1} です。
これまで見たことのない命令ですが、
これは SIMD 命令の 1 つです。
PSRLQ という命令のニーモニックから何をする命令なのか想像するのは困難ですが、
これは「ビット数, MMX レジスタ」という形式のオペランドを取り、
MMX レジスタを指定したビット数だけ右に論理シフトする命令です。
ここでは、
レジスタ MM1 の値を、
0x20 (= 32) ビットだけ右方向にシフトしています。
レジスタ MM0 の上位 32 ビットを、
レジスタ MM1 の下位 32 ビットに移動しています。

SIMD 命令のニーモニックは暗号めいていて、
ニーモニックだけ見ても何をする命令なのか想像しづらいと思います。
ただし、
SIMD 命令のニーモニックは表 [[tab:x86sim/convention]] のような規則で名付けられています。
これらの規則を頭に入れて、
しばらくいろいろな命令を眺めていると、
なんとなく命令の意味がわかるようになってきます。
しばらくは我慢して、
何度も SIMD 命令のリファレンスマニュアルを確認してください。

#+caption: SIMD 命令の命名規則
#+label: tab:x86sim/convention
#+attr_latex: :environment maxtabular
| 文字 | 意味                                                         | 日本語訳                             |
|------+--------------------------------------------------------------+--------------------------------------|
| A    | Aligned                                                      | 配置された                           |
| B    | Byte                                                         | バイト                               |
| D    | Doubleword                                                   | ダブルワード                         |
| DQ   | Double quadword                                              | ダブル・クワッドワード               |
| HL   | High to Low                                                  | 高から低                             |
| L    | Left                                                         | 左                                   |
| PD   | Packed Double-precision floating-point                       | 詰められた倍精度浮動小数点           |
| PI   | Packed Integer                                               | 詰められた整数                       |
| PS   | Packed Single-precision floating-point                       | 詰められた単精度浮動小数点           |
| Q    | Quadword                                                     | クワッドワード                       |
| R    | Right                                                        | 右                                   |
| S    | Signed, Saturated, or Shift                                  | 符号付き、飽和、シフト               |
| SD   | Scalar Double-precision floating-point                       | 単一の倍精度浮動小数点               |
| SI   | Signed Integer                                               | 符号付き整数                         |
| SS   | Scalar Single-precision floating-point, or Signed Saturation | 単一の単精度浮動小数点、符号付き飽和 |
| U    | Unsigned, or Unorderd, or Unaligned                          | 符号なし、順序なし、配置されない     |
| US   | Unsigned Saturation                                          | 符号なし飽和                         |
| V    |                                                              | AVX 以降で拡張された命令             |
| W    | Word                                                         | ワード                               |

表 [[tab:x86sim/convention]] から、
PSRLQ 命令は、
「Packed な (詰められた) データに対する Shift (シフト) 命令で、
Right (右) 方向に Logical (論理的に) にシフトする命令であり、
データの大きさは Quadword (クワッドワード = 64 ビット) である」のように読み解けます。

同様に、
先ほどの MOVQ 命令も、
「データを MOVe (移動) する命令であり、
データの大きさは Quadword (クワッドワード = 64 ビット) である」のように読み解けます。

#+begin_note
ややこしいのですが、
#+begin_src asm
	movq   %mm0, %mm1
#+end_src
における movq の末尾の q は、
*命令のニーモニックの一部* です。
MOV 命令とは名前の異なる、
MOVQ 命令です。
MOV 命令は IA-32 アーキテクチャの汎用命令ですが、
MOVQ 命令は SIMD 命令です。

ただし、
#+begin_src asm
	movl   %eax, %ebx
#+end_src
における movl の末尾の l は、
*GAS のサフィックス (接尾部)* であり、
命令のニーモニックの一部ではありません。
つまりあくまで MOV 命令であって、
オペランドの大きさを GAS に伝えるために、
命令のニーモニックの末尾に付与しています。

見た目も、
役割もそっくりですが、
前者はニーモニックの一部で、
後者は GAS のサフィックスなので注意してください。
#+end_note

プログラムのトレースに戻りましょう。

次の PSRLQ 命令を実行すると、
レジスタ MM1 の値が右方向に 32 ビットシフトするはずです。
実際に 1 命令ステップ実行して確かめてみましょう。
#+begin_src sh
(gdb) ← リターンキーを押す (stepiコマンドの繰り返し)
0x0804900e in _start ()
1: $mm0.v8_int8 = {1, 2, 3, 4, 5, 6, 7, 8}
2: $mm1.v8_int8 = {5, 6, 7, 8, 0, 0, 0, 0} ← MM1の値が32ビット右にシフトした
3: x/4i $pc
=> 0x804900e <_start+14>:       paddb  %mm1,%mm0
   0x8049011 <_start+17>:       movq   %mm0,%mm1
   0x8049014 <_start+20>:       psrlq  $0x10,%mm1
   0x8049018 <_start+24>:       paddd  %mm1,%mm0
(gdb) 
#+end_src
レジスタ MM1 の値が変化しました。
前述のように、
GDB の出力は、
下位バイト〜上位バイトの順になっていることに注意します。
上位 32 ビットが下位 32 ビットにシフトし、
上位 32 ビットはゼロで埋められていることがわかります。

次の命令は \inst{paddb %mm1, %mm0} です。
レジスタ XMM1 の各要素 (8 ビットの整数 \times 8 個) をレジスタ XMM0 に加算します。
これも表 [[tab:x86sim/convention]] をもとに読み解くと、
PADDB 命令は、
「Packed な (詰められた) データを ADD (加算) する命令であり、
加算するデータの単位が Byte (バイト) である」となります。
今は、
元のベクトル (1, 2, 3, 4, 5, 6, 7, 8) を 2 等分した、
(1, 2, 3, 4) と (5, 6, 7, 8) の和を計算しようとしているのですが、
そのため今は、
64 ビットの大きさを持つレジスタ MM0 のうち、
下位 32 ビット (8 ビット \times 4 個) のみを使います。
上位 32 ビットには何らかの値が残ったままではありますが、
興味があるのは下位 32 ビットのみです。

1 命令ステップ実行します。
#+begin_src sh
(gdb) ← リターンキーを押す (stepiコマンドの繰り返し)
0x08049011 in _start ()
1: $mm0.v8_int8 = {6, 8, 10, 12, 5, 6, 7, 8} ← 最初の4要素のみを使用
2: $mm1.v8_int8 = {5, 6, 7, 8, 0, 0, 0, 0}
3: x/4i $pc
=> 0x8049011 <_start+17>:       movq   %mm0,%mm1
   0x8049014 <_start+20>:       psrlq  $0x10,%mm1
   0x8049018 <_start+24>:       paddb  %mm1,%mm0
   0x804901b <_start+27>:       movq   %mm0,%mm1
(gdb) 
#+end_src
レジスタ MM0 の下位 32 ビット (8 ビット \times 4 個) には、
(1, 2, 3, 4) と (5, 6, 7, 8) の和である (6, 8, 10, 12) が正しく格納されていることがわかります。

このあとは、
これまでと同じような操作をさらに 2 回繰り返します。
まず、
(6, 8, 10, 12) を 2 等分した (6, 8) と (10, 12) の和である (16, 20) を計算します。
さらに同じような操作を繰り返して、
(16) と (20) の和である (36) を計算します。

しばらくステップ実行を続け、
最後の \inst{paddb %mm1,%mm0} まで実行しましょう。
#+begin_src sh
	:
	:
(gdb) ← リターンキーを押す (stepiコマンドの繰り返し)
0x08049022 in _start ()
1: $mm0.v8_int8 = {16, 20, 15, 18, 12, 14, 7, 8}
2: $mm1.v8_int8 = {20, 15, 18, 12, 14, 7, 8, 0}
3: x/4i $pc
=> 0x8049022 <_start+34>:       paddb  %mm1,%mm0
   0x8049025 <_start+37>:       mov    $0x1,%eax
   0x804902a <_start+42>:       int    $0x80
   0x804902c:   add    %al,(%eax)
(gdb) 
0x08049025 in _start ()
1: $mm0.v8_int8 = {36, 35, 33, 30, 26, 21, 15, 8} ← 第1要素(36)が8要素の和
2: $mm1.v8_int8 = {20, 15, 18, 12, 14, 7, 8, 0}
3: x/4i $pc
=> 0x8049025 <_start+37>:       mov    $0x1,%eax
   0x804902a <_start+42>:       int    $0x80
   0x804902c:   add    %al,(%eax)
   0x804902e:   add    %al,(%eax)
(gdb) 
#+end_src
これで、
レジスタ MM0 の最下位バイトに、
8 要素のベクトルのすべての要素の和である 36 (= 1 + 2 + \dots + 8) が格納されたことがわかります。

今回のプログラムでは、
初期に導入された MMX テクノロジの SIMD 命令だけを使用しました。
最近の SIMD 命令と比較すると MMX テクノロジの SIMD 命令は単純なものばかりですが、
それでも 8 個の整数の和がたった 3 回のシフト命令 (PSRLQ 命令) と 3 回の加算命令 (PADDB 命令) だけで実現できました。

*** 2 つのベクトルの内積の計算 (MMX 命令)

MMX テクノロジの SIMD 命令を使った別のプログラムを見てみましょう。
2 つのベクトルの内積を計算するプログラム ~prod.s~ です (図 [[fig:x86simd/mmx-prod/prod.s]])。
ベクトルの内積とは、
2 つのベクトル ${\mathbf x} = (x_1, \dots, x_n)$ および ${\mathbf y} = (y_1, \dots, y_n)$ に対して、
\begin{align}
  {\mathbf x} \cdot {\mathbf y} = \sum_{1 \le i \le n} x_i \, y_i
\end{align}
で定義されるスカラー量です。
2 つのベクトルに対して定義される演算ですが、
演算の結果はベクトルではなくスカラー (数) です。

#+caption: x86simd/mmx-prod/prod.s
#+label: fig:x86simd/mmx-prod/prod.s
#+include: "code/x86simd/mmx-prod/prod.s" src asm

プログラム ~prod.s~ は、
ベクトルの要素を 16 ビット (ワード) の整数で表現したときの、
長さ 4 の 2 つのベクトルの内積を求めます。
SIMD 命令を使わずに計算するためには、
4 回の乗算 ($x_i \, y_i$ の計算) と 4 回の加算 (4 つの $x_i \, y_i$ の和) が必要です。
SIMD 命令を使うと、
どのくらい演算回数が減るでしょうか。

プログラム ~prod.s~ で使われている演算命令は、
PMADDWD 命令、
PSRLQ 命令、
PADDD 命令の 3 つだけです。
しかも、
それぞれの命令は 1 回ずつしか使用されていません。
長さ 4 のベクトルの内積が、
たった 3 つの命令で計算できています。
SIMD 命令の真価が発揮されていると言えます。

なぜこんなことが可能になるのか、
プログラムの実行をトレースして眺めてみましょう。
以下のような ~.gdbinit~ ファイルを作成しておきます (図 [[fig:x86simd/mmx-prod/.gdbinit]])。

#+caption: x86simd/mmx-prod/.gdbinit
#+label: fig:x86simd/mmx-prod/.gdbinit
#+include: "code/x86simd/mmx-prod/.gdbinit" src gdb

先ほどの ~.gdbinit~ ファイルとほぼ同じですが、
#+begin_src gdb
display $mm0.v2_int32
#+end_src
という 1 行だけが追加されています。
これにより、
レジスタ MM0 の値を 32 ビットの整数として表示します。

アセンブルおよびリンクの手順は先ほどと同じなので省略し、
デバッガの監視下でプログラム ~prod~ を実行していきます。
#+begin_src gdb
$ gdb -q prod 
Reading symbols from prod...
(No debugging symbols found in prod)
Breakpoint 1 at 0x8049000
(gdb) r ← runコマンドの省略形
Starting program: /home/ohsaki/code/x86simd/mmx-prod/prod 

Breakpoint 1, 0x08049000 in _start ()
1: $mm0.v4_int16 = {0, 0, 0, 0}
2: $mm1.v4_int16 = {0, 0, 0, 0}
3: $mm0.v2_int32 = {0, 0}
4: x/4i $pc
=> 0x8049000 <_start>:  movq   0x804a000,%mm0
   0x8049007 <_start+7>:        pmaddwd 0x804a008,%mm0
   0x804900e <_start+14>:       movq   %mm0,%mm1
   0x8049011 <_start+17>:       psrlq  $0x20,%mm1
(gdb) 
#+end_src

最初の命令は \inst{movq 0x804a000,%mm0} です。
プログラム ~sum.c~ (図 [[fig:x86simd/mmx-sum/sum.s]]) と同じように、
メモリ 0x804a000 番地から格納されているデータをレジスタ MM0 に読み込みます。
先ほどは 8 ビット (バイト) \times 8 個の要素を読み込むために MOVQ 命令を使用しましたが、
今回は 16 ビット (ワード) \times 4 個の要素を読み込むために MOVQ 命令を使用しています。
MOVQ 命令は、
*単に 64 ビットのデータを転送する命令* なので、
その 64 ビットのデータの形式によらず使用できます。

算術演算や論理演算などでは、
レジスタに格納されているデータの形式 (データの大きさ、
符号付き/符号なし等) に応じて適切な命令を選択する必要があります。
一方、
データ転送命令では、
単にデータの大きさに応じて命令を選択します。
例えば、
128 ビットの XMM レジスタとの間でデータを転送する場合は、
64 ビットデータ用の MOVQ 命令ではなく、
128 ビットデータ用の MOVDQA 命令や MOVDQU 命令などを使用します。

1 命令実行しましょう。
#+begin_src gdb
(gdb) si ← stepi コマンドの省略形
0x08049007 in _start ()
1: $mm0.v4_int16 = {1, 2, 3, 4} ← メモリから4個の要素が読み込まれた
2: $mm1.v4_int16 = {0, 0, 0, 0}
3: $mm0.v2_int32 = {131073, 262147}
4: x/4i $pc
=> 0x8049007 <_start+7>:        pmaddwd 0x804a008,%mm0
   0x804900e <_start+14>:       movq   %mm0,%mm1
   0x8049011 <_start+17>:       psrlq  $0x20,%mm1
   0x8049015 <_start+21>:       paddd  %mm1,%mm0
(gdb) 
#+end_src

次の命令は \inst{pmaddwd 0x804a008, %mm0} です。
PMADDWD 命令は、
今回の内積の計算で最も重要な役割を果たします (図 [[fig:x86simd/pmaddwd.png]])。
PMADDWD 命令も表 [[tab:x86sim/convention]] をもとに解釈すると、
「Packed な (詰められた) データに対して Multiply (乗算) して ADD (加算) する演算命令であり、
Word (ワード = 16 ビット) 単位で乗算し、
隣接する乗算結果を加算し Doubleword (ダブルワード = 32 ビット) で格納する」となります。

#+caption: PMADDWD 命令の動作
#+label: fig:x86simd/pmaddwd.png
#+attr_latex: :width \columnwidth
[[./figure/x86simd/pmaddwd.png]]

PMADDWD 命令は、
ベクトルの内積を計算するために用意されたような命令です。
PMADDWD 命令により、
ベクトルの内積に必要な計算の多くが 1 命令だけで実行できてしまいます。
長さ 4 のベクトルの内積であれば、
PMADDWD 命令を実行すれば、
あとは残った 2 つの 32 ビットの整数を加算することで内積を求められます。

PMADDWD 命令を実行してみましょう。
#+begin_src gdb
(gdb) ← リターンキーを押す (stepi コマンドの繰り返し)
0x0804900e in _start ()
1: $mm0.v4_int16 = {-7, -1, 53, 0}
2: $mm1.v4_int16 = {0, 0, 0, 0}
3: $mm0.v2_int32 = {-7, 53} ← 対応する要素の積の和が計算された
4: x/4i $pc
=> 0x804900e <_start+14>:       movq   %mm0,%mm1
   0x8049011 <_start+17>:       psrlq  $0x20,%mm1
   0x8049015 <_start+21>:       paddd  %mm1,%mm0
   0x8049018 <_start+24>:       mov    $0x1,%eax
(gdb) 
#+end_src
レジスタ MM0 の (1, 2, 3, 4) と、
ラベル ~vec2~ に格納されている (5, -6, 7, 8) に対して PMADDWD 命令を実行し、
計算結果である (1 \times 5 + 2 \times (-6), 3 \times 7 + 4 \times 8) = (-7, 53) がレジスタ MM0 に格納されていることがわかります。

あとは、
レジスタ MM0 の上位 32 ビットと下位 32 ビットに格納されている、
-7 と 53 の和を計算するだけです。
レジスタ内の 2 つの要素の和は、
先ほどと同じように PSRLQ 命令を使用して 32 ビット右シフトしたものを
加算します。

ここから、
以下の 3 命令をまとめて実行します。
#+begin_src gdb
=> 0x804900e <_start+14>:       movq   %mm0,%mm1
   0x8049011 <_start+17>:       psrlq  $0x20,%mm1
   0x8049015 <_start+21>:       paddd  %mm1,%mm0
#+end_src

stepi コマンドの引数に、
実行する命令数を指定します。
#+begin_src gdb
(gdb) si 3 ← 「stepi 3」の省略形 (3 命令ステップ実行する)
0x08049018 in _start ()
1: $mm0.v4_int16 = {46, 0, 53, 0}
2: $mm1.v4_int16 = {53, 0, 0, 0}
3: $mm0.v2_int32 = {46, 53} ← 第1要素が2つのベクトルの内積
4: x/4i $pc
=> 0x8049018 <_start+24>:       mov    $0x1,%eax
   0x804901d <_start+29>:       int    $0x80
   0x804901f:   add    %al,(%eax)
   0x8049021:   add    %al,(%eax)
(gdb) 
#+end_src
最終的に、
レジスタ MM0 の下位 32 ビットに、
長さ 4 の 2 つのベクトルの内積である 46 が格納されています。
MMX テクノロジの SIMD 命令だけでもこれだけのことができます。

*** 文字列中にヌル文字が存在するかの判定 (MMX 命令)

さらにもう一つ、
SIMD 命令ならではのプログラムを見てみましょう。
文字列中にヌル文字が含まれているかを判定するプログラム ~find.s~ です (図 [[fig:x86simd/mmx-find/find.s]])。

#+caption: x86simd/mmx-find/find.s
#+label: fig:x86simd/mmx-find/find.s
#+include: "code/x86simd/mmx-find/find.s" src asm

これは、
[[sec:inline/call-from-c]] 節で説明した、
文字列の長さを返す関数 ~strlen~ の実現に必要な処理の一部を実装したものです。
関数 ~strlen~ は文字列中の末尾に存在する終端文字 (ヌル) 文字を、
文字列の先頭から探索することによって文字列の長さを特定します。
[[sec:inline/call-from-c]] 節で述べたように、
関数 ~strlen~ を素朴に実装すると、
(文字の単位がバイトであるため) 文字列の先頭から 1 バイトずつ調べ、
その値がヌル文字 (0x00) かどうかをチェックすることになります。

SIMD 命令はベクトル演算のための命令ですが、
前述のように *文字列もベクトルデータの一種* です。
したがって、
SIMD 命令によって文字列処理も可能になります。

プログラム ~find.c~ は 8 バイトの文字列中にヌル文字が含まれるかどうかを、
SIMD 命令を使用することにより、
8 バイトまとめてチェックします。
ヌル文字かどうかの判定を 1 バイトずつ 8 回繰り返すのではなく、
8 バイトまとめて判定するというのがポイントです。

このプログラムで最も重要なのは、
*2 つのベクトルの各要素が一致しているかを判定する* PCMPEQB 命令です (図 [[fig:x86simd/pcmpeqb.png]])。
これまでと同じように PCMPEQB 命令のニーモニックを解釈すると、
「Packed な (詰められた) データに対する CoMPare (比較) 命令で、
2 つのオペランド中の各要素が EQual (等しい) かどうかを判定するが、
各要素の大きさは Byte (バイト) である」となります。

#+caption: PCMPEQB 命令の動作
#+label: fig:x86simd/pcmpeqb.png
#+attr_latex: :width \columnwidth
[[./figure/x86simd/pcmpeqb.png]]

例えば、
#+begin_src asm
	pcmpeqb	%mm0, %mm1
#+end_src
それでは、
レジスタ MM1 の各要素 (バイト単位) を、
レジスタ MM0 の各要素と比較していきましょう。

それぞれの値が等しければ、
レジスタ MM1 中の対応する要素の値を 0xff にし、
そうでなければ 0x00 にします。
例えば、
レジスタ MM0 の値が 0x0807060504030201 であり、
レジスタ MM1 の値が 0x0800000000000001 とします。
このときに、
\inst{pcmpeqb %mm0, %mm1} を実行すると、
最上位バイトと最下位バイトの要素が一致しているため、
レジスタ MM1 の値は 0xff000000000000ff となります。

IA-32 アーキテクチャに限らず、
SIMD 命令ではない通常の比較命令では、
比較命令の実行結果はフラグレジスタに反映されます ([[sec:x86regs/register]] 節、
[[sec:comet-registers]] 節、
[[sec:avr-registers]] 節、
[[sec:arm/arch]] 節)。
SIMD 命令にも比較命令はありますが、
ベクトルの比較になりますので、
(ベクトルの要素を個々に比較する場合には、
複数ビットが必要となるため) 比較結果をフラグレジスタに保存できません。
そこで MMX テクノロジの比較命令では、
比較した結果をその MMX レジスタ自身に保存します (レジスタにもともと格納されていた値は破壊されます)。

このため、
SIMD 命令を用いたプログラミングでは、
従来のような「比較命令でフラグレジスタをセットし、
フラグレジスタの値に応じて条件分岐する」といった考え方とは異なるロジックでアルゴリズムを組み立てる必要があります。

もう一点、
プログラム ~find.s~ でわかりづらいのは、
PACKSSWB 命令の箇所ではないでしょうか。

PACKSSWB 命令は、
データの型変換のための命令であり、
ベクトル中の 16 ビット \times 4 個の要素を、
8 ビット \times 8 個に変換します (図 [[fig:x86simd/packsswb.png]])。
つまり、
64 ビットのデータ (16 ビット \times 4 個) を、
データサイズが半分の 32 ビットのデータ (8 ビット \times 4 個) に変換します。

また、
PACKSSWB 命令が取るオペランドは 2 つです。
例えば、
#+begin_src asm
	packsswb	%mm1, %mm0
#+end_src
とすれば、
レジスタ MM0 中の 64 ビットを変換したデータがレジスタ MM0 の下位 32 ビットに、
レジスタ MM1 の 64 ビットを変換したデータがレジスタ MM0 の上位 32 ビットに格納されます。

#+begin_note
PACKSSWB 命令を表 [[tab:x86sim/convention]] をもとに読み解くと、
「データを PACK (詰める) 命令であり、
Signed Saturation (符号付き飽和算術) で Word (ワード = 16 ビット) の要素を Byte (バイト = 8 ビット) の要素として詰める」となります。
#+end_note

#+caption: PACKSSWB 命令の動作
#+label: fig:x86simd/packsswb.png
#+attr_latex: :width \columnwidth
[[./figure/x86simd/packsswb.png]]

#+begin_note
*飽和算術 (saturation arithmetic)* というのは、
演算結果がデータ領域に収まらない (オーバーフローやアンダーフローが起こった) ときに、
*演算結果を最大値や最小値に制限する* (最大値や最小値で飽和させる) という算術演算であり、
従来の算術演算命令にはなかった概念です。

例えば、
ベクトルの各要素のデータサイズが 8 ビット (バイト) の符号なし整数とします。
演算結果が 8 ビットに収まらない場合、
通常の算術演算では桁あふれが起きます。
0xf0 + 0x21 を計算すると演算結果は 0x111 ですが、
データサイズが 8 ビットのため、
演算結果の最上位の桁が捨てられて 0x11 となります。
この場合、
キャリーフラグがセットされ、
演算によって桁あふれが起きたことがわかります。

飽和算術では、
オーバーフローが起きそうになったら最大値に制限し、
アンダーフローが起きそうになったら最小値に制限します。
上の例では、
0xf0 + 0x21 を計算すると演算結果は 0x111 ですが、
このままだとオーバーフローが起きてしまうので、
演算結果を、
8 ビットの符号なし整数の最大値である 0xff にします。
同様に、
0x10 - 0x21 を計算する場合は、
演算結果は 8 ビットの符号なし整数の最小値である 0x00 にします。

SIMD 命令では、
ベクトルの各要素のオーバーフローやアンダーフローの扱いが大変面倒なので、
こういった面倒さを軽減するために飽和算術が用意されています。
#+end_note

プログラム ~find.s~ では、
PCMPEQB 命令の実行により、
文字列中にヌル文字があれば、
レジスタ MM1 の該当するバイトが 0xff になります。
64 ビットのレジスタ MM1 中に 0xff である箇所があるかどうかを判定するために PACKSSWB 命令を使用しています。
つまり、
PACKSSWB 命令によって、
レジスタ MM1 上の 64 ビットのデータを、
レジスタ MM1 の下位 32 ビットに集約しています。
その後、
レジスタ MM1 の下位 32 ビットをレジスタ EAX にコピーしています。
これにより、
レジスタ EAX の値がゼロかどうかをチェックすることにより、
文字列中にヌル文字が含まれているかを判定できます。

#+begin_note
プログラム ~find.s~ のロジックだけでは関数 ~strlen~ は実現できません。
関数 ~strlen~ をこのような SIMD 命令を使って実装するためには、
例えば以下のような処理が必要です。
1. 文字列を 8 バイトずつ切り出す
2. それぞれの 8 バイトに対して ~find.s~ のようなロジックでヌル文字の有
   無を判定する。ヌル文字がなければ 1. に戻る
3. ヌル文字が 8 バイト中の何バイト目かを判定し、文字列長を計算する
4. 計算した文字列長を返す
#+end_note

それでは、
プログラム ~find.s~ の動作を実際にトレースしてみましょう (アセンブルやリンクの方法は同じなので省略します)。
以下のような ~.gdbinit~ ファイル (図 [[fig:x86simd/mmx-find/.gdbinit]]) を用意し、
デバッガ上でプログラム ~find~ を起動します。

#+caption: x86simd/mmx-find/.gdbinit
#+label: fig:x86simd/mmx-find/.gdbinit
#+include: "code/x86simd/mmx-find/.gdbinit" src gdb

最初の命令は \inst{movq 0x804a000,%mm0} で、
メモリから 8 バイトの文字列を読み込んでいるだけです。
#+begin_src gdb
$ gdb -q find
Reading symbols from find...
(No debugging symbols found in find)
Breakpoint 1 at 0x8049000
(gdb) r ← run の省略形
Starting program: /home/ohsaki/code/x86simd/mmx-find/find 

Breakpoint 1, 0x08049000 in _start ()
1: /x $mm0.v8_int8 = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
2: /x $mm1.v8_int8 = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
3: /x $eax = 0x0
4: x/4i $pc
=> 0x8049000 <_start>:  movq   0x804a000,%mm0
   0x8049007 <_start+7>:        pxor   %mm1,%mm1
   0x804900a <_start+10>:       pcmpeqb %mm0,%mm1
   0x804900d <_start+13>:       packsswb %mm1,%mm1
(gdb) si ← stepi の省略形
0x08049007 in _start ()
1: /x $mm0.v8_int8 = {0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x21, 0x0, 0xff}
2: /x $mm1.v8_int8 = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
3: /x $eax = 0x0
4: x/4i $pc
=> 0x8049007 <_start+7>:        pxor   %mm1,%mm1
   0x804900a <_start+10>:       pcmpeqb %mm0,%mm1
   0x804900d <_start+13>:       packsswb %mm1,%mm1
   0x8049010 <_start+16>:       movd   %mm1,%eax
(gdb) 
#+end_src
レジスタ MM0 に 8 文字「~Hello!~」が読み込まれており、
今の場合、
7 文字目がヌル文字 (0x00) であることがわかります。

次の命令は \inst{pxor %mm1,%mm1} です。
PXOR 命令は名前から想像できるようにベクトル版の排他的論理和です。
#+begin_src asm
	xor	%eax, %eax
#+end_src
によってレジスタ EAX の値がゼロになるのと同じように、
#+begin_src asm
	pxor	%mm1, %mm1
#+end_src
によってレジスタ MM1 のすべてのビットがゼロになります。
今はレジスタ MM0 中にヌル文字があるかを判定したいため、
比較対象である、
レジスタ MM1 のすべての要素をヌル文字にしています。

さらに 1 命令、
ステップ実行していきます。
今の場合、
レジスタ MM1 の値はもともとゼロでしたので、
PXOR 命令を実行しても特に変化はありません。
#+begin_src gdb
(gdb) ← リターンキーを押す (stepiコマンドの繰り返し)
0x0804900a in _start ()
1: /x $mm0.v8_int8 = {0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x21, 0x0, 0xff}
2: /x $mm1.v8_int8 = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
3: /x $eax = 0x0
4: x/4i $pc
=> 0x804900a <_start+10>:       pcmpeqb %mm0,%mm1
   0x804900d <_start+13>:       packsswb %mm1,%mm1
   0x8049010 <_start+16>:       movd   %mm1,%eax
   0x8049013 <_start+19>:       mov    $0x1,%eax
(gdb) 
#+end_src

次の命令は \inst{pcmpeqb %mm0, %mm1} です。
前述のとおり、
レジスタ MM0 中のヌル文字の箇所に対応する、
レジスタ MM1 のバイトが 0xff になります。
実行してみましょう。
#+begin_src gdb
(gdb) ← リターンキーを押す (stepiコマンドの繰り返し)
0x0804900d in _start ()
1: /x $mm0.v8_int8 = {0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x21, 0x0, 0xff}
2: /x $mm1.v8_int8 = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x0}
3: /x $eax = 0x0                                    ↑ ヌル文字の箇所が 0xff になった
4: x/4i $pc
=> 0x804900d <_start+13>:       packsswb %mm1,%mm1
   0x8049010 <_start+16>:       movd   %mm1,%eax
   0x8049013 <_start+19>:       mov    $0x1,%eax
   0x8049018 <_start+24>:       int    $0x80
(gdb) 
#+end_src
期待どおり、
レジスタ MM1 の 7 バイト目 (レジスタ MM1 の 48〜55 ビット) が 0xff となっています。

ここからは、
レジスタ MM1 中に 0xff のバイトが存在するかを判定します。
次の命令は \inst{packsswb %mm1, %mm1} ですが、
これはレジスタ MM1 の 64 ビット (16 ビット \times 8) を、
レジスタの下位 32 ビット (8 ビット \times 8) に集約する命令です。
1 命令ステップ実行しましょう。
#+begin_src gdb
(gdb) ← リターンキーを押す (stepiコマンドの繰り返し)
0x08049010 in _start ()
1: /x $mm0.v8_int8 = {0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x21, 0x0, 0xff}
2: /x $mm1.v8_int8 = {0x0, 0x0, 0x0, 0x7f, 0x0, 0x0, 0x0, 0x7f}
3: /x $eax = 0x0      ↑64ビットのデータが32ビットに集約された
4: x/4i $pc
=> 0x8049010 <_start+16>:       movd   %mm1,%eax
   0x8049013 <_start+19>:       mov    $0x1,%eax
   0x8049018 <_start+24>:       int    $0x80
   0x804901a:   add    %al,(%eax)
(gdb) 
#+end_src
レジスタ MM1 の値が変化しました。
何がどう変化したのかわかりづらいですが、
レジスタ MM1 の値が 0x00ff000000000000 から 0x7f0000007f000000 になっており、
16 ビットの 0x00ff (= 255) が、
型変換によって 8 ビットの 0x7f (= 127) になっています。
PACKSSWB 命令は、
符号付きの飽和演算であるため、
255 を 8 ビットに符号付き整数として格納しようとして、
255 が符号付き整数の最大値 127 を超えているため、
最大値である 127 (= 0x7f) を格納しています。

最後の命令は \inst{movd %mm1, %eax} です。
MOVD 命令で、
末尾が D なので、
Doubleword (ダブルワード = 32 ビット) を転送する命令であることがわかります。
この命令は、
レジスタ MM1 の下位 32 ビットをレジスタ EAX にコピーします。
#+begin_src gdb
(gdb) ← リターンキーを押す (stepiコマンドの繰り返し)
0x08049013 in _start ()
1: /x $mm0.v8_int8 = {0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x21, 0x0, 0xff}
2: /x $mm1.v8_int8 = {0x0, 0x0, 0x0, 0x7f, 0x0, 0x0, 0x0, 0x7f}
3: /x $eax = 0x7f000000 ← MM1の下位32ビットが格納された
4: x/4i $pc
=> 0x8049013 <_start+19>:       mov    $0x1,%eax
   0x8049018 <_start+24>:       int    $0x80
   0x804901a:   add    %al,(%eax)
   0x804901c:   add    %al,(%eax)
(gdb) 
#+end_src
レジスタ EAX にレジスタ MM1 の下位 32 ビットが格納されました。
レジスタ EAX の値がゼロではないことから、
8 文字の文字列中にヌル文字が含まれていたことがわかります。

*** 浮動小数点数によるユークリッド距離の計算 (SSE2 命令)

もう 1 つ、
これまでとは違ったタイプの SIMD 命令を使ったアセンブリ言語プログラムをトレースしてみましょう。

SSE 拡張によって可能になった浮動小数点数演算を使い、
点 ($x$, $y$) の原点からのユークリッド距離を計算するプログラム ~dist.s~ です (図 [[fig:x86simd/sse-dist/dist.s]])。
x87 FPU 命令を使ったプログラム ([[sec:x86fp/x87-inst]] 節の図 [[fig:x86fp/dist.s]]) と同じ計算を、
SSE2 拡張の SIMD 命令を使って書いています。

#+caption: x86simd/sse-dist/dist.s
#+label: fig:x86simd/sse-dist/dist.s
#+include: "code/x86simd/sse-dist/dist.s" src asm

SSE2 拡張の SIMD 命令を使うので、
64 ビットの MMX レジスタではなく、
*128 ビットの XMM レジスタ* を使用します。
また、
浮動小数点数の格納や演算はすべて *倍精度* で行っています。
倍精度の浮動小数点数の大きさは 64 ビットなので、
XMM レジスタには 2 つの要素が格納できます。
このため、
XMM レジスタには点の座標 ($x$, $y$) のデータががちょうど収まります。

プログラム ~dist.s~ をアセンブルおよびリンクして、
デバッガの監視下で実行していきましょう (これまでと同じ手順ですので説明は省略します)。
今回は、
以下のような ~.gdbinit~ ファイルを用意しておきます。

#+caption: x86simd/sse-dist/.gdbinit
#+label: fig:x86simd/sse-dist/.gdbinit
#+include: "code/x86simd/sse-dist/.gdbinit" src gdb

\inst{~display $xmm0.v2_double~} は、
レジスタ XMM0 の値を倍精度の浮動小数点数として表示しています。
また、
\inst{~display/gf &dist~} はラベル ~dist~ の番地に格納されている値を倍精度の浮動小数点数として表示しています。

デバッガの監視下でプログラム ~dist~ を起動します。
#+begin_src gdb
$ gdb -q dist
Reading symbols from dist...
(No debugging symbols found in dist)
Breakpoint 1 at 0x8049000
(gdb) r ← run コマンドの省略形
Starting program: /home/ohsaki/code/x86simd/sse-dist/dist 

Breakpoint 1, 0x08049000 in _start ()
1: $xmm0.v2_double = {0, 0} ← レジスタXMM0の要素の値
2: x/fg &dist  0x804a000:       0 ← メモリに格納されている値
3: x/4i $pc
=> 0x8049000 <_start>:  movapd 0x804a010,%xmm0
   0x8049008 <_start+8>:        mulpd  %xmm0,%xmm0
   0x804900c <_start+12>:       haddpd %xmm0,%xmm0
   0x8049010 <_start+16>:       sqrtpd %xmm0,%xmm0
(gdb) 
#+end_src
レジスタ XMM0 中の要素の値 (64 ビットの倍精度浮動小数点数 \times 2) が表示されており、
現在はどちらもゼロになっています。
また、
ラベル ~dist~ (0x804a000 番地) に格納されている値も表示されていますが、
この値も現在はゼロです。

最初の命令は \inst{movapd 0x804a010, %xmm0} です。
メモリの 0x804a010 番地から、
*128 ビットのデータ* をレジスタ XMM0 に読み込みます。
表 [[tab:x86sim/convention]] より、
MOVAPD 命令は、
「データを MOVe (転送) する命令であり、
転送されるデータは Aligned な (配置された) Packed Double-precision floating-point (詰められた倍精度浮動小数点)」となります。

128 ビット中に倍精度浮動小数点数を 2 つ格納するため packed (詰められた) と呼ばれています。
*Aligned (配置された)* というのは、
MOVAPD 命令がアクセスするデータは 16 の倍数となるアドレスに配置されていることを意味しています。

#+begin_note
SSE 拡張以降の SIMD 命令の多くは、
メモリ上のデータが 16 の倍数のアドレスに配置されていることを前提としています。
そのため、
メモリ上のデータが 16 の倍数のアドレスに配置されていないと、
SIMD 命令の実行に失敗したり、
命令の実行が非常に遅くなったりしてしまいます。
#+end_note

MOVAPD 命令を実行します。
#+begin_src gdb
(gdb) si
0x08049008 in _start ()
1: $xmm0.v2_double = {1.23, -4.5599999999999996}
2: x/fg &dist  0x804a000:       0
3: x/4i $pc
=> 0x8049008 <_start+8>:        mulpd  %xmm0,%xmm0
   0x804900c <_start+12>:       haddpd %xmm0,%xmm0
   0x8049010 <_start+16>:       sqrtpd %xmm0,%xmm0
   0x8049014 <_start+20>:       movsd  %xmm0,0x804a000
(gdb) 
#+end_src
1 命令で、
2 つの倍精度浮動小数点数がレジスタ XMM0 に読み込まれました。

次の命令は \inst{mulpd %xmm0, %xmm0} です。
MULPD 命令は SIMD 版の乗算命令であり、
意味は「MULtiply (乗算する) 命令であり、
乗算されるデータは Packed Double-precision floating-point (詰められた倍精度浮動小数点) である」となります。
それぞれ 2 つのオペランドに、
どちらもレジスタ XMM0 を指定しているので、
レジスタ XMM0 の各要素の値が 2 乗されます。

1 命令ステップ実行します。
#+begin_src gdb
(gdb) ← リターンキーを押す (stepiコマンドの繰り返し)
0x0804900c in _start ()
1: $xmm0.v2_double = {1.5128999999999999, 20.793599999999998}
2: x/fg &dist  0x804a000:       0
3: x/4i $pc
=> 0x804900c <_start+12>:       haddpd %xmm0,%xmm0
   0x8049010 <_start+16>:       sqrtpd %xmm0,%xmm0
   0x8049014 <_start+20>:       movsd  %xmm0,0x804a000
   0x804901c <_start+28>:       mov    $0x1,%eax
(gdb) 
#+end_src
たったの 1 命令で、
2 つの浮動小数点数が 2 乗されました。

次の命令は \inst{haddpd %xmm0,%xmm0} です。
HADDPD 命令は SSE3 拡張で新しく追加された *水平演算命令* であり (図 [[fig:x86simd/haddpd.png]])、
ニーモニックから「Horizontal (水平方向の) ADD (加算する) 命令であり、
加算されるデータは Packed Double-precision floating-point (詰められた倍精度浮動小数点) である」と読み解けます。

#+caption: HADDPD 命令の動作
#+label: fig:x86simd/haddpd.png
#+attr_latex: :width \columnwidth
[[./figure/x86simd/haddpd.png]]

一般的な SIMD 命令は、
2 つのベクトルを縦方向に演算します。
つまり、
2 つのベクトル ${\mathbf x} = (x_1, \dots, x_n)$ および ${\mathbf y} = (y_1, \dots, y_n)$ に対して、
${\mathbf x}$ と ${\mathbf y}$ のそれぞれの要素に対して演算を行います。
一方、
水平方向の演算命令は、
${\mathbf x}$ 中の $x_i$ や $x_j$ に対して演算を行います。

例えば、
#+begin_src asm
	haddpd	%xmm1, %xmm0
#+end_src
では、
- レジスタ XMM0 の中の 2 つの要素を加算し、レジスタ XMM0 の下位の要素に格納
- レジスタ XMM1 の中の 2 つの要素を加算し、レジスタ XMM0 の上位の要素に格納
という処理が行われます。
したがって、
\inst{haddpd %xmm0,%xmm0} を実行すると、
レジスタ XMM0 の 2 つの要素の和が、
レジスタ XMM0 の上位および下位の両方に格納されます。

実際に実行してみましょう。
#+begin_src gdb
(gdb) ← リターンキーを押す (stepiコマンドの繰り返し)
0x08049010 in _start ()  ↓XMM0の2つの要素の和が格納された
1: $xmm0.v2_double = {22.306499999999996, 22.306499999999996}
2: x/fg &dist  0x804a000:       0
3: x/4i $pc
=> 0x8049010 <_start+16>:       sqrtpd %xmm0,%xmm0
   0x8049014 <_start+20>:       movsd  %xmm0,0x804a000
   0x804901c <_start+28>:       mov    $0x1,%eax
   0x8049021 <_start+33>:       int    $0x80
(gdb) 
#+end_src
レジスタ XMM0 の 2 つの要素が、
どちらも $x^2 + y^2 \simeq 22.306$ になっていることがわかります。

あとは、
$x^2 + y^2$ の平方根を求めればユークリッド距離を求められます。
そこで、
平方根を計算する SIMD 命令 (SQRTPD 命令) を使って \inst{sqrtpd %xmm0, %xmm0} として、
レジスタ XMM0 の各要素の平方根を計算し、
計算結果をレジスタ XMM0 に格納します。

さらに 1 命令実行します。
#+begin_src gdb
(gdb) ← リターンキーを押す (stepiコマンドの繰り返し)
0x08049014 in _start () ↓22.306の平方根が計算された
1: $xmm0.v2_double = {4.7229757568719313, 4.7229757568719313}
2: x/fg &dist  0x804a000:       0
3: x/4i $pc
=> 0x8049014 <_start+20>:       movsd  %xmm0,0x804a000
   0x804901c <_start+28>:       mov    $0x1,%eax
   0x8049021 <_start+33>:       int    $0x80
   0x8049023:   add    %al,(%eax)
(gdb) 
#+end_src
無事、
ユークリッド距離 $\sqrt{x^2 + y^2} \simeq 4.723$ を求められました。

最後の命令は \inst{movsd %xmm0, 0x804a000} です。
これは、
レジスタ XMM0 の値 (下位 64 ビットの値) をメモリの 0x804a000 番地に格納します。
表 [[tab:x86sim/convention]] より MOVSD 命令は、
「データを MOVe (転送する) 命令であり、
転送するデータは Scalar Double-precision floating-point (単一の倍精度浮動小数点) である」ことがわかります。
なお MOVSD 命令の最後の SD は、
レジスタ XMM0 全体ではなく、
レジスタ XMM0 の最下位の要素のみを転送する命令であることを意味しています。

最後に、
もう 1 命令ステップ実行します。
#+begin_src gdb
(gdb) ← リターンキーを押す (stepiコマンドの繰り返し)
0x0804901c in _start ()
1: $xmm0.v2_double = {4.7229757568719313, 4.7229757568719313}
2: x/fg &dist  0x804a000:       4.7229757568719313
3: x/4i $pc                     ↑XMM0の最下位の要素が転送された
=> 0x804901c <_start+28>:       mov    $0x1,%eax
   0x8049021 <_start+33>:       int    $0x80
   0x8049023:   add    %al,(%eax)
   0x8049025:   add    %al,(%eax)
(gdb) 
#+end_src
ラベル ~dist~ のメモリに、
計算結果が正しく格納されたことがわかります。

ユークリッド距離の計算が、
SSE2 拡張や SSE3 拡張の SIMD 命令に適していることもあり、
非常に少ない命令で複雑な浮動小数点数演算ができています。
x87 FPU 命令を使ったアセンブリ言語プログラム (図 [[fig:x86fp/dist.s]]) と比較しても、
命令数が大幅に減ってることがわかります。

** コードリーディング
<<sec:x86simd/reading>>

*** 2 つのベクトルから大きいほうの要素の抽出 (SSE4.1 命令)

さらにいくつか IA-32 アーキテクチャの SIMD 命令を使ったアセンブリ言語プログラムを読んでみましょう。

次は、
2 つのベクトルの各要素から、
*大きいほうの要素* を抽出するプログラム ~max.s~ です。
つまり、
2 つのベクトル ${\mathbf x} = (x_1, \dots, x_n)$ および ${\mathbf y} = (y_1, \dots, y_n)$ に対して、
(\max(x_1, y_1), \dots, \max(x_n, y_n)) を求めるプログラムです。

#+caption: x86simd/sse4-max/max.s
#+label: fig:x86simd/sse4-max/max.s
#+include: "code/x86simd/sse4-max/max.s" src asm

MMX テクノロジ拡張には、
2 つのベクトルの大きいほうの要素や小さいほうの要素を抽出する SIMD 命令はありませんでした。
MMX 命令を使ってこういった処理を実現するためには、
比較命令と論理演算命令を組み合わせる必要がありました。
こういったプログラミングもパズルのようで面白いのですが、
SSE 拡張では、
単一の SIMD 命令だけで、
大きいほうの要素や小さいほうの要素を抽出できるようになりました。

このプログラムの要点を説明しましょう。
このプログラムは、
ラベル ~vec1~ と ~vec2~ に配置された、
長さ 16 の 2 つのベクトルから、
各要素が大きいほうの値を抽出します。
つまり、
( -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7) と (7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5, -6,
-7, -8) という 2 つのベクトルから、各要素が大きいほうの値を取り出した
(7, 6, 5, 4, 3, 2, 1, 0, 0, 1, 2, 3, 4, 5, 6, 7) を求めます。

まず、
#+begin_src asm
        ## vec1から16バイト(128ビット)をXMM0に読み込み
        movdqa  vec1, %xmm0             # XMM0 ← [vec1]
#+end_src
はこれまでにも登場した MOVDQA 命令です。
MOVDQA 命令は、
「データを MOVe (転送) する命令であり、
転送するデータは Double Quadword (ダブル・クワッドワード = 128 ビット) で、
そのデータはメモリ上に Aligned (配置された) 必要がある」というものでした。
ここでは、
ラベル ~vec1~ のアドレスから 16 個のバイトをレジスタ XMM0 に読み込んでいます。

このプログラムの核は、
次の
#+begin_src asm
        ## XMM0とvec2の各要素の最大値をXMM0に保存
        pmaxsb  vec2, %xmm0             # XMM0 ← max(XMM0, vec2)
#+end_src
です。
PMAXSB 命令だけで、
指定したオペランドの 2 つのベクトルの各要素から大きいほうを取り出し、
結果を宛先オペランドに格納します。
今の場合、
レジスタ XMM0 とメモリ ~vec2~ 上の 2 つのベクトルをバイト単位で比較し、
結果をレジスタ XMM0 に格納しています。
これまでと同じように、
PMAXSB という命令のニーモニックを解釈すると、
「Packed (詰められた) データの MAXimum (最大値) を求める命令であり、
データは Signed (符号付き整数) である Byte (バイト) である」となります。

なお、
PMAXSB 命令は、
SSE4.1 拡張で導入された SIMD 命令です。
このため、
SSE4 拡張に対応していない古い CPU では動作しません。

*** 2 つのベクトルの内積の計算 (SSE4.1 命令)

次のプログラムも 2 つのベクトルの内積計算です。

先ほど、
MMX テクノロジの SIMD 命令を使ったプログラム (図 [[fig:x86simd/mmx-prod/prod.s]]) を示しました。
MMX テクノロジの PMADDWD 命令を使用して、
長さが 4 の 2 つのベクトル (ただし各要素は 16 ビットの整数) の内積を計算するというものでした。

MMX テクノロジ拡張の PMADDWD 命令もすごい命令でしたが、
SSE4.1 拡張になってもっとすごい命令が追加されました。
以下のプログラム ~prod.s~ (図 [[fig:x86simd/sse4-prod/prod.s]]) は、
長さが 2 で要素が倍精度浮動小数点数であるような、
2 つのベクトルの内積を求めるプログラムです。

#+caption: x86simd/sse4-prod/prod.s
#+label: fig:x86simd/sse4-prod/prod.s
#+include: "code/x86simd/sse4-prod/prod.s" src asm

最初の
#+begin_src asm
        ## vec1 番地に格納されたベクトルのデータを XMMX0 に読み込み
        movdqa  vec1, %xmm0             # XMM0 ← [vec1]
#+end_src
は、
これまで何度も登場した MOVDQA 命令です。
メモリ上の 128 ビットのデータをレジスタ XMM0 に読み込んでいます。

このプログラムの核は、
次の
#+begin_src asm
        ## XMM0とvec2の内積を計算し、XMM0の上位・下位にそれぞれ保存
        dppd    $0b110011, vec2, %xmm0  # XMM0 ← XMM0 と [vec2] の内積
#+end_src
です。
なんと、
DPPD 命令という、
たったの 1 命令だけで内積が計算できています。
DPPD 命令も表 [[tab:x86sim/convention]] より、
「Dot Product (内積) を計算する命令であり、
内積を計算するベクトルのデータは Packed Double-precision floating-point (詰められた倍精度浮動小数点) である」と読み解けます。

2 つのベクトルの内積を 1 命令で計算するだけあり、
DPPD 命令のオペランドはやや複雑です。
DPPD 命令は「ビットマスク, レジスタ/メモリロケーション, レジスタ」という 3 つのオペランドを取ります。
DPPD 命令は、
基本的に、
第 2 オペランドと第 3 オペランドに指定した 2 つのベクトルの内積を計算します。
ただし、
2 つのベクトルのどの部分を内積計算に含めるか (もしくは含めないか)、
また、
計算した内積を宛先オペランドのレジスタのどの部分に格納するかを「マスク」で指定します。
DPPD 命令の詳細については文献 \cite{Intel20:IA32} を参照してください。

ただし、
文献 \cite{Intel20:IA32} における DPPD の説明を読むと
#+begin_quote
5.10.2 Floating-Point Dot Product Instructions \\
DPPD \quad \quad Perform double-precision dot product up to 2 elements and broadcast
#+end_quote
との記述がありますが、
IA-32 アーキテクチャの SIMD 命令の初心者にはわかりづらい説明ではないでしょうか。
「dot product (内積)」を計算するのはよいとしても、
「broadcast (ブロードキャスト) を実行する」とは何のことかわからないでしょう。

IA-32 アーキテクチャの SIMD 命令には、
packed、
aligned、
saturated、
gather、
broadcast、
shuffle、
blend、
horizontal addition/subtraction のような用語が登場しますが、
これらはそれぞれ SIMD 命令に特有の概念を表しています。

以下では、
これらの用語のうち、
本書でまだ取り上げていないものを簡単に説明します。

- broadcast (ブロードキャスト)
# SSE4.1

  英語の broadcast は、
  テレビやラジオで「放送する」という意味です。
  このため、
  SIMD 命令の broadcast も、
  演算結果をコンピュータ内部のバス上の他のデバイスに広告したり、
  演算結果をネットワークで接続された他のコンピュータに広告したりすることかと想像するかもしれませんが、
  違います。
  SIMD 命令におけるブロードキャスト (broadcast) は、
  もともとの英語の「broad (広く) + cast (ばらまく)」の意味です。
  つまり、
  SIMD 命令におけるブロードキャストとは、
  ベクトル中のある要素を、
  他のベクトルの要素にコピーする (ばらまく) ことを意味します。
    
  VPBROADCASTD 命令、
  VPBROADCASTW 命令、
  VPBROADCASTB 命令などがブロードキャスト命令です。
  これらの命令は、
  あるベクトルの最下位の要素を、
  他のベクトルのすべての要素にコピー (ブロードキャスト) します。
  先ほどの DPPD 命令の場合は、
  2 つのベクトルの内積を計算したあと、
  計算結果をベクトル内のすべての要素に (「マスク」で除外されていなければ) コピーします。

- shuffle (シャッフルする、ごちゃまぜにする)

  トランプのようなカードゲームのカードを混ぜる (でたらめな順番に入れ  替える) ことを「シャッフル」と呼びます。
  SIMD 命令における shuffle (シャッフルする) もカードのシャッフルと  同じような意味です。
  SIMD 命令におけるシャッフル (shuffle) とは、
  ベクトル中の要素の順番を入れ替えて、
  他のベクトルにコピーすることを意味します。
  
  PSHUFD 命令、
  PSHUFW 命令、
  PSHUFLW 命令、
  PSHUFB 命令、
  SHUFPB 命令などがシャッフル命令です。
  これらの命令を使えば、
  ベクトルの要素を自由に組み替えて他のベクトルに格納できます。
  例えば、
  (1, 2, 3, 4) という長さ 4 のベクトルを、
  (2, 1, 4, 3) や (1, 1, 2, 2)、
  (3, 1, 4, 4) など (重複も許した形で) ベクトルの要素を自由に入れ  替えることができます。

- blend (ブレンドする、混ぜる)
# SSE4.1

  blend とは、
  2 つのベクトルの「いいところ取り」をしたベクトルを  作成するという操作を意味します。
  2 つのベクトル ${\mathbf x} = (x_1, \dots, x_n)$ および ${\mathbf y} = (y_1, \dots, y_n)$ に対して、
  $i \, (1 \le i \le n)$ 番目の要素を $x_i$ または $y_i$ から自由に組み  合わせることで新しいベクトルを作ります。
  
  VPBLENDD 命令、
  PBLENDW 命令、
  PBLENDVB 命令、
  BLENDPD 命令などがブレンド命令です。
  例えば、
  (1, 2, 3, 4) と (5, 6, 7, 8) という 2 つのベクトルから、
  (1, 2, 7, 8) や、
  (1, 6, 3, 8)、
  (5, 2, 3, 4) などのベクトルを得ることができます。
  それぞれの要素をどちらのベクトルから得るかは即値で指定します。

なお、
SIMD 命令を活かしたプログラムを作成する方法には、

1. SIMD 命令を実行するプログラムを *アセンブリ言語* で記述する (本章で
   示した方法)
2. C 言語や C++ 言語のプログラム中に、SIMD 命令を実行するアセンブリ言
   語プログラムを *インラインアセンブラ* ([[ch:inline]] 章) で記述する
3. C 言語や C++ 言語の *組み込み関数 (intrinsics; intrinsic function)*
   を使って、SIMD 命令を実行するプログラムを高級言語で記述する
4. C 言語や C++ 言語などの高級言語で普通にプログラムを作成し、*コンパ
   イラによる最適化* によって SIMD 命令を活かした機械語プログラムに変
   換する

などの方法があります。

3 番目の方法 (SIMD 命令のための組み込み関数を使う方法) を用いて、
冒頭の ~add-mul.s~ (図 [[fig:x86simd/add-mul.s]]) を書き直したものが ~add-mul-intr.c~ (図 [[fig:x86simd/add-mul-intr.c]]) です。

#+caption: x86simd/add-mul-intr.c
#+label: fig:x86simd/add-mul-intr.c
#+include: "code/x86simd/add-mul-intr.c" src raw

C コンパイラや C++ コンパイラには、
それぞれの SIMD 命令に対応する組み込み関数が用意されているので、
アセンブリ言語でプログラムを記述することなく、
SIMD 命令を利用したプログラミングが可能です。

#+begin_note
プログラミングにおいて「組み込み関数」と言えば、
普通は「built-in function」を指します。
ただし、
SIMD 命令のための組み込み関数は、
「intrinsics」や「intrinsic function」と呼ばれています。
このため、
SIMD 命令のプログラミングに関する情報を探す場合は、
「SIMD intrinsics」などをキーワードにしてください。
#+end_note

ただし、
こういった組み込み関数を使いこなすためには、
それぞれの SIMD 命令やアセンブリ言語の知識が不可欠です。
さらに、
SIMD 命令に対応した組み込み関数の使い方にも習熟する必要があります。
例えば、
上のプログラム ~add-mul-intr.c~ でも、
関数 ~print_vec~ において、
ベクトルの各要素を表示するために、
一見すると何やら不思議な処理を行っています。
アセンブリ言語プログラムを書くよりも、
インラインアセンブラで記述するほうが難しい ([[sec:inline/overview]] 節) のと同じように、
SIMD 命令を使ったアセンブリ言語プログラムを書くよりも、
SIMD 命令のための組み込み関数を使うほうが難しいと思います。
SIMD 命令を使ったプログラミングを学習するのであれば、
C 言語や C++ 言語の組み込み関数よりも、
アセンブリ言語で直接 SIMD 命令を操作するプログラムを書くことをおすすめします。

なお、
4 番目の方法も場合によっては非常に有効です。
最近のコンパイラの最適化アルゴリズムは非常に優秀なので、
単純なプログラムであれば、
C 言語や C++ 言語で普通に記述するだけで、
SIMD 命令を活用した高速な機械語プログラムに変換されることがあります。
C 言語や C++ 言語で記述したプログラムを、
コンパイラの最適化オプションをさまざまに変えてコンパイルし、
どのようなアセンブリ言語のプログラムに変換されているかを見てみるとよいでしょう。

** 章末問題
<<sec:x86simd/quiz>>

1. MMX テクノロジ命令を使用して、2 つのベクトル (1, 2, 3, 4) と (1, 0,
   -1, -2) の和を計算するアセンブリ言語プログラムを示せ。ただし、ベク
   トルの各要素は 16 ビットの符号付き整数とせよ。

   #+begin_answer
   プログラムの例: ~mmx-add.s~ (図 [[fig:x86simd/ex/mmx-add.s]])
   #+caption: x86simd/ex/mmx-add.s
   #+label: fig:x86simd/ex/mmx-add.s
   #+include: "code/x86simd/ex/mmx-add.s" src asm
   #+end_answer

2. 1. と同じだが、2 つのベクトルの差を計算するアセンブリ言語プログラム
   を示せ。

   #+begin_answer
   プログラムの例: ~mmx-sub.s~ (図 [[fig:x86simd/ex/mmx-sub.s]])
   #+caption: x86simd/ex/mmx-sub.s
   #+label: fig:x86simd/ex/mmx-sub.s
   #+include: "code/x86simd/ex/mmx-sub.s" src asm
   #+end_answer

3. 1. と同じだが、2 つのベクトルのそれぞれの要素の積を要素とするベクト
   ルを求めるアセンブリ言語プログラムを示せ。

   #+begin_answer
   プログラムの例: ~mmx-mul.s~ (図 [[fig:x86simd/ex/mmx-mul.s]])
   #+caption: x86simd/ex/mmx-mul.s
   #+label: fig:x86simd/ex/mmx-mul.s
   #+include: "code/x86simd/ex/mmx-mul.s" src asm
   #+end_answer

4. SSE2 命令を使用して、2 つのベクトル (1, 2, 3, 4, 5, 6, 7, 8) と (1,
   0, -1, -2, 1, 0, -1, -2)の和を計算するアセンブリ言語プログラムを示
   せ。ただし、ベクトルの各要素は 16 ビットの符号付き整数とせよ。

   #+begin_answer
   プログラムの例: ~sse2-add.s~ (図 [[fig:x86simd/ex/sse2-add.s]])
   #+caption: x86simd/ex/sse2-add.s
   #+label: fig:x86simd/ex/sse2-add.s
   #+include: "code/x86simd/ex/sse2-add.s" src asm
   #+end_answer

5. 4. と同じだが、2 つのベクトルの差を計算するアセンブリ言語プログラム
   を示せ。

   #+begin_answer
   プログラムの例: ~sse2-sub.s~ (図 [[fig:x86simd/ex/sse2-sub.s]])
   #+caption: x86simd/ex/sse2-sub.s
   #+label: fig:x86simd/ex/sse2-sub.s
   #+include: "code/x86simd/ex/sse2-sub.s" src asm
   #+end_answer

6. 4. と同じだが、2 つのベクトルのそれぞれの要素の積を要素とするベクト
   ルを求めるアセンブリ言語プログラムを示せ。

   #+begin_answer
   プログラムの例: ~sse2-mul.s~ (図 [[fig:x86simd/ex/sse2-mul.s]])
   #+caption: x86simd/ex/sse2-mul.s
   #+label: fig:x86simd/ex/sse2-mul.s
   #+include: "code/x86simd/ex/sse2-mul.s" src asm
   #+end_answer

7. SSE 命令を使用して、2 つのベクトル (1.23, 4.56, -7.8, 9.0) と
   (1.23, -1.23, 0, 4.56) の和を計算するアセンブリ言語プログラムを示せ。
   ただし、ベクトルの各要素は単精度浮動小数点数とせよ。

   #+begin_answer
   プログラムの例: ~sse-add.s~ (図 [[fig:x86simd/ex/sse-add.s]])
   #+caption: x86simd/ex/sse-add.s
   #+label: fig:x86simd/ex/sse-add.s
   #+include: "code/x86simd/ex/sse-add.s" src asm
   #+end_answer

8. 7. と同じだが、2 つのベクトルのそれぞれの要素の積を要素とするベクト
   ルを求めるアセンブリ言語プログラムを示せ。

   #+begin_answer
   プログラムの例: ~sse-mul.s~ (図 [[fig:x86simd/ex/sse-mul.s]])
   #+caption: x86simd/ex/sse-mul.s
   #+label: fig:x86simd/ex/sse-mul.s
   #+include: "code/x86simd/ex/sse-mul.s" src asm
   #+end_answer

8. 7. と同じだが、2 つのベクトルのそれぞれの要素対において、より大きい
   ほうの値を要素とするベクトルを求めるアセンブリ言語プログラムを示せ。

   #+begin_answer
   SSE 拡張で導入された MAXPS 命令を使えば 1 命令で大きいほうの値が取り出せる。

   プログラムの例: ~sse-max.s~ (図 [[fig:x86simd/ex/sse-max.s]])
   #+caption: x86simd/ex/sse-max.s
   #+label: fig:x86simd/ex/sse-max.s
   #+include: "code/x86simd/ex/sse-max.s" src asm
   #+end_answer

9. ラベル ~src~ が指す番地に格納された、4 つの BGRA (Blue, Green, Red,
   Alpha) 形式のピクセルデータ (4 バイト \times 4 個)を、RGBA (Red,
   Green, Blue, Alpha) 形式に変換し、ラベル ~dst~ が指す番地に格納する
   アセンブリ言語プログラムを示せ。ピクセルデータの R, G, B, A は、そ
   れぞれ 8 ビットの符号なし整数である。

   #+begin_answer
   SSSE3 拡張で導入されたシャッフルのための命令 (SHUFB 命令) を使用すると簡潔に書ける。

   プログラムの例: ~bgra2rgba.s~ (図 [[fig:x86simd/ex/bgra2rgba.s]])
   #+caption: x86simd/ex/bgra2rgba.s
   #+label: fig:x86simd/ex/bgra2rgba.s
   #+include: "code/x86simd/ex/bgra2rgba.s" src raw
   #+end_answer
