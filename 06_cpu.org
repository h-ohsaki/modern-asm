# -*- Org -*-
# 
# Copyright (c) 2021, Hiroyuki Ohsaki.
# All rights reserved.
# 

# This document is licensed under a Creative Commons
# Attribution-NonCommercial-ShareAlike 4.0 International License (CC
# BY-NC-SA 4.0).

# This document is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# Creative Commons License for more details.

# You should have received a copy of the license along with this work.
# If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

* コンピュータの構造: CPU の構成
<<ch:cpu>>

** 複雑化するコンピュータ
<<sec:cpu/complex>>

現在、
ありとあらゆる場所で *コンピュータ (computer)* が動いています。
パソコンやスマートフォン、
タブレット端末は当然のこと、
デジタル時計や、
体重計、
冷蔵庫、
携帯電話、
自動車など、
ほとんどすべての電子機器の内部でコンピュータが動いています。
しかし、
一言でコンピュータと言っても、
その構造はそれぞれ異なっています。

本書では、
主にインテルの *IA-32 アーキテクチャ (IA-32 architecture)* の CPU を対象としてアセンブリ言語プログラミングを学びます。
しかし、
例えば IA-32 アーキテクチャは、
冷蔵庫に内蔵されているような組み込み向け CPU のアーキテクチャとは大きく異なっています。

コンピュータの頭脳である *CPU (Central Processing Unit; 中央処理装置)* は過去数十年にわたって飛躍的に進歩しました。
インテルの IA-32 アーキテクチャの CPU は「信じられないくらい高機能であり、
そして同時に信じられないくらい複雑」です。

例えば、
IA-32 アーキテクチャを解説したソフトウェア開発マニュアル \cite{Intel20:IA32} は、
なんと 5 000 ページ以上もあります。
初学者が、
いきなり IA-32 アーキテクチャの全貌を理解しようとしてマニュアルを読み始めても、
間違いなく失敗に終わることでしょう。

ただし、
IA-32 アーキテクチャを含め、
現在実用化されているコンピュータの多くは *フォン・ノイマン・アーキテクチャ (von Neumann architecture)* を基礎としています。
冷蔵庫に内蔵されているような組み込み向けコンピュータも、
そのほとんどはフォン・ノイマン型のコンピュータです。
このため、
高度に大規模化・複雑化が進んだ最近のコンピュータに目を向ける前に、
現在のコンピュータの基礎となっているフォン・ノイマン・アーキテクチャを理解しましょう。

ここからは、
具体的なコンピュータアーキテクチャを取り上げるのではなく、
フォン・ノイマン・アーキテクチャの基礎を説明します。

** コンピュータの構成
<<sec:cpu/computer>>

一般に、
コンピュータは、
CPU (Central Processing Unit) と、
*メモリ (memory)*、
*入出力デバイス (I/O (Input/Output) device)* が、
*バス (bus)* を介して接続された構成となっています (図 [[fig:cpu/computer]])。

#+caption: コンピュータの構成
#+label: fig:cpu/computer
#+attr_latex: :width \textwidth
[[./figure/cpu/computer.png]]

まず、
CPU とは、
コンピュータの心臓部にあたる *LSI (Large-Scale Integration; 大規模集積回路)* です。
CPU は、
機械語で書かれたプログラムを解釈し、
実行します。
計算するのも、
データを処理するのも、
メモリにデータの保存を指示するのも、
入出力デバイスに指示を出すのも、
すべて CPU の役割です。
乱暴に言えば、
CPU がコンピュータの主役であり、
メモリや入出力デバイスは脇役であると言えます。
CPU が主人であり、
メモリや入出力デバイスは下僕 (しもべ) である、
ということもできます。

#+begin_note
CPU は *マイクロプロセッサ (microprocessor)* とも呼ばれます。
micro (小さな) + processor (処理装置) と呼ばれるだけあって、
CPU は小さな半導体部品です。
CPU の種類にもよりますが、
半導体部品の大きさはたかだか数 mm〜数 cm 四方程度です。

もし身近に不要となったパソコンがあれば、
分解して、
中身がどうなっているか調べてみてください。
例えば、
インテルのデスクトップ向け CPU の LSI は、
一辺が 4〜5 cm くらいもあります。

一見すると、
「さすが CPU はコンピュータの主役だけあって、
大きな LSI なんだな」という印象を持ってしまいます。
しかし、
実はその LSI の面積の大半は多数のピンが占めています。
CPU の半導体部品そのものは一辺が 5 mm くらいと非常に小さなものです。
#+end_note

*メモリ (memory)* とは、
コンピュータの記憶をつかさどる LSI です。
メモリは、
大きく分類して、
*揮発性メモリ (volatile memory)* と *不揮発性メモリ (non-volatile memory)* に分けられます。

揮発性メモリの多くは *RAM (Random-Access Memory)* です。
ランダムアクセス (radom access) という名前が付いてるだけあり、
メモリの好きな場所を、
自由な順番にアクセスすることが可能です。
RAM は書き換え可能なメモリであり、
データを消去したり、
データを書き込んだりすることができます。

不揮発性メモリの多くは *ROM (Read-Only Memory)* です。
read-only という名前のとおり、
データの読み出しのみが可能であり、
データの書き込みはできません。

#+begin_note
読み出しのみが可能なメモリが ROM なら、
読み書きの両方が可能なメモリは RWM (Read-and-Write Memory) などと呼ばれてもよさそうなものですが、
なぜか RAM と呼ばれています。
#+end_note

#+begin_note
このように、
フォン・ノイマン型のコンピュータでは、
CPU とメモリが完全に独立しています。
CPU は計算だけを行い、
メモリは記憶だけを行う、
というように役割が明確に分かれています。

余談になりますが、
非常に複雑で高度な情報処理装置である人間の「脳」では、
計算と記憶が一体で不可分になっています。
脳を構成する多数のニューロンは、
計算も行うし、
また同時に記憶も行うのだそうです。

究極のコンピュータのあるべき姿はどのような形なのでしょうか?
人間の脳のように、
計算と記憶が一体化したアーキテクチャが未来のコンピュータとして望ましいのでしょうか。
それとも、
フォン・ノイマン型のコンピュータのように、
計算と記憶を今後も独立させ続けるべきなのでしょうか。
#+end_note

*入出力デバイス (I/O device)* とは、
コンピュータの外部からコンピュータ内部へ情報を入力する、
またはコンピュータの内部からコンピュータの外部で情報を出力するための装置です。
コンピュータを構成するのは、
心臓部となる CPU、
記憶をつかさどるメモリ、
その他もろもろを担当するいろんな入出力デバイス、
と理解すればよいでしょう。

入力デバイスの例としては、
キーボード、
マウス、
ジョイスティック、
カメラ、
サウンドデバイス (音声入力)、
指紋センサ、
スキャナなどが挙げられます。

また、
出力デバイスの例としては、
ディスプレイ、
サウンドデバイス (音声出力)、
プリンタなどが挙げられます。

入力と出力の両方を行うデバイス (入出力デバイス) の例としては、
ハードディスク、
SSD (Solid-State Drive; 半導体ディスク)、
USB (Universal Serial Bus; 汎用シリアルバス) メモリなどのストレージデバイス、
ネットワークインターフェースなどが挙げられます。

バスに接続できればよいので、
基本的にどんな入出力デバイスでもコンピュータの一部として組み込むことが可能です。

CPU は *バス (bus)* と呼ばれる通信経路を介してメモリや入出力デバイスと通信します。
バスは CPU ・メモリ・入出力デバイスを相互に接続する通信経路です。
多くの場合、
バスとは、
CPU ・メモリ・入出力デバイス間を接続する複数の信号路 (プリント基板上のパターン) です。
このため、
例えばバス幅が 16 ビットの *パラレルバス (parallel bus)* であれば、
CPU の LSI と、
メモリの LSI、
入出力デバイスの LSI が、
相互に 16 本の基板上のパターンで接続されています。

** CPU の構成
<<sec:cpu/structure>>

前述のように、
現在のコンピュータは信じられないくらい高機能で複雑ですが、
それでもその多くはやはりフォン・ノイマン・アーキテクチャ (図 [[fig:cpu/neumann]]) を基礎としています。

#+caption: フォン・ノイマン・アーキテクチャ
#+label: fig:cpu/neumann
#+attr_latex: :width \textwidth
[[./figure/cpu/neumann.png]]

フォン・ノイマン・アーキテクチャは、
*プログラム内蔵型コンピュータ (stored-program computer)* の一種です。
メモリ内にコンピュータが実行するプログラムと、
そのプログラムが利用するデータが格納 (= 内蔵) されています。

プログラム内蔵型コンピュータは以下のように動作します。
まず、
CPU は、
メモリに格納されたプログラムを 1 語だけ読み込みます。
読み込んだ語を解釈し、
その語で指定された単純な処理を実行します。
単純な処理とは、
例えば、
メモリからデータを読み込んだり、
メモリにデータを書き込んだり、
簡単な計算 (加算や減算など) を行ったり、
プログラムを読み込むアドレスを変更するような処理です。

このような仕組みを実現するため、
フォン・ノイマン・アーキテクチャの CPU は、
- レジスタ (register)
- ALU (Arithmetic and Logic Unit; 算術論理演算装置)
- 制御装置 (control unit)
の 3 つで構成されます(図 [[fig:cpu/cpu-arch]])

#+caption: CPU の構成
#+label: fig:cpu/cpu-arch
#+attr_latex: :width .7\columnwidth
[[./figure/cpu/arch.png]]

*レジスタ (register)* (プロセッサレジスタ (processor register) とも呼ばれます) とは、
CPU 内部にある小容量の記憶領域です。
CPU そのものもが半導体部品ですので、
当然ながらその内部にあるレジスタも半導体でできています。

CPU の種類にもよりますが、
レジスタの総容量は数十バイトから数百バイトくらいしかありません。
レジスタは小容量ですが、
CPU 内部にあるため非常に高速にアクセス (読み書き) ができます。
CPU が実行する計算の一時結果を保存したり、
CPU の状態に関する情報を保存したりするために用いられます。

*ALU (Arithmetic and Logic Unit)* とは、
CPU 内部にある、
*算術演算 (arithmetic operation)* および *論理演算 (logical operation)* を行うデジタル回路です。
レジスタと同様に、
ALU も当然ながら半導体でできています。
ALU は、
レジスタもしくはメモリに格納されている値に対して算術演算や論理演算を行い、
計算結果をレジスタに格納します (レジスタの内容は計算結果で上書きされます)。

どのような算術演算・論理演算が可能かは CPU ごとに異なります。

算術演算の例としては、
整数どうしの加算・減算・乗算・除算などが挙げられます。

論理演算の例としては、
AND (論理積)、
OR (論理和)、
XOR (排他的論理和)、
NOT (論理否定) などのブール演算が挙げられます。

*制御装置 (control unit)* とは、
CPU の心臓部にあたるデジタル回路です。
制御装置は、
CPU ・メモリ・入出力デバイス間のデータの流れを制御し、
これらを連携して動作させます。

先ほど、
コンピュータの心臓部にあたるのが CPU だと述べました。
そしてコンピュータの心臓部にあたる CPU の、
さらにその心臓部にあたるのが制御装置だというわけです。

ここからは、
レジスタおよび制御装置についてもう少し詳しく説明します。

** レジスタ
<<sec:cpu/register>>

前述のように、
*レジスタ (register)* とは、
CPU 内部にある小容量の記憶領域です。
CPU にもよりますが、
レジスタは数個から数十個程度しかありません。

複数あるレジスタは、その役割によって
- 汎用レジスタ (general-purpose register)
- フラグレジスタ (flag register)
- プログラムカウンタ (program counter)
- スタックポインタ (stack pointer)
- 制御レジスタ (control register)
などに分類されます。

*汎用レジスタ (general-purpose register)* は、
計算の一時結果を保存するなど、
さまざまな用途に利用できるレジスタです。
ALU による算術演算・論理演算は、
汎用レジスタに格納されている値に対して実行できます。
ALU による計算結果も、
汎用レジスタに格納されます。
これも CPU によって異なりますが、
通常、
CPU は数個〜数十個程度の汎用レジスタを持っています。

それ以外のレジスタは特定用途のためのレジスタです。

*フラグレジスタ (flag register)* は、
ALU による算術演算・論理演算の結果の状態を保存するためのレジスタです。
フラグレジスタの値は ALU によって自動的に設定されます。
フラグレジスタには、
例えば、
ALU による計算結果が 0 であったか、
計算によってレジスタの値がオーバーフローしたかどうかなどの状態が記録されます。

*プログラムカウンタ (program counter)* は、
メモリ内に格納されたプログラムを、
次にメモリのどのアドレスから読み込めばよいかを表すレジスタです。
前述のように、
フォン・ノイマン・アーキテクチャはプログラム内蔵型コンピュータであり、
プログラムカウンタが差すアドレスのプログラムを順次読み込んで実行することで処理が行われます。
プログラムカウンタの値は (基本的には) 制御装置によって自動的に更新されます。

*スタックポインタ (stack pointer)* は、
*スタック (stack)* と呼ばれる、
メモリ上に確保された記憶領域のアドレスを表すレジスタです。
レジスタ数が少ないため、
汎用レジスタを計算の一時結果に利用するだけでは、
複雑な計算を行うことができません。
そこで、
スタックと呼ばれる一時退避用の記憶領域を使うことで、
汎用レジスタ数の不足に対処しています。
スタックポインタの値は (基本的には) 制御装置によって自動的に更新されます。

** 制御装置
<<sec:cpu/ctrl-unit>>

制御装置は、
おおよそ以下のように動作します。

1. フェッチ
2. デコード
3. 実行すべき処理にもとづき、ALU やバスに指示を出す
4. プログラムカウンタの値を、次に実行すべき命令を差すように増加させる
5. 1. に戻る

\relax 1. *フェッチ (fetch)* とは、
CPU が、
プログラムカウンタが差すアドレスから、
次に実行すべき (もちろん機械語の) 命令を読み込むことをいいます。
英語の fetch は「取ってくる」という意味です。

\relax 2. *デコード (decode)* とは、
機械語の命令 (コード) を解読し、
CPU が実行すべき処理を判断することです。

デコードを終えると、
3.の処理が行われ、
レジスタの値が書き換えられたり、
レジスタ→メモリやメモリ→レジスタのデータのコピーが行われたりします。

制御装置の動作は、
基本的にこのような処理の繰り返しです。

*** 演算

コンピュータは、
非常に高度で複雑な処理を実行することができます。

しかし、
CPU 内部で ALU が実行できるのは本当に単純な演算だけであり、
加算や乗算のような単純な算術演算と、
AND や OR のような単純な論理演算くらいしかできません。
CPU 内部で制御装置が実行できるのも本当に単純な処理だけです。
メモリに格納されたプログラムを順番に読み込んで、
1 つずつ実行するだけです。

ただし、
CPU はこれらの単純な計算や処理を、
*極めて高速に大量に* 実行することができます。
コンピュータはこのような単純ですが膨大な数の計算や処理を超高速に実行することにより、
大規模な科学技術計算 (例えば、
気候変動シミュレーション) や大規模データ処理 (例えば、
銀行のオンライン決済システム) を実現しています。

極めて複雑な生命体である人間も、
細胞レベルや、
分子レベルで見れば非常に単純なものの組み合わせでできています。
これと同様に、
極めて複雑なコンピュータプログラムも、
機械語レベルで見れば *非常に単純な計算と処理の組み合わせ* でできています。

ただし、
現在の科学技術では、
細胞や分子の挙動をどれだけ深く理解しても、
生命体である人間を完全に理解することはできません。

その一方、
機械語レベルで CPU (レジスタ・ ALU ・制御装置) の挙動を正しく理解すれば、
コンピュータプログラムを *完全に理解することができます*。
そういう意味では、
プログラムや、
それを実行するコンピュータを理解することは、
それほど難しいことではないともいえます。

レジスタ・ ALU ・制御装置の動きが心の目で「見える」ようになれば、
コンピュータやプログラムの動作を「実感」できるようになります。

** IA-32 アーキテクチャのレジスタ
<<sec:cpu/ia32-register>>

ここで、
一般的なフォン・ノイマン・アーキテクチャの話から、
具体的な例として IA-32 アーキテクチャの話へと移りましょう。

IA-32 アーキテクチャの最近の CPU は、
32 ビットモードに加えて *Intel 64* と呼ばれる 64 ビット拡張をサポートしています。
本書では、
IA-32 アーキテクチャの 32 ビットモードを中心に説明します
(64 ビットモードについては [[ch:x86-64]] 章で解説します)。

32 ビットモードにおける IA-32 アーキテクチャのレジスタ (汎用レジスタ、
セグメントレジスタ、
プログラムステータス制御レジスタ、
命令ポインタ) を図 [[fig:ia32reg]] に示します。
IA-32 アーキテクチャはかなり複雑なので、
一般的な CPU よりも多くのレジスタを持っています。

#+caption: 32 ビットモードにおける IA-32 アーキテクチャのレジスタ
#+label: fig:ia32reg
#+attr_latex: :width \textwidth
[[./figure/cpu/ia32reg.png]]

32 ビットモードにおける IA-32 アーキテクチャの *汎用レジスタ* は、
EAX、
EBX、
ECX、
EDX、
ESI、
EDI、
EBP、
ESP の 8 個です。
これらはすべて *32 ビットのレジスタ* (各レジスタの大きさが 32 ビット) です。
この中で、
ESP レジスタは汎用レジスタに分類されていますが、
実際にはスタックポインタとして利用されます。

*セグメントレジスタ* (CS、
DS、
SS、
ES、
FS、
GS レジスタ) はメモリのセグメントを指定するためのレジスタです。
これらのセグメントレジスタはオペレーティングシステムが管理するため、
通常、
アプリケーション側からは操作できません。
本書では、
オペレーティングシステムの管理下で動作するアプリケーションを対象としたアセンブリ言語プログラミングを説明するので、
セグメントレジスタはほとんど登場しません。

*EFLAGS レジスタ* は「プログラムステータス制御レジスタ」という長い名前が示すように、
プログラムの現在の実行状態の取得や、
プログラムの動作を制御するために使用されます。
EFLAGS レジスタは、
汎用レジスタやセグメントレジスタとは異なり、
多数のフラグの寄せ集めです。
EFLAGS の各ビットにそれぞれ意味があり、
各ビットの状態を取得したり設定したりすることによって、
プログラムの実行状態の取得やプログラムの動作の制御を行います。

*EIP レジスタ* は命令ポインタです。
一般的には *プログラムカウンタ* と呼ばれるレジスタです。
CPU が次に実行する命令が格納されているメモリのアドレスを保持しています。

IA-32 アーキテクチャのレジスタについては [[ch:x86regs]] 章で詳しく説明します。
また、
最近の IA-32 アーキテクチャの CPU は、
浮動小数点演算用レジスタ、
SIMD 命令用レジスタなどの、
特定の用途向けのレジスタも持っています (これらについては [[ch:x86fp]] 章および [[ch:x86simd]] 章で説明します)。
ここでは、
IA-32 アーキテクチャの細部のことは気にせずに、
フォン・フォン・ノイマン型のコンピュータとして IA-32 アーキテクチャをざっと眺めておきましょう。

ここまでの要点を整理すると以下のとおりです。

- 汎用レジスタは *8 個* (EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP レジス
  タ) である
- 汎用レジスタの大きさは *すべて 32 ビット* である (32 ビット CPU なの
  でデータの大きさもアドレスの大きさも 32 ビット)
- プログラムカウンタは EIP レジスタである
- スタックポインタは ESP レジスタである (スタックポインタが何かは
  [[ch:stack]] 章で説明します)
- CPU の算術演算・論理演算の実行状態は EFLAGS レジスタ中の各ビットに反
  映される

** 章末問題
<<sec:cpu/quiz>>

1. 英英辞典 (中規模以上のものが望ましい) で「memory」および「bus」の項
   をそれぞれ調べよ。また、コンピュータにおけるおける「メモリ」、「バ
   ス」に該当する解説を (解説の有無も含めて) 確認せよ。

2. 周囲のコンピュータや、CPU が搭載されていると思われる電子機器に接続
   されている入出力デバイスを列挙せよ。
