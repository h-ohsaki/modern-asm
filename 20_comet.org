# -*- Org -*-
# 
# Copyright (c) 2021, Hiroyuki Ohsaki.
# All rights reserved.
# 

# This document is licensed under a Creative Commons
# Attribution-NonCommercial-ShareAlike 4.0 International License (CC
# BY-NC-SA 4.0).

# This document is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# Creative Commons License for more details.

# You should have received a copy of the license along with this work.
# If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

* 仮想コンピュータの例: COMET II
<<ch:comet>>

** COMET II と CASL II の概要
<<sec:comet/overview>>

*** COMET II

COMET II とは、
独立法人情報処理推進機構が実施している *情報処理技術者試験* において、
ソフトウェア開発分野に関する試験問題のために作られた仮想的なコンピュータです。

情報処理技術者試験は国家資格試験ですので、
ある特定のコンピュータや特定の処理系 (例えばアセンブラ) を前提とした試験問題は望ましくありません。
このため、
現実に存在する特定のコンピュータや処理系ではなく、
仮想的に考えられた (実在しない) コンピュータ (*COMET II*) と、
そのコンピュータのためのアセンブリ言語 (*CASL II*) が考案されています (図 [[fig:comet/flow]])。

#+caption: CASL II と COMET II
#+label: fig:comet/flow
#+attr_latex: :width \columnwidth
[[./figure/comet/flow.png]]

COMET II は試験問題のために考えられたコンピュータであり、
本当に最小限のコンピュータアーキテクチャとなっています。
COMET II は、
レジスタの大きさこそ 8 ビットではなく 16 ビットですが、
コンピュータが登場した頃の、
4 ビットや 8 ビットのコンピュータのアーキテクチャ (をさらに単純にしたもの) のような構成になっています。

[[ch:x86regs]] 章 -- [[ch:x86ctrl]] 章で紹介した IA-32 アーキテクチャは信じられないくらい複雑でした。
IA-32 アーキテクチャの命令数は 500 以上、
ソフトウェア開発マニュアル \cite{Intel20:IA32} は 5 000 ページを超えるものでした。

一方、
COMET II のアーキテクチャは信じられないくらい単純な構成です。
COMET II の命令は *28 個* しかなく (表 [[tab:comet/inst]])。
COMET II の仕様書は、
なんと *たったの 3 ページ* しかありません。
IA-32 アーキテクチャのソフトウェア開発マニュアルの厚みにも驚きますが、
COMET II の仕様書の薄さにも驚きです。

#+caption: COMET II の命令
#+label: tab:comet/inst
#+attr_latex: :environment maxtabular
| 大分類                     | 小分類                   | 命令                             |
|----------------------------+--------------------------+----------------------------------|
| データ転送命令             | 汎用データ転送命令       | LD, ST, LAD, PUSH, POP           |
|                            | スタック操作命令         | PUSH, POP                        |
| 2 進算術命令               | 加算命令と減算命令       | ADDA, ADDL, SUBA, SUBL, CPA, CPL |
|                            | 比較命令と符号変更命令   | CPA, CPL                         |
| 論理演算命令               |                          | AND, OR, XOR                     |
| シフト命令とローテート命令 | ビットのシフト命令       | SLA, SLL, SRA, SRL               |
| 制御転送命令               | 無条件転送命令           | JUMP, CALL, RET                  |
|                            | 条件付き転送命令         | JPL, JMI, JNZ, JZE, JOV          |
|                            | ソフトウェア割り込み命令 | SVC                              |
| その他の命令               | ノー・オペレーション命令 | NOP                              |

COMET II には、
メモリとレジスタしかありません。
浮動小数点数演算命令や SIMD 命令はもちろんのこと、
割り込みも、
I/O ポートもありません。

ある意味、
COMET II は、
現実のコンピュータとは似ても似つかない、
オモチャのような単純なコンピュータのアーキテクチャです。
COMET II にどれだけ詳しくなっても、
現実のコンピュータのアセンブリ言語プログラムを作成することはできません。

しかし、
COMET II はフォンノイマン型コンピュータのエッセンスを取り出したようなアーキテクチャです。
[[sec:cpu/structure]] 節で述べたように、
現在利用されている多くのコンピュータはフォンノイマン型アーキテクチャを基礎としています。
COMET II は、
これ以上の機能を省いたら、
「さすがにコンピュータとしては使えなくなる」というギリギリの線まで単純化されたアーキテクチャです。
このため、
COMET II は、
コンピュータの仕組みや原理を学ぶためには理想形に近いコンピュータであるとも言えます。

IA-32 アーキテクチャを始めとする現在の CPU の命令セットアーキテクチャは極めて複雑なので、
ある意味、
「初心者お断り」の状態です。
現実のコンピュータは複雑すぎて、
初学者の人には、
何が重要で、
何が重要でないかがよくわからなくなっています。

一方、
COMET II は、
絶妙なバランスで設計された仮想コンピュータアーキテクチャです。
情報処理技術者試験において、
ソフトウェア開発分野における情報処理技術の本質を問うために必要十分な機能だけが含まれています。
したがって、
「COMET II みたいなオモチャを学んでも現実のコンピュータの理解には役立たない」のではなく、
「COMET II のような単純なアーキテクチャを学ぶとコンピュータの本質が理解できる」と言えます。
このため、
1. まず、COMET II をじっくり学び、フォンノイマン型コンピュータやアセン
   ブリ言語の基礎を習得する
2. その後、現実のコンピュータアーキテクチャや実際の処理系の使い方を習
   得する
というのが効果的な学習法です。

#+begin_note
筆者は、
高校生の頃にザイログの Z80 やモステクノロジーの 6502 (いずれも 8 ビット CPU) を書籍や雑誌を読んで学んでいました。
今の IA-32 アーキテクチャの CPU とは比べものにならないくらい単純な CPU です。
しかし、
Z80 や 6502 を学んでも、
「あ、
なるほど」という実感はあまり得られませんでした。

しかし、
大学生の頃に CASL と COMET (現在の CASL II や COMET II の 1 つ前のバージョンです) でアセンブリ言語プログラミングを学び、
「あ、
なるほど」という実感を得ることができました。

「コンピュータのことがイマイチよくわからない」、
「アセンブリ言語プログラミングがどうもしっくり来ない」という時は、
COMET II や CASL II でコンピュータやアセンブリ言語プログラミングの本質を学ぶとよいでしょう。
#+end_note

#+begin_quote
COMET II は仮想のコンピュータなので、
COMET II の CPU やワンボードコンピュータは (少なくとも筆者の知る限り) 存在しません。
現在、
Mouser や DigiKey などの電子部品を販売する会社から、
さまざまな種類の CPU を 1 個単位で購入することができます。
しかし、
COMET II の CPU は存在しないため、
もちろん購入することもできません。

COMET II は非常に単純なコンピュータアーキテクチャであり、
COMET II の CPU を自作することは難しくないでしょう。
本書では COMET II のシミュレータ (~comet~ プログラム) を使用しますが、
このシミュレータはたかだか数百行程度のプログラムです。
しかも、
プログラムの大半はトレース実行や逆アセンブル、
メモリダンプなどの処理が占めています。
COMET II のシミュレーションだけであれば、
すべてアセンブリ言語で書いてもかまわないくらいです。

また、
FPGA を使って COMET II の CPU を作成するといったことも可能です。
一部の大学や高専では、
カリキュラムの一部として COMET II の CPU を FPGA で作成しているところもあるようです。

COMET II は、
実用の観点からは最弱なコンピュータかもしれませんが、
学習の観点からは最強に近いコンピュータだと思います。
#+end_quote

*** CASL II

*CASL II* とは、
仮想コンピュータである COMET II のためのアセンブリ言語です。
CASL II で書かれたアセンブリ言語のプログラムを、
アセンブラによって COMET II が理解できる機械語に変換する、
ということが想定されています。
ここで、
CASL II はアセンブラ (処理系) ではなく、
アセンブラ (処理系) が解釈するアセンブリ言語 (プログラミング言語) であることに注意してください。

COMET II が (実際には存在しない) 仮想的なコンピュータであるのと同様に、
CASL II も (実際には存在しない) 仮想的なアセンブラが解釈するアセンブリ言語です。
「CASL II アセンブラ」という処理系が実際に存在するわけではありません。
CASL II はあくまでアセンブリ言語であり、
- プログラムのソースコードはどういった書式になっているか
- プログラムのラベルや定数にどんな文字が使えるか
- アセンブリ言語のニーモニックはどういった表記になっているか
などを定めたものです。

#+begin_note
CASL II はアセンブリ言語ですが、
CASL II のアセンブリ言語を解釈するアセンブラ (処理系) は複数実装されています。
本書でも、
Python で書かれた CASL II アセンブラ (~casl~ プログラム) と COMET II シミュレータ (~comet~ プログラム) を使用します。

COMET II が非常に単純なコンピュータアーキテクチャであるのと同じように、
CASL II も非常に単純なアセンブリ言語です。
CASL II アセンブラである ~casl~ プログラムも数百行程度のプログラムです。
数百行のプログラムなので、
読むことも、
書くこともそれほど難しくありません。
#+end_note

CASL II で書かれたプログラムの例を示します。
123 + 456 を計算するだけのプログラムです (図 [[fig:comet/add.cas]])。

#+caption: comet/add.cas
#+label: fig:comet/add.cas
#+include: "code/comet/add.cas" src casl

上の例では、
行頭の ~ADD~ や ~V~ は *ラベル (label)* です。
~START~、
~DC~、
~END~ はアセンブラの *疑似命令* です。

COMET II および CASL II は、
その前身である COMET および CASL を拡張した内容になっています。
オリジナルの COMET および CASL の仕様が策定されたのが 1986 年、
COMET II および CASL II の仕様が策定されたのが 2001 年です。
COMET と COMET II、
CASL と CASL II、
どちらもそれほど大きく変更されていません。

CASL II の前身の CASL が策定されたのが 1986 年ということもあり、
今となっては少し古さを感じるアセンブリ言語です。
例えば、
ラベルに使用できるのは英大文字か数字のみとなっており、
英小文字やアンダースコアなどは使用できません)。
ラベルの長さも 8 文字以下でなければなりません。

#+begin_comment
ただし、
COMET II と同様に、
CASL II も、
アセンブリ言語プログラミングの学習にとっては非常に有効です。
CASL II には、
情報処理技術者試験において、
ソフトウェア開発分野における情報処理技術の本質を問うために必要十分な仕様が含まれています。
このため、
「CASL II みたいなオモチャを学んでも現実のアセンブリ言語プログラミングには役立たない」のではなく、
「CASL II のような単純なアセンブリ言語を学ぶとアセンブリ言語プログラミングの本質が理解できる」と言えます。
#+end_comment

#+begin_note
本書を執筆するにあたり、
COMET II や、
その前身の COMET を扱った資料や書籍をいろいろ読んでみましたが、
COMET や CASL の名前の由来に関する記述は見当たりませんでした。

COMET の最初の 3 文字は computer の COM と思われますが、
末尾の 2 文字は何を意味しているのでしょう。
資格試験のための仮想コンピュータなので、
examination や test (どちらも「試験」を意味する英単語) 等の言葉から来ているのかもしれません。

CASL (キャッスル) の発音も字面も castle (城) と似ていますが、
CASL にはお城っぽい要素もなく、
英語の castle とは関係なさそうです。
おそらく、
CASL の名前の由来は「CASL (Comet ASsembLer)」ではないかと想像します。
#+end_note

*** COMET II シミュレータによるトレース

COMET II のレジスタ、
アドレス指定モード、
命令セットを説明する前に、
*CASL II アセンブラ* および *COMET II シミュレータ* を試してみましょう。
説明だけを読んでいても退屈でしょうし、
実際に手を動かして COMET II の動作を眺めるのがよいでしょう。
COMET II シミュレータによるプログラム実行の流れを図 [[fig:comet/simulator]] に示します。

#+caption: CASL II アセンブラと COMET II シミュレータ
#+label: fig:comet/simulator
#+attr_latex: :width \columnwidth
[[./figure/comet/casl-flow.png]]

まず、
アセンブリ言語 CASL II で書かれたプログラム (図 [[fig:comet/add.cas]]) を ~add.cas~ という名前で保存します。

次に、
CASL II アセンブラである *~casl~ コマンド* でアセンブルし、
機械語プログラム ~add.com~ に変換します。
~casl~ コマンドに ~-a~ オプションを指定し、
アセンブル結果 (図 [[fig:comet/add.cas]]) を出力します。
#+begin_src sh
$ casl -a add.cas
#+end_src

#+caption: add.cas のアセンブル結果
#+label: fig:comet/add.com
#+include: "code/comet/add.com" src casl

~casl~ コマンドの出力は、
GNU アセンブラ (GAS) の出力とほぼ同じです。
左端から、
アセンブリ言語プログラムの行番号、
機械語プログラムのアドレス、
機械語、
アセンブルされたプログラムです。

上のアセンブル結果の出力から、
0x0000〜0x0008 番地に、
9 ワード分の機械語の命令が生成されたことがわかります。
COMET II ではメモリの番地の単位はバイトではなくワードであることに注意してください。

ADDA 命令と RET 命令の命令語長が 1 ワードである一方、
それ以外の命令 (LD 命令、
LAD 命令、
ST 命令) の命令語長が 2 ワードであることもわかります。
最後の DC 命令はアセンブラの疑似命令です。
DC 命令のオペランドに指定した値をメモリ中に生成します。

COMET II シミュレータである ~comet~ コマンドで、
先ほど生成したプログラム ~add.com~ を実行します。
実行したい機械語プログラムのファイル名を引数に指定して、
*~comet~ コマンド* を起動します。
#+begin_src casl
$ comet add.com
This is COMET, version 1.0.
Copyright (c) 2021, Hiroyuki Ohsaki.
All rights reserved.
Reading object from add.com...done.
PR  #0000 [LD   GR1, #0009 <=123>             ] SP  #ffff  OF 0  SF 0  ZF 0
GR0 #0000 (     0) GR1 #0000 (     0) GR2 #0000 (     0) GR3 #0000 (     0)
GR4 #0000 (     0) GR5 #0000 (     0) GR6 #0000 (     0) GR7 #0000 (     0)
comet>
#+end_src
~comet~ コマンドの使い方は、
GDB (GNU デバッガ) を真似ています。
GDB の使い方を知っていれば ~comet~ コマンドもすぐに使えるようになるでしょう。

COMET II シミュレータでは、
以下の形式で、
現在のプログラムカウンタやレジスタに関する情報が表示されます。
#+begin_src casl
PR  #0000 [LD   GR1, #0008 <V>                ] SP  #ffff  OF 0  SF 0  ZF 0
GR0 #0000 (     0) GR1 #0000 (     0) GR2 #0000 (     0) GR3 #0000 (     0)
GR4 #0000 (     0) GR5 #0000 (     0) GR6 #0000 (     0) GR7 #0000 (     0)
#+end_src

1行目の
#+begin_src casl
PR  #0000 [LD   GR1, #0008 <V>                ] SP  #ffff  OF 0  SF 0  ZF 0
#+end_src
は左から順番にプログラムカウンタ (PR レジスタ) の値、
次に実行される命令の逆アセンブル結果、
スタックポインタ (SP レジスタ) の値、
3 つのフラグレジスタ (OF、
SF、
ZF フラグ) の値を示しています。
現在、
プログラムカウンタの値は 0x0000 であり、
次に実行される命令が \inst{LD GR1, #0008} であることがわかります。

CASL II ではこのように、
16 進数は先頭に番号記号 (~#~) を付けて表記され、
例えば ~#0008~ は 16 進数の 0x0008 を意味します。
OF、
SF、
ZF フラグはすべて 0 であることもわかります。
その次の
#+begin_src casl
GR0 #0000 (     0) GR1 #0000 (     0) GR2 #0000 (     0) GR3 #0000 (     0)
GR4 #0000 (     0) GR5 #0000 (     0) GR6 #0000 (     0) GR7 #0000 (     0)
#+end_src
は汎用レジスタである GR0〜GR7 の現在の値を 16 進数と 10 進数 (符号なし整数) として表示しています。
COMET II シミュレータの起動直後なので、
すべてのレジスタの値は 0 になっています。

この時の COMET II の状態を図 [[fig:add-0]] に示します。
メモリの 0x0000〜0x0008 番地に格納されている命令や値と、
それぞれのレジスタの状態を図示しています。
COMET II における汎用レジスタや、
プログラムカウンタ、
スタックポインタについては後ほど [[sec:comet-registers]] 節で説明します。

#+caption: プログラムカウンタが 0x0000 のときの状態
#+label: fig:add-0
[[./figure/comet/add-0.png]]

「~comet>~」が COMET II シミュレータのプロンプトです。
コマンドを入力してエンターキーを押します。

help コマンドでヘルプを見ることができます。
#+begin_src casl
comet> h
List of commands:

r,  run         Start execution of program.
c,  continue    Continue program being debugged after breakpoint.
s,  step        Step execution.  Argument N means do this N times.
b,  break       Set a breakpoint at specified address.
d,  del         Delete some breakpoints.
i,  info        Print information on breakpoints.
p,  print       Print status of PR/FR/GR0--GR7 registers.
du, dump        Dump 128 words of memory image from specified address.
st, stack       Dump 128 words of stack image.
f,  file        Use FILE as program to be debugged.
j,  jump        Continue program at specifed address.
m,  memory      Change the memory at ADDRESS to VALUE.
di, disasm      Disassemble 32 words from specified address.
l,  label       Print all defined labels.
h,  help        Print list of commands.
q,  quit        Exit comet.
comet> 
#+end_src
GDB と同じように、
コマンド名は help で、
help コマンドの省略形が h です。
GDB とよく似たコマンドが並んでいることがわかります。

1 命令ずつ実行するには step コマンド (省略形は s) を使用します。
1 命令だけステップ実行してみます。
実行される命令は \inst{LD GR1, #0008} です。
レジスタ GR1 に、
0x0008 番地に格納されている値が読み込まれます。
#+begin_src casl
comet> s
PR  #0002 [LAD  GR2, #01c8                    ] SP  #ffff  OF 0  SF 0  ZF 0
GR0 #0000 (     0) GR1*#007b (   123) GR2 #0000 (     0) GR3 #0000 (     0)
GR4 #0000 (     0) GR5 #0000 (     0) GR6 #0000 (     0) GR7 #0000 (     0)
comet>
#+end_src
プログラムカウンタの値が 0x0002 に増加しました (図 [[fig:add-2]])。
GR1 レジスタの値が 0x0000 から 0x007b に変化しました。
値が変化したレジスタには、
~GR1*~ のようにアスタリスク (~*~) が表示されます。
上の出力より、
レジスタ GR1 の値は 10 進数で 123 であることもわかります。

#+caption: プログラムカウンタが 0x0002 のときの状態
#+label: fig:add-2
[[./figure/comet/add-2.png]]

メモリの 0x0008 番地にどんな値が格納されていたのかを見てみましょう。
dump コマンド (省略形は du) でメモリの中身をダンプします。
#+begin_src casl
comet> du
0002 1220 01c8 2412 1110 0008 8100 007b 0000  .....{.
000a 0000 0000 0000 0000 0000 0000 0000 0000 ........
0012 0000 0000 0000 0000 0000 0000 0000 0000 ........
001a 0000 0000 0000 0000 0000 0000 0000 0000 ........
0022 0000 0000 0000 0000 0000 0000 0000 0000 ........
002a 0000 0000 0000 0000 0000 0000 0000 0000 ........
0032 0000 0000 0000 0000 0000 0000 0000 0000 ........
003a 0000 0000 0000 0000 0000 0000 0000 0000 ........
0042 0000 0000 0000 0000 0000 0000 0000 0000 ........
004a 0000 0000 0000 0000 0000 0000 0000 0000 ........
0052 0000 0000 0000 0000 0000 0000 0000 0000 ........
005a 0000 0000 0000 0000 0000 0000 0000 0000 ........
0062 0000 0000 0000 0000 0000 0000 0000 0000 ........
006a 0000 0000 0000 0000 0000 0000 0000 0000 ........
0072 0000 0000 0000 0000 0000 0000 0000 0000 ........
007a 0000 0000 0000 0000 0000 0000 0000 0000 ........
comet> 
#+end_src
何も引数を指定しないと、
現在のプログラムカウンタから 128 ワードのメモリの内容を 16 進数でダンプします。

dump コマンドに引数を指定して、
0x0008 番地からのメモリの内容をダンプします。
#+begin_src casl
comet> dump #0008
0008 007b 0000 0000 0000 0000 0000 0000 0000 {.......
0010 0000 0000 0000 0000 0000 0000 0000 0000 ........
0018 0000 0000 0000 0000 0000 0000 0000 0000 ........
0020 0000 0000 0000 0000 0000 0000 0000 0000 ........
0028 0000 0000 0000 0000 0000 0000 0000 0000 ........
0030 0000 0000 0000 0000 0000 0000 0000 0000 ........
0038 0000 0000 0000 0000 0000 0000 0000 0000 ........
0040 0000 0000 0000 0000 0000 0000 0000 0000 ........
0048 0000 0000 0000 0000 0000 0000 0000 0000 ........
0050 0000 0000 0000 0000 0000 0000 0000 0000 ........
0058 0000 0000 0000 0000 0000 0000 0000 0000 ........
0060 0000 0000 0000 0000 0000 0000 0000 0000 ........
0068 0000 0000 0000 0000 0000 0000 0000 0000 ........
0070 0000 0000 0000 0000 0000 0000 0000 0000 ........
0078 0000 0000 0000 0000 0000 0000 0000 0000 ........
0080 0000 0000 0000 0000 0000 0000 0000 0000 ........
comet>
#+end_src
メモリの 0x0008 番地に格納されている値が 0x007b であることがわかります。

さらにいくつか命令をステップ実行して、
最終的に GR1 レジスタに 123 + 456 = 579 が格納されるようすを見てみましょう。
次に実行される命令は \inst{LAD GR2, #01c8} です。
レジスタ GR2 に 0x01c8 (10 進数で 456) が格納されます。
#+begin_src casl
comet> s
PR  #0004 [ADDA GR1, GR2                      ] SP  #ffff  OF 0  SF 0  ZF 0
GR0 #0000 (     0) GR1 #007b (   123) GR2*#01c8 (   456) GR3 #0000 (     0)
GR4 #0000 (     0) GR5 #0000 (     0) GR6 #0000 (     0) GR7 #0000 (     0)
comet>
#+end_src
レジスタ GR2 の値が 0x01c8 (= 456) に変化したことがわかります (図 [[fig:add-4]])。

#+caption: プログラムカウンタが 0x0004 のときの状態
#+label: fig:add-4
[[./figure/comet/add-4.png]]

次の命令は \inst{ADDA GR1, GR2} です。
レジスタ GR1 に、
レジスタ GR2 の値が加算されます。
GDB と同じように、
直前と同じコマンドを繰り返す場合はリターンキーを押します。
#+begin_src casl
comet> ← エンターキーを押す (step コマンドの繰り返し)
PR  #0005 [ST   GR1, #0008 <V>                ] SP  #ffff  OF 0  SF 0  ZF 0
GR0 #0000 (     0) GR1*#0243 (   579) GR2 #01c8 (   456) GR3 #0000 (     0)
GR4 #0000 (     0) GR5 #0000 (     0) GR6 #0000 (     0) GR7 #0000 (     0)
comet>
#+end_src
レジスタ GR1 の値が 123 + 456 = 579 に変化したことがわかります (図 [[fig:add-5]])。

#+caption: プログラムカウンタが 0x0005 のときの状態
#+label: fig:add-5
[[./figure/comet/add-5.png]]

次の命令は \inst{ST GR1, #0008} です。
メモリの 0x0008 番地にレジスタ GR1 の値が格納されます。
先ほど dump コマンドで 0x0008 番地の内容を確認したときは
#+begin_src casl
0008 007b 0000 0000 0000 0000 0000 0000 0000 {.......
#+end_src
のように 0x007b が格納されていました。
1 命令ステップ実行して、
0x0008 番地のメモリの内容を再度ダンプしてみます。
#+begin_src casl
comet> ← エンターキーを押す (step コマンドの繰り返し)
PR  #0007 [RET                                ] SP  #ffff  OF 0  SF 0  ZF 0
GR0 #0000 (     0) GR1 #0243 (   579) GR2 #01c8 (   456) GR3 #0000 (     0)
GR4 #0000 (     0) GR5 #0000 (     0) GR6 #0000 (     0) GR7 #0000 (     0)
comet> du #0008
0008 0243 0000 0000 0000 0000 0000 0000 0000 C.......
0010 0000 0000 0000 0000 0000 0000 0000 0000 ........
0018 0000 0000 0000 0000 0000 0000 0000 0000 ........
0020 0000 0000 0000 0000 0000 0000 0000 0000 ........
0028 0000 0000 0000 0000 0000 0000 0000 0000 ........
0030 0000 0000 0000 0000 0000 0000 0000 0000 ........
0038 0000 0000 0000 0000 0000 0000 0000 0000 ........
0040 0000 0000 0000 0000 0000 0000 0000 0000 ........
0048 0000 0000 0000 0000 0000 0000 0000 0000 ........
0050 0000 0000 0000 0000 0000 0000 0000 0000 ........
0058 0000 0000 0000 0000 0000 0000 0000 0000 ........
0060 0000 0000 0000 0000 0000 0000 0000 0000 ........
0068 0000 0000 0000 0000 0000 0000 0000 0000 ........
0070 0000 0000 0000 0000 0000 0000 0000 0000 ........
0078 0000 0000 0000 0000 0000 0000 0000 0000 ........
0080 0000 0000 0000 0000 0000 0000 0000 0000 ........
comet>
#+end_src
メモリの 0x0008 番地の値が 0x007b から 0x0243 (= 579) に変化したことがわかります。

最後に quit コマンド (省略形は q) で COMET II シミュレータを終了します。
#+begin_src casl
comet> q
#+end_src

IA-32 アーキテクチャと COMET II は、
まったくといっていいほど複雑さが異なりますが、
どちらもフォン・ノイマンアーキテクチャのコンピュータです。
レジスタも、
命令セットも、
オペコードも、
メモリのアドレッシングモードも、
何もかもが違いますが、
フォン・ノイマンアーキテクチャのコンピュータとしての本質はまったく同じであることがわかります。

** CASL II
<<sec:comet/casl>>

前述のように、
CASL II はアセンブラではなく、
*アセンブリ言語の仕様* です。

ここでは、
GNU アセンブラ (GAS) の文法 ([[sec:gas/syntax]] 節) と対比する形で、
CASL II の文法を説明します。

*** スペースとタブ

スペースやタブの扱いは GAS とほぼ同じです。

CASL II では、
スペース (space) を *間隔文字* と呼んでいます。
GAS と同じように、
スペースの並びを単一の空白文字として扱います。
GAS と同じように、
アセンブリ言語のプログラム中のインデントには特別の意味はありません (単に読みやすさのためのものです)。

CASL II の仕様ではタブの扱いは明記されていません。
このため、
CASL II アセンブラの実装によってはタブが使用できないかもしれません。
CASI II アセンブラである ~casl~ プログラムは、
タブも空白文字として扱います。

CASL II では、
以下のように、
命令のオペランドは空白を空けずにカンマ (~,~) で区切って記述します。
#+begin_src casl
	LD	GR1,#0000,GR2
	DC	123,456,-1,'ABC'
#+end_src

#+begin_note
CASL II の仕様 \cite{IPA19:COMET} では、
「複数のオペランドをカンマで区切る場合に、
間に空白を入れてはいけない」とは明記されていません。
ただし後述するように、
カンマの前後に空白を許すと、
CASL II で規定されているコメントが実現できません (コメントかオペランドかを判別できません)。
このため、
オペランドの間に空白を入れないことを想定していると考えられます (文献 \cite{IPA19:COMET} のサンプルプログラムにも、
カンマの前後に空白はありません)。
#+end_note

一方、
~casl~ プログラムでは、
以下のように命令のオペランドを区切るカンマの前後にスペースを書くことができます。
#+begin_src casl
	LD	GR1, #0000, GR2
	DC	123, 456, -1, 'ABC'
#+end_src
スペースは複数あってもかまいませんし、
省略することも可能です。

*** コメント

CASL II は行単位のコメントのみをサポートしています。
コメント開始文字はセミコロン (~;~) であり、
コメント開始文字から行末までがコメントになります。
コメントの記述例を以下に示します。

#+caption: comet/comment.cas
#+label: fig:comet/comment.cas
#+include: "code/comet/comment.cas" src casl

コメントには処理系が許す任意の文字を記述できます。
漢字などのマルチバイト文字も (処理系が許すのであれば) 記述できます。

なお、
CASL II の仕様では、
オペランドを取る命令がある行で、
最後のオペランドのあとに書かれたものはコメントになると定められています。
例を示します。

#+caption: comet/comment-wo-delim.txt
#+label: fig:comet/comment-wo-delim.txt
#+include: "code/comet/comment-wo-delim.txt" src casl

なお、
~casl~ プログラムではコメント行のセミコロン (~;~) は省略できません。
これは、
オペランドの区切りにスペースを許容しているためです (コメント開始文字 (~;~) がなければ、
オペランドの末尾とコメントの開始を区別できない (ケースがある) ためです)。

*** シンボル

GAS とは異なり、
利用できる文字種や長さにかなりの制限があります。
なお、
CASL II ではラベル以外のシンボルは登場しません。
シンボルはすべて (メモリのアドレスを表す) ラベルです。

まず、
COMET II では、
シンボルに利用できる文字は、
英字 (大文字のみ) と数字のみです。
シンボルを数字で始めることはできません。
そして、
シンボルの長さは 1〜8 文字でなければなりません。
また、
GR0〜GR7 は予約語のため使用できず、
GAS のような局所ラベルもありませんし、
ラベルにマルチバイト文字を使うこともできません。

*** 文

他のアセンブリ言語と同じように、
CASL II のプログラムも *文 (statement)* で構成されます。
改行 (newline) で区切られた、
各行が CASL II の文に相当します。
CASL II では 1 行中に複数の文を記述できないため、
CASL II の仕様 \cite{IPA19:COMET} では文のことを *行* と呼んでいます。

*** ラベル

CASL II では、
命令のある行にのみ *ラベル* を指定できます。
空白行やコメントにはラベルを指定できません。

ラベルは必ず行頭から始まる必要があります。
行の先頭に空白があれば、
それはラベルとは見なされません。

ラベルの例を示します (図 [[fig:comet/label.cas]])。

#+caption: comet/label.cas
#+label: fig:comet/label.cas
#+include: "code/comet/label.cas" src casl

疑似命令 START がある行のラベルは必須です。
逆に、
疑似命令 END がある行にラベルは指定できません。

*** 局所ラベル

CASL II では局所ラベルは使えません。
すべてのラベルは大域的 (グローバル) です。

*** 命令

それぞれの文 (または行) には、
アセンブリ言語の命令か、
CASL II の疑似命令やマクロ命令を記述できます。

*疑似命令* (CASL II では *アセンブラ命令* と呼ばれています) は以下の 4 つです。
| START | プログラムの先頭を定義 |
| END   | プログラムの末尾を明示 |
| DC    | 定数を定義             |
| DS    | 領域を確保             |

START 命令と END 命令は、
アセンブリ言語プログラムの開始と終了を示す疑似命令です。

DC 命令は定数を定義するための疑似命令です。
GAS における疑似命令 .word と同じように、
指定されたオペランドをメモリ中に確保します。
CASL II では、
DC 命令のオペランドには、
カンマで区切って複数の定数が指定できます。

疑似命令のサンプルを示します (図 [[fig:comet/pseudo.cas]])。

#+caption: comet/pseudo.cas
#+label: fig:comet/pseudo.cas
#+include: "code/comet/pseudo.cas" src casl

*** 定数

アセンブリ言語の命令や疑似命令のオペランドには、
レジスタ、
ラベル、
数値定数、
文字定数が記述できます。
オペランドに何が指定できるかは、
それぞれの命令によります。

数値定数には 10 進定数と 16 進定数があります。

*10 進定数* には整数を指定できます。
COMET II ではデータの大きさはすべて 1 ワード (16 ビット) です。
定数には 16 ビットを超える値も指定できますが、
アセンブラによって下位 16 ビットのみが格納されます。
10 進定数の記述例を示します (表 [[tab:comet/dec-const]])。

#+caption: 10 進定数の記述例
#+label: tab:comet/dec-const
|  記述例 | 記述の可否                                                       |
|---------+------------------------------------------------------------------|
|       0 | ○                                                               |
|     123 | ○                                                               |
|   32767 | ○                                                               |
|   65535 | ○                                                               |
| 1234567 | ○ (下位 16 ビットのみ格納され、0x61a7 (= 24999) として扱われる) |
|   12.34 | × (小数は記述できない)                                          |
|    10e4 | × (指数表記は記述できない)                                      |
|    +123 | ? (CASL II の仕様では未定義 (利用できるかは処理系による))        |

*16 進定数* には 16 進数の整数が指定できます。
CASL II では、
先頭に番号記号 (~#~) を付けた、
必ず 4 桁の 16 進数として表記します。
16 進数の表記には、
数字の 0〜9 と英大文字の A〜F を使います。
英小文字の a〜F は使用できません。
16 進定数の例を示します (表 [[tab:comet/hex-const]])。

#+caption: 16 進定数の記述例
#+label: tab:comet/hex-const
| 記述例 | 記述の可否                        |
|--------+-----------------------------------|
| #0000  | ○                                |
| #1234  | ○                                |
| #1F80  | ○                                |
| -#1F80 | × (符号は指定できない)           |
| #0     | × (必ず 4 桁が必用)              |
| #1F    | × (必ず 4 桁が必用)              |
| #1f80  | × (小文字の a〜f は使用できない) |
| 1234H  | × (#hhhh の形式のみ可能)         |
| 0x1234 | × (#hhhh の形式のみ可能)         |

また、
定数の記述を容易にするための仕組みとして *リテラル* が利用できます。
CASL II では、
#+begin_src asm
	LD	GR1, 123
#+end_src
と書くと、
レジスタ GR1 に 123 が格納されるのではなく、
レジスタ GR1 に、
メモリの 123 番地に格納されている値が読み込まれてしまいます。
CASL II では、
オペランドに即値が指定できないため何かと不便です。

#+begin_note
「LD 命令の第 2 オペランドに即値を書いているつもりで、
実はメモリのアドレスを書いている」というのは、
CASL II のプログラミングで最も頻繁に起こる間違いだと思います。
筆者も、
本書の執筆中に、
何度も何度も間違えました。

あまりにも何度も間違えるので、
~casl~ アセンブラには、
以下の条件を満たすときに警告を出す機能を実装してあります。
- LD 命令の第 2 オペランドにメモリアドレスを指定している
- そのメモリアドレスに対応するラベルが定義されていない

例えば、
#+begin_src asm
	LD	GR1, 123
#+end_src
をアセンブルすると以下のような警告を表示します。
#+begin_src raw
foo.cas:1: warning: LD must take address, rather than immediate
->      LD GR1, 123
#+end_src
#+end_note

その不便さを軽減するためにリテラルが利用できます (図 [[fig:comet/literal.cas]])。

#+caption: comet/literal.cas
#+label: fig:comet/literal.cas
#+include: "code/comet/literal.cas" src casl

例えば、
#+begin_src asm
	LD	GR1, =-123
#+end_src
のように書くと、
アセンブラは以下のように処理します。
- -123 という定数をメモリ上に確保する。具体的にはアセンブラの疑似命令
  \inst{DC -123} をプログラムの末尾に追加する。
- ~=-123~ と記述したオペランドには、DC 命令によって確保したメモリのア
  ドレスに置き換える。

リテラルが ~casl~ アセンブラによってどのような機械語に変換されるかの例を見てみましょう。
#+begin_src casl
   3 0002 1010          LD      GR1, =-123      ; リテラルを使って同じことを行う
   3      0010
#+end_src
~=-123~ に相当するのが 0010 (16 進数の 0x0010) です。
LD 命令の第 2 オペランドがアドレス 0x0010 になっています。

0x0010 番地に何が生成されたかを見てみます。
#+begin_src casl
  14 0010 ff85          END
  14      0002
  14      ffff
#+end_src
0x0010 番地には 0xff85 (= -123) が生成されていることがわかります。

*** セクション

COMET II にはメモリ保護機能がありません。
CASL II にもプログラム領域やデータ領域といったセクションやセグメントの概念はありません。

*** 式

一般的なアセンブリ言語では、
数値定数が期待されている箇所には式を記述できます。
例えば、
GNU アセンブラ (GAS) では、
#+begin_src asm
	movl	$(123 + 456), %eax
#+end_src
のように即値を指定するオペランドに式を記述できます。
アセンブリ言語中に記述された式は、
アセンブラによってアセンブル時に評価され、
評価された結果の値に応じて機械語のプログラムが生成されます。

しかし、
CASL II ではこのような式は一切記述できません。

** COMET II のアーキテクチャ
<<sec:comet/comet>>

*** 概要

ここで、
COMET II のアーキテクチャを説明しましょう (表 [[tab:comet/isa]])。

#+caption: COMET II の概要
#+label: tab:comet/isa
| 命令セットの種別     | CISC?                                 |
| レジスタの大きさ     | 16 ビット                             |
| 汎用レジスタ数       | 8                                     |
| プログラムカウンタ   | PR レジスタ                           |
| スタックポインタ     | SP レジスタ                           |
| 特殊レジスタ         | なし                                  |
| フラグレジスタ       | OF フラグ、SF フラグ、ZF フラグ       |
| 命令数               | 28                                    |
| 命令語の大きさ       | 1〜2 ワード                           |
| データサイズ         | 16 ビット (ワード)                    |
| 浮動小数点数演算命令 | なし                                  |
| SIMD 命令            | なし                                  |
| メモリアドレス       | 16 ビット (64 K ワード)               |
| エンディアンネス     | なし (メモリの単位がワードであるため) |
| メモリ保護           | なし                                  |
| ハードウェア割り込み | なし                                  |
| ソフトウェア割り込み | なし                                  |

(必ずしも正確な表現ではありませんが) COMET II の特徴を大ざっぱに説明すれば「16 ビットの CPU と、
64 K ワード (128 K バイト) のメモリを搭載したコンピュータ」です。

COMET II の大きな特徴は、
レジスタも、
メモリも、
すべて 16 ビットのワード (word) 単位であるという点です (図 [[fig:comet/memory]])。
レジスタやメモリへのアクセスはすべて 16 ビット (ワード) 単位で行われます。
すべてのレジスタの大きさもすべて 16 ビットですし、
メモリ空間の大きさも 64 K ワード (= 128 K バイト) です。
アドレスの単位も、
8 ビット単位の「バイト」ではなく、
16 ビット単位の「ワード」です。

#+caption: COMET II のメモリ
#+label: fig:comet/memory
[[./figure/comet/memory.png]]

メモリの大きさは 64 K ワードなので、
メモリの番地は 0〜65 535 の値を取ります。
ここで、
アドレスの単位が「バイト」ではなく「ワード」であることに注意しましょう。
そのため例えば、
メモリの 0 番地には、
8 ビットではなく 16 ビットのデータが格納され、
同様に、
メモリの 1 番地にも 16 ビットのデータが格納されます。
多くのコンピュータでは、
メモリアドレスの単位はバイトですが、
COMET II ではワード (16 ビット) であることに注意してください。

このため、
COMET II において、
もしメモリの先頭の 1 バイトのみを書き換えたいのであれば、
1. メモリの先頭の 1 ワード (16 ビット) をレジスタに読み込む
2. レジスタの上位または下位 8 ビットを書き換える
3. 書き換えたレジスタの値をメモリの先頭に書き込む
という処理を行う必要があります。

このため通常は、
COMET II ではバイト単位の処理を行いません。
すべてワード (16 ビット) 単位で扱います。
例えば、
=ABC= という文字列の ASCII コードは 0x41、
0x42、
0x43 です。
普通のコンピュータでは、
これらの 3 文字をメモリに格納するときは、
0x41、
0x42、
0x43 の 3 バイトをこのままメモリに格納します。
ただし COMET II では、
すべてがワード単位なので、
0x0041、
0x0042、
0x0043 の 3 ワードをメモリに格納します (図 [[fig:comet/memory]])。
つまり、
「3 バイト (24 ビット) を格納するために 3 ワード (48 ビット) を使用する」という贅沢な使い方をするのです。

メモリへのアクセスはすべてワード単位であるため、
エンディアンネスも無関係です。
1 ワードのデータを、
バイト単位でメモリに配置しない (できない) ため、
どちらが上位バイトで、
どちらが下位バイトかという問題が生じません。

*** レジスタ
<<sec:comet-registers>>

COMET II のレジスタの一覧を図 [[fig:comet/regs]] に示します。

#+caption: COMET II のレジスタ
#+label: fig:comet/regs
#+attr_latex: :width \columnwidth
[[./figure/comet/regs.png]]

COMET II は、
8 個の *汎用レジスタ* (すべて 16 ビット) と、
*プログラムカウンタ* および *スタックポインタ* のためのレジスタ (どちらも 16 ビット)、
*フラグレジスタ* (3 ビット) を持っています。

**** 汎用レジスタ

GR0〜GR7 は *汎用レジスタ (general-purpose register)* です。
レジスタとメモリ間のデータ転送や、
ALU による算術演算・論理演算などに使用します。
16 ビットの符号なし整数もしくは符号付き整数を格納します。

汎用レジスタ GR0〜GR7 は、
(GR0 がインデックスレジスタ (後述します) として使用できないことを除き) すべて対等です。
COMET II では、
すべての汎用レジスタに対して、
算術演算や論理演算を同じように行うことができます。

これは、例えば
#+begin_src casl
	LAD	GR1, 123
	ST	GR1, TEMP
TEMP	DS	1
#+end_src
のようにレジスタ GR1 が使用できるのであれば、
同じように他の汎用レジスタに対して
#+begin_src casl
	LAD	GR3, 123
	ST	GR3, TEMP
TEMP	DS	1
#+end_src
や
#+begin_src casl
	LAD	GR3, 123
	ST	GR5, TEMP
TEMP	DS	1
#+end_src
などが実行できることを意味します。

IA-32 アーキテクチャではレジスタ EAX がアキュムレータとして特別扱いされていました。
また、
レジスタ ECX がカウンタとして特定の役割を持っていました。
COMET II ではこういった「レジスタごとの役割」というものがありません。

なお、
COMET II の前身の COMET では汎用レジスタは GR0〜GR4 の 5 個でしたが、
COMET II では、
汎用レジスタが GR0〜GR7 の 8 個に増えています。

**** プログラムカウンタ、スタックポインタ

*PR (Program Register) レジスタ* および *SP (Stack Pointer) レジスタ* は、
どちらも特定の用途のためのレジスタです。

PR レジスタは、
いわゆる *プログラムカウンタ* で、
次に実行すべき命令が格納されているメモリのアドレスを保持しています。
COMET II では、
レジスタもメモリもすべてワード単位なので、
当然、
PR レジスタの大きさも 16 ビットです。

SP レジスタは、
いわゆる *スタックポインタ* で、
メモリ上に確保されたスタックの最上段のアドレスを保持しています。
PR レジスタと同様に、
SP レジスタの大きさも 16 ビットです。

PR はプログラムカウンタとして、
SP はスタックポインタとしてのみ使用されます。
COMET II では、
PR レジスタや SP レジスタを直接操作することはできません。
何らかの命令を実行すると、
その結果に応じて PR レジスタや SP レジスタの値が自動的に変化します。

このため、
例えば
#+begin_src casl
	LAD	PR, #1000	; 書けない!
	LAD	SP, #7FFF	; 書けない!
#+end_src
などの操作で PR レジスタや SP レジスタの値を直接変更することはできません。

**** フラグレジスタ

*フラグレジスタ* は、
OF (Overflow Flag) フラグ、
SF (Sign Flag) フラグ、
ZF (Zero Flag) フラグと呼ばれる 3 ビットのフラグによって構成されるレジスタです。
演算命令などの実行によって、
それぞれのフラグの値が設定されます。

SF フラグと ZF フラグは、
いわゆる *符号フラグ* と *ゼロフラグ* であり、
IA-32 アーキテクチャの SF フラグ、
ZF フラグ ([[sec:x86regs/register]] 節) と基本的に同じです。

*SF フラグ (符号フラグ)* は、
直前の演算結果が負であった場合にセットされます (1 になります)。
直前の演算結果が負でなかった場合 (正もしくはゼロの場合) にはリセットされます (0 になります)。

*ZF フラグ (ゼロフラグ)* は、
直前の演算結果がゼロであった場合にセットされます (1 になります)。
直前の演算結果がゼロでなかった場合にはリセットされます (0 になります)。

*OF (オーバーフローフラグ)* は、
IA-32 アーキテクチャの CF フラグと OF フラグを兼ねたような役割を持ち、
直前の演算結果において *桁あふれ* が起きた場合にセットされます (1 になります)。
直前の演算結果において桁あふれが起きなかった場合にはリセットされます (0 になります)。

例えば、
IA-32 アーキテクチャの ADD 命令は、
符号なし整数にも符号付き整数にも使えます。
IA-32 アーキテクチャでは、
ADD 命令のオペランドを符号なし整数と見なしたときに、
桁あふれが発生すれば CF フラグをセットします。
ADD 命令のオペランドを符号付き整数と見なしたときに、
オーバーフローが発生すれば OF フラグをセットします。

一方、
COMET II では、
符号なし整数と符号付き整数に、
それぞれ異なる命令を使います。
例えば、
オペランドが符号なし整数のときには ADDL 命令を使います。
ADDL 命令は、
桁あふれが発生すれば OF フラグをセットします。
一方、
オペランドが符号付き整数の時には ADDA 命令を使います。
ADDA 命令は、
オーバーフローが発生すれば OF フラグをセットします

フラグレジスタの基本的な考え方は上記の通りです。
ただし、
COMET II も、
他のコンピュータと同じように、
ある命令の実行時に、
どのフラグが変化するかはその命令によります。
それぞれの命令の実行により、
どのフラグレジスタがどのように変化するか (もしくは変化しないか) は、
命令ごとに定められています。
したがって、
フラグレジスタの挙動を正確に理解するためには、
COMET II の仕様を確認する必要があります。

例えば COMET II の場合、
#+begin_src casl
	LD	GR1, MINUS1
MINUS1	DC	-1
#+end_src
によって、
レジスタ GR1 に -1 (2 の補数表現で 0xffff) が格納されます (ラベル ~MINUS1~ が差す番地に格納されている値がレジスタ GR1 にコピーされます)。
このとき、
レジスタ GR1 の値が負であるため SF フラグは 1 になり、
ZF フラグは (ゼロではないため) 0 になります。
また、
OF フラグはレジスタ GR1 の値によらず常に 0 になります。

一方、
命令のオペランドにアドレスとして -1 を指定して、
#+begin_src casl
	LAD	GR1, -1
#+end_src
とすることでも、
レジスタ GR1 に -1 (2 の補数表現で 0xffff) を格納できます。
ただし、
この場合には、
SF フラグ、
ZF フラグ、
OF フラグ、
いずれも変化しません (直前の値がそのまま保持されます)。

「レジスタ GR1 の値の変化は同じなのに、
なぜ LD 命令ではフラグレジスタが変化し、
なぜ LAD 命令ではフラグレジスタが変化しないのか?」
と疑問を持つかもしれませんが、
これに対する回答は、
「COMET II の仕様でそう決まっているから」という (つまらない) ものです。
LD 命令でフラグレジスタが変化し、
LAD 命令でフラグレジスタが変化しないことに必然性はありません。
単に (COMET II の仕様を決めた人が) そう決めたからにすぎません。

COMET II に限らず、
一般形なコンピュータでは、
フラグレジスタは、
ほとんどの場合、
「普通に考えたら、
そう変化するよね」という常識的な変化をします。
ただし、
一部の命令では期待に反する挙動をします。
したがって、
フラグレジスタを扱う場合は、
そのつど、
それぞれの命令セットの仕様を確認する必要があります。

*** COMET と COMET II の違い
<<sec:comet-vs-cometII>>

COMET II は、
その前身である COMET を拡張した内容になっています。
COMET の仕様が策定されたのが 1986 年で、
COMET II の仕様が策定されたのが 2001 年です。

COMET II は、
前身である COMET からそれほど大きく変化していませんが、
COMET II が COMET から変化した点で、
特徴的なものをいくつか紹介しましょう。

**** 「プログラムカウンタ」のレジスタ名

COMET ではプログラムカウンタは「PC レジスタ」でしたが、
COMET II では「PR レジスタ」と呼ばれています (名前が変更になっています)。
レジスタの名称が変更になっただけなので、
アセンブリ言語のプログラムを作成する上では特に影響はありません。

**** スタックポインタの追加、汎用レジスタの増加

COMET は 5 個の汎用レジスタ GR0〜GR4 を持っていました。
しかし、
レジスタ GR4 はスタックポインタとして使われていたため、
事実上、
汎用レジスタとして使えるのは GR0〜GR3 の 4 個だけでした。

COMET II ではスタックポインタのためのレジスタ (SP レジスタ) が導入され、
汎用レジスタも GR0〜GR7 の 8 個に増えました。
COMET では GR4 が汎用レジスタとして事実上使えなかったので、
COMET II では使用できる汎用レジスタ数が 4 から 8 へと倍増しました。
汎用レジスタの数が増えたため、
アセンブリ言語のプログラムを作成する上での自由度が高まり、
COMET のときのような、
「汎用レジスタのやりくりに困る」ことが減りました。

**** OF (オーバーフロー) フラグの追加

COMET では、
フラグレジスタは 2 ビット (SF と ZF のみ) でした。
COMET II では、
フラグレジスタに OF (オーバーフローフラグ) が追加されました。
演算による桁あふれを判定できるフラグが追加されたので、
算術演算を行うプログラムや、
値のオーバーフローをチェックするプログラムなどが書きやすくなりました。

**** 符号なし整数のための論理演算命令が追加

符号なし整数を扱うための論理演算命令 (論理加算命令 ADDL と論理減算命令 SUBL) が追加されました。
これらの命令では、
値を符号なし整数として扱います。
「論理加算」や「論理減算」とは耳慣れない言葉ですが、
要は「符号なし整数の加算」と「符号なし整数の減算」です。
これにともない、
従来の加算命令 (ADD) および減算命令 (SUB) は、
それぞれ ADDA および SUBA へと名前が変更になりました。

算術演算 (ADDA、
SUBA) も、
論理演算 (ADDL、
SUBL) もほとんど同じように動作します。
これは、
2 の補数表現には、
「2 の補数によって減算が加算になる」という美しい性質があるためです ([[sec:number/binary]] 節)。

算術演算でも論理演算でも、
演算結果は同じなのですが、
「途中の計算でオーバーフローが起こったかどうか」の判定が異なります。

ここで、
算術演算と論理演算の違いを例で説明しましょう。
例として、
「0x0005 + 0xffff」という演算 (加算) を考えます。
これらの値が符号付き整数であれば、
「0x0005 (= 5) + 0xfffc (= -4)」となり、
計算結果は 0x0001 (= 1) になります。
「5 + (-4) = 1」という演算なので、
オーバーフローは発生しません (OF フラグが 0 になります)。

一方、
値が符号なし整数であれば、
「0x0005 (= 5) + 0xfffc (= 65532)」となり、
計算結果は 0x10001 (= 65537) となります。
レジスタの大きさが 16 ビットしかないため、
最上位のビットが捨てられて 0x0001 (= 1) となります。
このため、
オーバーフローが発生しています (OF フラグが 1 になります)。

このような論理演算命令が追加されたことで、
符号なし整数を扱うプログラムを書きやすくなりました。

** COMET II 命令セット (概要、アドレッシングモード)
<<sec:comet/inst>>

*** 命令の分類

[[sec:x86regs/category]] 節で述べたように、
インテルの IA-32 アーキテクチャには 500 を超える命令がありました。
一方、
COMET II にはたったの 28 個の命令しかありません。

COMET II の 28 個の命令を、
IA-32 アーキテクチャの命令と同じように分類すると以下のようになります (該当する命令がない箇所は「なし」と記載しています)。

- データ転送命令
  - 汎用データ転送命令 ★: LD, ST, LAD
  - 交換命令: なし
  - スタック操作命令 ★: PUSH, POP
  - 型変換命令: なし
- 2 進算術命令
  - 加算命令と減算命令 ★: ADDA, ADDL, SUBA, SUBL
  - インクリメント命令とデクリメント命令 ★: なし
  - 比較命令と符号変更命令 ★: CPA, CPL
  - 乗算命令と除算命令 ★: なし
- 10 進算術命令
  -パックド BCD 調整命令: なし
  - アンパックド BCD 調整命令: なし
- 論理演算命令 ★: AND, OR, XOR
- シフト命令とローテート命令
  - ビットのシフト命令 ★: SLA, SLL, SRA, SRL
  - ビットのダブルシフト命令: なし
  - ビットのローテート命令: なし
- ビット命令とバイト命令
  - ビットテストおよび変更命令: なし
  - ビットスキャン命令: なし
  - 条件付きバイトセット命令: なし
  - テスト命令: なし
- 制御転送命令
  - 無条件転送命令 ★: JUMP, CALL, RET
  - 条件付き転送命令 ★: JPL, JMI, JNZ, JZE, JOV
  - ソフトウェア割り込み命令: SVC
- ストリング命令: なし
- I/O 命令: なし
- ENTER 命令と LEAVE 命令: なし
- フラグ制御命令
  - キャリーフラグおよび方向フラグ命令: なし
  - EFLAGS 転送命令: なし
  - 割り込みフラグ命令: なし
- セグメント・レジスタ命令
  - セグメント・レジスタ・ロードおよびストア命令: なし
  - far 制御転送命令: なし
  - ソフトウェア割り込み命令: なし
  - far ポインタロード命令: なし
- その他の命令
  - アドレス計算命令: なし
  - テーブル・ルックアップ命令: なし
  - プロセッサ識別命令: なし
  - ノー・オペレーション命令と未定義命令 ★: NOP

多くの箇所が「なし」となっています。
「なし」となっている箇所を削除すると以下が残ります。

- データ転送命令
  - 汎用データ転送命令 ★: LD, ST, LAD
  - スタック操作命令 ★: PUSH, POP
- 2 進算術命令
  - 加算命令と減算命令 ★: ADDA, ADDL, SUBA, SUBL
  - 比較命令と符号変更命令 ★: CPA, CPL
- 論理演算命令 ★: AND, OR, XOR
- シフト命令とローテート命令
  - ビットのシフト命令 ★: SLA, SLL, SRA, SRL
- 制御転送命令
  - 無条件転送命令 ★: JUMP, CALL, RET
  - 条件付き転送命令 ★: JPL, JMI, JNZ, JZE, JOV
  - ソフトウェア割り込み命令: SVC
- その他の命令
  - ノー・オペレーション命令と未定義命令 ★: NOP

COMET II の命令数は 28 しかありませんが、
重要な命令 ([[sec:x86regs/category]] 節において★を付けたカテゴリの命令) はほとんど揃っていることがわかります。
★を付けたカテゴリで、
COMET II に対応する命令が存在しないのは

  - 乗算命令と除算命令 ★: なし

だけです。
IA-32 アーキテクチャでも機械語プログラムの 99.9% は 34 種類の命令が占めていました ([[sec:x86regs/ranking]] 節)。
COMET II の命令数は少ないですが、
一般的なコンピュータとして必須の命令は大体揃っています。

*** アドレス指定モード

COMET II の命令は、
オペランドを 0〜3 個取ります。
COMET II は非常に単純なアーキテクチャであり、
オペランドの指定方法も単純です。

COMET II のオペランドは、
以下のいずれかの形式を取ります。
命令のニーモニックを op、
汎用レジスタを \r{i}、
\r{j} (GR0〜GR7 のいずれか)、
メモリアドレスを $m$ と表記します。

| オペランドなし                                 | op                   |
| レジスタ 1 個                                  | op \r{i}             |
| レジスタ 2 個                                  | op \r{i}, \r{j}      |
| レジスタとメモリアドレス                       | op \r{i}, $m$        |
| レジスタ、メモリアドレス、インデックスレジスタ | op \r{i}, $m$, \r{j} |

IA-32 アーキテクチャの説明ではオペランド $m$ は間接メモリ参照も可能な「メモリロケーション」でしたが、
COMET II のオペランド $m$ は単なるメモリアドレスです。

IA-32 アーキテクチャを学んだあとで上のオペランド形式を見ると、
「あれ、
オペランドに定数を指定する即値がないな?」
と思うかもしれません。
基本的にそのとおりです。
COMET II では即値を使った計算がほとんどできません。
一部、
オペランドに定数を記述できる命令もありますが、
そういった命令は、
後ほど説明するようにメモリアドレス $m$ を即値のように代用します。

COMET II のオペランドの形式をそれぞれ説明します。

- オペランドなし: op

  RET 命令や NOP 命令など、
  一部の命令はオペランドを取りません (オペランドを記述するとエラーになります)。
  例を示します。
  #+begin_src casl
  	RET
  #+end_src

- レジスタ 1 個: op \r{i}

  POP 命令のみ、
  オペランドを 1 つだけ取ります。
  オペランドに指定できるのは汎用レジスタのみです。
  メモリアドレスを指定するとエラーになります。
  例を示します。
  #+begin_src casl
  	POP	GR1
  #+end_src

- レジスタ 2 個: op \r{i}, \r{j}

  LD 命令と、
  算術・論理演算命令、
  比較演算命令はオペランドを 2 個 (宛先オペランドと出所オペランド) 取ります。
  宛先オペランドと出所オペランドにはレジスタしか指定できません。
  例を示します。
  #+begin_src casl
  	ADD	GR1, GR2
  #+end_src
  CASL II は AT&T 構文よりはインテル構文に似たアセンブリ言語です。
  2 つのオペランドは、
  「宛先オペランド、
  出所オペランド」の順に並びます。

COMET II の多くの命令のオペランドは、
以下のどちらかの形式を取ります。

- レジスタとメモリアドレス: op \r{i}, $m$

  宛先オペランドに汎用レジスタ \r{i} を指定し、
  出所オペランドにメモリアドレス $m$ を指定する形式です。
  例えば、
  #+begin_src casl
  	LD	GR1, #1234
  #+end_src
  は 0x1234 番地に格納されている 1 ワード (16 ビット) の値をレジスタ GR1 に  読み込みます。
  一部の命令では、
  メモリアドレス $m$ を即値として扱います。
  例えば、
  #+begin_src casl
  	LAD	GR1, #1234
  #+end_src
  ではレジスタ GR1 に 0x1234 という値そのものを格納します。
  レジスタ GR1 に 0x1234 番地に格納されている値を格納するのでは *ない* ことに注意してください。

  また、
  SLL 命令は左シフト命令ですが、
  #+begin_src casl
  	SLL	GR1, 1
  #+end_src
  はレジスタ GR1 の値を左に 1 ビットだけシフトします。
  レジスタ GR1 の値を、

  実際には、
  このような 2 オペランド形式は、
  次の 3 オペランド形式におけるインデックスレジスタ \r{j} を省略したものです。

- レジスタ、メモリアドレス、インデックスレジスタ: op \r{i}, $m$, \r{j}

  この形式では、
  宛先オペランドは「レジスタ \r{i}」で、
  出所オペランドは実効アドレスを表す「メモリアドレス $m$ とインデックスレジスタ \r{j}」です。
  出所オペランドは $m + \r{j}$ で表される *実効アドレス (effective address)* を意味します。

  「実効アドレス」という言葉は耳慣れないかもしれませんが、
  effective address の日本語訳です。
  ここでの effective は、
  「(名目的ではなく) 実際上の、
  事実上の」といった意味です。
  実効アドレスとは、
  「そこに書かれたとおりのアドレスではなく、
  実際に使われるアドレス」  というニュアンスです。

  例えば
  #+begin_src casl
  	LAD	GR2, 4
  	LD	GR1, #1000, GR2
  #+end_src
  の LD 命令では、
  実効アドレスは 0x1000 + GR2 = 0x1004 になります。
  LD 命令によって、
  0x1004 番地の値がレジスタ GR1 に読み込まれます。
  これにより、
  例えば、
  0x1000 番地から格納されている配列の 4 番目の値にアクセスすることができます。
  実効アドレスを指定するレジスタ \r{j} は *インデックスレジスタ (index register)* と  呼ばれます。
  インデックスレジスタには、
  GR0 以外のすべての汎用レジスタが指定できます。

  したがって、
  例えば、
  レジスタ GR1 に、
  メモリの 0x1234 番地に格納されている値を読み込むには、
  以下のようないくつかの方法があります。

  1. 汎用レジスタの値が差すメモリからの読み込み
    #+begin_src casl
    	LAD	GR2, #1234
    	LD	GR1, GR2
    #+end_src
    まず、
    レジスタ GR2 にメモリのアドレスを格納し、
    レジスタ GR2 の値が差すメモリの値をレジスタ GR1 に読み込むという方法です。
  
  2. 実効アドレスが差すメモリの値の読み込み (インデックスレジスタなし)
    #+begin_src casl
    	LD	GR1, #1234
    #+end_src
    0x1234 番地の値をレジスタ GR1 に読み込むという方法です。
  
  3. 実効アドレスが差すメモリの値の読み込み (インデックスレジスタあり)
    #+begin_src casl
    	LAD	GR2, #1234
    	LD	GR1, 0, GR2
    #+end_src
    実効アドレスを「0 + レジスタ GR2 の値」として指定しています。
    レジスタ GR2 の値が差すメモリの値がレジスタ GR1 に読み込まれます。
  
  4. 実効アドレスが差すメモリの値の読み込み (インデックスレジスタあり)
    #+begin_src casl
    	LAD	GR2, 0
    	LD	GR1, #1234, GR2
    #+end_src
    2 番目の方法にインデックスレジスタ GR2 を追加した形式です。
    レジスタ GR2 の値がゼロなので、
    結局、
    0x1234 番地の値がレジスタ GR1 に読み込まれます。
  
「0x1234 番地の値をレジスタに読み込む」だけなら、
普通は 1 番目または 2 番目のように記述しますが、
3 番目や 4 番目のようにも記述できることは頭に入れておいてください。

ここまでの説明から、
COMET II には以下の 3 種類のアドレス指定モードがあることがわかります。
| レジスタ参照   | レジスタの値が指すメモリにアクセスする                                  |
| 絶対メモリ参照 | メモリアドレスが指すメモリにアクセスする                                |
| 間接メモリ参照 | 「メモリアドレス + インデックスレジスタの値」が指すメモリにアクセスする |

上述のように、
COMET II はオペランドに定数を指定する即値を使えません。
即値が必要な命令では、
即値の代わりに実効アドレスを使います。
このため、
COMET II や CASL II ではよく以下のような勘違いが起こります。

IA-32 アーキテクチャでは、
#+begin_src casl
	movl	$123, %eax
	addl	$456, %eax
#+end_src
とすれば、
レジスタ EAX に即値 123 が格納され、
その後、
レジスタ EAX に即値 456 が追加されます。

CASL II でも同じようなつもりで
#+begin_src casl
	LD	GR1, 123
	ADDA	GR1, 456
#+end_src
のように書いてしまいがちです。
他のコンピュータや CPU のアセンブリ言語に慣れていればいるほど、
上記のように書きたくなります。
このように書いても完全に正しいプログラムではあるのですが、
期待とはまったく異なる動作をします。
というのも、
#+begin_src casl
	LD	GR1, 123
#+end_src
はレジスタ GR1 に 123 を格納するのではなく、
メモリの 123 番地に格納されている値をレジスタ GR1 に読み込むからです。
同じように、
#+begin_src casl
	ADDA	GR1, 456
#+end_src
はレジスタ GR1 に 456 が加算されるのではなく、
メモリの 456 番地に格納されている値をレジスタ GR1 に加算します。

COMET II にはメモリ保護の機能もないため、
123 番地や 456 番地の値を読み出しても特にエラーになりません。
おそらくこれらの番地はゼロで初期化されているでしょうから、

1. レジスタ GR1 にゼロを読み込む
2. レジスタ GR1 にゼロを加算する
という処理になり、
結局、
レジスタ GR1 の値はゼロのままになってしまいます。

** COMET II 命令セット (データ転送)
<<sec:comet/trans>>

IA-32 アーキテクチャの説明 ([[ch:x86regs]] 章〜[[ch:x86ctrl]] 章) と同じように、
COMET II の命令を順番に説明しましょう。

データ転送命令とは、
汎用レジスタ間でデータをコピーしたり、
メモリと汎用レジスタの間でデータをコピーしたり、
即値をレジスタに書き込むための命令です。
スタックへのプッシュやポップもデータ転送命令に含まれます。

COMET II のデータ転送命令は以下の 5 種類です。
表の右端には、
それぞれの命令の動作を CPU の抽象モデルで記述しています。
ニーモニックの表記における ~[]~ は省略できることを意味します。

| 名称           | ニーモニック               | 説明                                                               |
|----------------+----------------------------+--------------------------------------------------------------------|
| ロード         | LD    \r{i}, \r{j}         | \r{j} が差すメモリ上の値を \r{i} に読み込む                        |
| (LoaD)         |                            | \r{i} ← [\r{j}]                                                    |
| ロード         | LD    \r{i}, $m$ [, \r{j}] | 実効アドレス $m + \r{j}$ が差すメモリ上の値を \r{i} に読み込む     |
| (LoaD)         |                            | \r{i} ← [$m$ + \r{j}]                                             |
| ストア         | ST    \r{i}, $m$ [, \r{j}] | \r{i} の値を実効アドレス $m + \r{j}$ が差すメモリに書き込む        |
| (STore)        |                            | [$m$ + \r{j}] ← r                                                 |
| ロードアドレス | LAD   \r{i}, $m$ [, \r{j}] | 実効アドレス $m + \r{j}$ を \r{i} に格納する                       |
| (Load ADdress) |                            | \r{i} ← $m$ + \r{j}                                               |
| プッシュ       | PUSH  $m$ [, \r{i}]        | SP を -1 し、実効アドレス $m + \r{i}$ をスタックの最上位に書き込む |
| (PUSH)         |                            | \sp ← <-> 1, [\sp] ← $m$ + \r{i}                                |
| ポップ         | POP   \r{i}                | スタック最上位の値を \r{i} に読み込み、SP を -1 する               |
| (POP)          |                            | \r{i} ← [\sp], ; \sp ← <-> 1                                     |

LD 命令には、
オペランドの記述方法が異なる 2 種類の命令があります。
どちらも同じ LD というニーモニックですが、
実際には異なる命令です。
つまり、
#+begin_quote
LD \r{i}, \r{j}
#+end_quote
という、
*レジスタ \r{j} の値* をレジスタ \r{i} にコピーする命令と、
#+begin_quote
LD \r{i}, $m$ [, \r{j}]
#+end_quote
という、
実効アドレス $m$ + \r{j} が差す *メモリ上の値* をレジスタ \r{i} に読み込む命令の 2 種類があります。
アセンブリ言語では、
どちらも同じ LD というニーモニックを使用しますが、
前者の LD 命令のオペコードは 0x14 で、
後者の LD 命令のオペコードは 0x10 です。

#+begin_note
正確には、
COMET II の仕様書 \cite{IPA19:COMET} には命令のオペコードは定められていません。
文献 \cite{IPA19:COMET} では、
COMET II のオペコードはあくまで参考資料として掲載されています。
#+end_note

ST 命令はオペランドの順番がインテル構文とは逆になっているので注意してください。
ST 命令のみ、
オペランドの順番が、
「出所オペランド, 宛先オペランド」の順番です。
例えば、
#+begin_src casl
	ST	GR1, #1234
#+end_src
はレジスタ GR1 の値を、
メモリの 0x1234 番地に書き込みます。
出所オペランドが =GR1= で、
宛先オペランドが =#1234= です。

また PUSH 命令は「メモリアドレス, インデックスレジスタ (オプション)」という形式のオペランドしか取れません。
何となく直感的ではありませんが、
これで大抵の処理が書けます。
例えば、
レジスタ GR3 の値をスタックにプッシュする場合は
#+begin_src raw
	PUSH	GR3	; 書けない!
#+end_src
のようなプログラムを組みたくなりますが、
CASL II ではこのように書くことはできません。
PUSH 命令のオペランドは実効アドレス $m$ や $m + \r{i}$ しか指定できないため、
レジスタ GR3 の値をプッシュしたい場合は
#+begin_src raw
	PUSH	0, GR3
#+end_src
のように書くことになります。
この場合、
実効アドレスが「0 + GR3」となり、
これはレジスタ GR3 の値と等しいため、
レジスタ GR3 の値を直接プッシュするのと同じ意味になります。

IA-32 アーキテクチャと比較したときの、
COMET II のデータ転送命令との特徴は以下のようなものです。
- データの大きさはすべてワード (16 ビット)
- 出所オペランドに即値が指定できない
- 宛先オペランドにメモリロケーションが指定できない
- 出所オペランドに指定できるメモリロケーションは「アドレス + インデッ
  クスレジスタ」の形式のみ
- LD 命令によってフラグレジスタが設定される (OF フラグは常に 0 になる)
- ST 命令のオペランドは「出所オペランド、宛先オペランド」の順
- PUSH 命令、POP 命令のオペランドは1種類しかない
- アトミックなデータ交換命令 (XCHG 命令等) がない

** COMET II 命令セット (算術演算、論理演算)
<<sec:comet/arith>>

*** 算術演算命令

以下に、
COMET II の算術演算および論理演算の一覧を示します。
オペランドはすべて「レジスタ、
レジスタ」の形式か、
「レジスタ、
メモリアドレス、
インデックスレジスタ (オプション)」の形式で統一されていることがわかります。

#+attr_latex: :environment maxtabular
| 算術加算            | ADDA \r{i}, \r{j}         | \r{i} に \r{j} の値を加える                                              |
| ADD Arithmetic      |                           | \r{i} ← <+> \r{j}                                                       |
|                     | ADDA \r{i}, $m$ [, \r{j}] | \r{i} に $m$ + \r{j} が差すメモリ上の値を加える                          |
|                     |                           | \r{i} ← <+> [$m$ + \r{j}]                                               |
| 論理加算            | ADDL \r{i}, \r{j}         | \r{i} に \r{j} の値を加える                                              |
| ADD Logical         |                           | \r{i} ← <+> \r{j}                                                       |
|                     | ADDL \r{i}, $m$ [, \r{j}] | \r{i} に $m$ + \r{j} が差すメモリ上の値を加える                          |
|                     |                           | \r{i} ← <+> [$m$ + \r{j}]                                               |
| 算術減算            | SUBA \r{i}, \r{j}         | \r{i} から \r{j} の値を減じる                                            |
| SUBtract Arithmetic |                           | \r{i} ← <-> \r{j}                                                       |
|                     | SUBA \r{i}, $m$ [, \r{j}] | \r{i} から $m$ + \r{j} が差すメモリ上の値を減じる                        |
|                     |                           | \r{i} ← <-> [$m$ + \r{j}]                                               |
| 論理減算            | SUBL \r{i}, \r{j}         | \r{i} から \r{j} の値を減じる                                            |
| SUBtract Logical    |                           | \r{i} ← <-> \r{j}                                                       |
|                     | SUBL \r{i}, $m$ [, \r{j}] | \r{i} から $m$ + \r{j} が差すメモリ上の値を減じる                        |
|                     |                           | \r{i} ← <-> [$m$ + \r{j}]                                               |
| 論理積              | AND \r{i}, \r{j}          | \r{i} に \r{i} と \r{j} の論理積を格納する                               |
| AND                 |                           | \r{i} ← <&> \r{j}                                                       |
|                     | AND \r{i}, $m$ [, \r{j}]  | \r{i} に \r{i} と $m$ + \r{j} が差すメモリ上の値の論理積を格納する       |
|                     |                           | \r{i} ← <&> [$m$ + \r{j}]                                               |
| 論理和              | OR \r{i}, \r{j}           | \r{i} に \r{i} と \r{j} の論理和を格納する                               |
| OR                  |                           | \r{i} ← <\vbar> \r{j}                                                   |
|                     | OR \r{i}, $m$ [, \r{j}]   | \r{i} に \r{i} と $m$ + \r{j} が差すメモリ上の値の論理和を格納する       |
|                     |                           | \r{i} ← <\vbar> [$m$ + \r{j}]                                           |
| 排他的論理和        | XOR \r{i}, \r{j}          | \r{i} に \r{i} と \r{j} の排他的論理和を格納する                         |
| eXclusive OR        |                           | \r{i} ← <^> \r{j}                                                       |
|                     | XOR \r{i}, $m$ [, \r{j}]  | \r{i} に \r{i} と $m$ + \r{j} が差すメモリ上の値の排他的論理和を格納する |
|                     |                           | \r{i} ← <^> [$m$ + \r{j}]                                               |

このように、
COMET II では基本的な算術演算と論理演算が可能です。
ただし、
乗算や除算のための算術演算命令はないため、
COMET II で乗算や除算をするためにはプログラムを書いて実現する必要があります。
算術演算と論理演算はほとんど同じですが、
OF フラグの設定のされ方が異なります。

また、
COMET II には、
INC 命令や DEC 命令のような、
レジスタの値を 1 だけ増減する命令はありません。
このため、
COMET II では、
レジスタの値を \pm 1 するためには、
LAD 命令を使います。
例えば、
レジスタ GR1 の値に 1 を加えるには
#+begin_src casl
	LAD	GR1, 1, GR1
#+end_src
のように書きます。
「レジスタ GR1 の値 + 1」を実効アドレスとして指定し、
その実効アドレスの値をレジスタ GR1 に格納するわけです。

レジスタの値を増減するプログラムの例を示します (図 [[fig:comet/inc-dec.cas]])。

#+caption: comet/inc-dec.cas
#+label: fig:comet/inc-dec.cas
#+include: "code/comet/inc-dec.cas" src casl

また、
COMET II には論理否定 (not) のための命令がありません。
すべての論理演算は排他的論理和の組み合わせで記述できるので、
当然ながら論理否定も排他的論理和 (XOR) で実現できます。
論理否定 (NOT) を計算するプログラムの例を示します (図 [[fig:comet/not.cas]])。

#+caption: comet/not.cas
#+label: fig:comet/not.cas
#+include: "code/comet/not.cas" src casl

*** 比較演算命令

#+attr_latex: :environment maxtabular
| 算術比較           | CPA \r{i}, \r{j}         | \r{i} - \r{j} に従って SF、ZF フラグを設定する                           |
| ComPare Arithmetic |                          | \sf ← \r{i} - \r{j} が負; \zf ← \r{i} - \r{j} がゼロ                   |
|                    | CPA \r{i}, $m$ [, \r{j}] | \r{i} - [$m$ + \r{j}] が差すメモリ上の値に従って SF、ZF フラグを設定する |
|                    |                          | \sf ← \r{i} - [$m$ + \r{j}] が負; \zf ← \r{i} - [$m$ + \r{j}] がゼロ   |
| 論理比較           | CPL \r{i}, \r{j}         | \r{i} - \r{j} に従って SF、ZF フラグを設定する                           |
| ComPare Logical    |                          | \sf ← \r{i} - \r{j} が負; \zf ← \r{i} - \r{j} がゼロ                   |
|                    | CPL \r{i}, $m$ [, \r{j}] | \r{i} - [$m$ + \r{j}] が差すメモリ上の値に従って SF、ZF フラグを設定する |
|                    |                          | \sf ← \r{i} - [$m$ + \r{j}] が負; \zf ← \r{i} - [$m$ + \r{j}] がゼロ   |

比較命令は CPA 命令と CPL 命令の 2 つだけです。
「宛先オペランド - 出所オペランド」の差によって、
SF フラグと ZF フラグを設定します。

| オペランドの大小関係             | SF フラグ | ZF フラグ |
|----------------------------------+-----------+-----------|
| 宛先オペランド > 出所オペランド  |         0 |         0 |
| 宛先オペランド = 出所オペランド  |         0 |         1 |
| 宛先オペランド < 出所オペランド  |         1 |         0 |

加算 (ADDA 命令と ADDL 命令) や減算 (SUBA 命令と SUBL 命令) と同じように、
符号なし整数と符号付き整数のために別の命令が用意されています。
例えば、
符号なし整数の場合
#+begin_quote
0xffff (= 65535) > 0x0001 (= 1)
#+end_quote
という大小関係になります。
ただし、
オペランドの値が符号付き整数であれば
#+begin_quote
0xffff (= -1) < 0x0001 (= 1)
#+end_quote
のように不等号の向きが逆になります。
そのため、
#+begin_src casl
	LD	GR1, V1		; GR1 ← (V1)
	CPL	GR1, V2		; GR1 > (V2)?
	CPA	GR1, V2		; GR1 > (V2)?
V1	DC 	#FFFF
V2	DC 	#0001
#+end_src
において、
CPL 命令を実行すると SF フラグは 0 になります (0xffff > 0x0001 であるため)。
一方、
CPA 命令を実行すると SF フラグは 1 になります (-1 < 1 であるため)。
オペランドの値が符号なし整数なのか符号付き整数なのかは CPU からは区別できないため、
符号なしか符号付きかに応じて異なる比較命令を使う必要があります。

*** シフト演算命令

シフト演算命令のオペランドは「レジスタ, メモリアドレス, インデックスレジスタ (オプション)」の形式のみです。
実効アドレスの値だけ左もしくは右にビットシフトします。

| 算術左シフト           | SLA \r{i}, $m$ [, \r{j}] | \r{i} を左に $m + \r{j}$ 回ビットシフトする |
| Shift Left Arithmetic  |                          | \r{i} ← <$\ll$> $m$ + \r{j}                |
| 算術右シフト           | SRA \r{i}, $m$ [, \r{j}] | \r{i} を右に $m + \r{j}$ 回ビットシフトする |
| Shift Right Arithmetic |                          | \r{i} ← <$\gg$> $m$ + \r{j}                |
| 論理左シフト           | SLL \r{i}, $m$ [, \r{j}] | \r{i} を左に $m + \r{j}$ 回ビットシフトする |
| Shift Left Logical     |                          | \r{i} ← <$\ll$> $m$ + \r{j}                |
| 論理左シフト           | SRL \r{i}, $m$ [, \r{j}] | \r{i} を右に $m + \r{j}$ 回ビットシフトする |
| Shift Left Logical     |                          | \r{i} ← <$\gg$> $m$ + \r{j}                |

算術演算・比較演算と同じように、
オペランドの値が、
符号なし整数か符号付き整数かによって、
それぞれ別の命令が用意されています。
オペランドの値が符号なしか符号付きかによってビットシフトの挙動が大きく異なるので、
2 つの命令が用意されているというのは一般的なことです。
IA-32 アーキテクチャでも、
符号なし用と符号付き用に別のビットシフト命令が用意されています。

COMET II のシフト演算命令では、
宛先オペランドに指定できるのはレジスタのみであり、
メモリロケーションは指定できません。
また、
出所オペランドに指定できるのは実効アドレスのみです。
そのため、
「メモリに格納されている値の数だけビットシフトする」という演算はできません。

IA-32 アーキテクチャと比較したときの、
COMET II の算術演算・論理演算命令の特徴は以下のようなものです。
- データの大きさはすべてワード (16 ビット)
- 出所オペランドに即値が指定できない
- 宛先オペランドにメモリロケーションが指定できない
- 出所オペランドに指定できるメモリロケーションは「アドレス + インデッ
  クスレジスタ」の形式のみ
- 算術演算・比較演算には符号なし整数と符号付き整数に別の命令が用意され
  ている
- 算術演算には乗算や減算のための命令はない
- 算術演算には +1 や -1 のための命令はない
- 論理否定のための命令はない

** COMET II 命令セット (実行制御)
<<sec:comet/ctrl>>

*** 分岐命令

#+attr_latex: :environment maxtabular
| 無条件分岐         | JUMP $m$ [, \r{i}] | 実行アドレス $m$ + \r{i} にジャンプする                           |
| unconditional JUMP |                    | \pc ← $m$ + \r{i}                                                |
| 零分岐             | JZE $m$ [, \r{i}]  | 直前の演算結果がゼロなら $m$ + \r{i} にジャンプする               |
| Jump on ZEro       |                    | \pc ← $m$ + \r{i} \mbox{if $\zf = 1$}                            |
| 非零分岐           | JNZ $m$ [, \r{i}]  | 直前の演算結果がゼロでないなら $m$ + \r{i} にジャンプする         |
| Jump on Non Zero   |                    | \pc ← $m$ + \r{i} \mbox{if $\zf = 0$}                            |
| 正分岐             | JPL $m$ [, \r{i}]  | 直前の演算結果が正なら $m$ + \r{i} にジャンプする                 |
| Jump on PLus       |                    | \pc ← $m$ + \r{i} \mbox{if $\sf = 0$ and $\zf = 0$}              |
| 負分岐             | JMI $m$ [, \r{i}]  | 直前の演算結果が負なら $m$ + \r{i} にジャンプする                 |
| Jump on MInus      |                    | \pc ← $m$ + \r{i} \mbox{if $\sf = 1$ }                           |
| オーバーフロー分岐 | JOV $m$ [, \r{i}]  | 直前の演算結果でオーバーフローがあれば $m$ + \r{i} にジャンプする |
| Jump on OVerflow   |                    | \pc ← $m$ + \r{i} \mbox{if $\of = 1$}                            |

分岐命令のオペランドは「レジスタ、
メモリアドレス、
インデックスレジスタ (オプション)」の形式のみです。

COMET II のジャンプ命令は無難な命令セットになっています。
無条件ジャンプである JUMP 命令と、
条件ジャンプ命令である、
JZE 命令、
JNZ 命令、
JPL 命令、
JMI 命令、
JOV 命令があります。

JUMP 命令は *無条件ジャンプ* のための命令です。
プログラムカウンタ (PR レジスタ) の値を、
オペランドに指定された実効アドレスに変更します。
また、
JZE 命令は、
直前の演算結果がゼロであった時にのみジャンプする *条件ジャンプ* 命令です。
ZF フラグが 1 であれば、
JUMP 命令と同じように、
オペランドに指定された実効アドレスにジャンプします。
ZF フラグが 0 であれば何も行いません (プログラムカウンタを次の命令に進めます)。

| 条件ジャンプ命令 | 条件                   | OV | SF | ZF |
|------------------+------------------------+----+----+----|
| JUMP             | 常に                   |    |    |    |
| JZE              | ゼロである             |    |    |  1 |
| JNZ              | ゼロでない             |    |    |  0 |
| JPL              | 正である               |    |  0 |  0 |
| JMI              | 負である               |    |  1 |    |
| JOV              | オーバーフローがあった |  1 |    |    |

COMET II のジャンプ命令は癖のないものばかりですが、
命令の名前が少し覚えにくいかもしれません。
例えば、
無条件ジャンプの命令は JP でも JMP でもなく JUMP (4 文字) です。
他の条件ジャンプ命令はすべて 3 文字ですが、
無条件ジャンプだけ 4 文字です。

また条件ジャンプも覚えにくい名前になっています。
ZF フラグが 1 の時の条件ジャンプ命令は JZE であり、
JE でも、
JZ でも JMPZ でもありません。
CPU のアーキテクチャによってジャンプ命令の名称はさまざまなので仕方ありませんが、
いろいろなアーキテクチャのアセンブリ言語を読んだり書いたりしていると混乱しそうです。
とりあえず、
「COMET II の無条件ジャンプは 4 文字、
条件ジャンプはすべて 3 文字」と覚えておくとよいでしょう。

*** コール、リターン命令

#+attr_latex: :environment maxtabular
| コール                 | CALL $m$ [, \r{i}] | スタックにプログラムカウンタをプッシュし、実効アドレス $m$ + \r{i} にジャンプする |
| CALL subroutine        |                    | \sp ← <-> 1; [\sp] ← \pc; \pc ← $m$ + \r{i}                                    |
| リターン               | RET                | スタックに積まれているリターンアドレスをポップし、そこにジャンプする              |
| RETurn from subroutine |                    | \pc ← [\sp]; \sp ← <+> 1                                                        |

関数やサブルーチンの呼び出しと、
呼び出された関数やサブルーチンからの復帰を行う CALL 命令と RET 命令です。
分岐命令と同じく、
コールおよびリターン命令のオペランドは「レジスタ、
メモリアドレス、
インデックスレジスタ (オプション)」の形式のみです。

CALL 命令も RET 命令もまったく普通の命令です。
他のコンピュータにおける CALL 命令や RET 命令と大きな差はありません。

上の表に示したように、
CALL 命令の動作を CPU の抽象モデルで記述すると以下のようになります。
| \sp          | ← | <-> 1       |
| \relax [\sp] | ← | \pc         |
| \pc          | ← | $m$ + \r{i} |
これら 3 つの処理が、
単一の CALL 命令によって実行されます。

実際には COMET II ではこのようには書けませんが、
もし仮に PR レジスタを命令のオペランドに指定できたとすると、
~CALL m [, r]~ は
#+begin_src casl
	PUSH	0, PR
	JUMP	m [, r]
#+end_src
という 2 命令と同じ処理を行います。
CALL 命令がスタックに積むリターンアドレスは、
CALL 命令が配置されているメモリのアドレスではなく、
CALL 命令の次の命令が配置されているメモリのアドレス (CALL 命令が配置されているメモリのアドレス + 2 ワード) であることに注意してください。

*** スーパーバイザコール

| スーパバイザコール | SVC $m$ [, \r{i}] | $m$ + \r{i} を引数としてスーパバイザ呼び出しを行う |
| SuperVisor Call    |                   | (CPU の抽象モデルで記述できない)                   |

英語の supervisor とは「監督者、
管理者」という意味です。

#+begin_note
ちなみに、
米国の大学では、
大学院修士課程や博士課程において、
学生の修士論文や博士論文の指導を行う教員 (指導教員) を supervisor と呼びます。
#+end_note

*スーパーバイザコール (supervisor call)* とは「監督者、
管理者を呼び出す」という意味です。
コンピュータにおけるスーパーバイザコールとは、
通常、
オペレーティングシステムの何らかの機能を呼び出すことを意味します。
オペレーティングシステムのシステムコール ([[sec:gas/usage]] 参照) もスーパーバイザコールの一種です。

COMET II は仮想コンピュータであり、
COMET II 上でどのようなオペレーティングシステムが動作しているのかは規定されていません。
「COMET II のプログラムは、
何らかのオペレーティングシステムの監視下で動作していて、
SVC 命令によってその機能を呼び出せる」ということだけが決まっています。

SVC 命令は、
その何らかのオペレーティングシステムの機能を呼び出すための命令で、
オペレーティングシステムに、
SVC 命令に指定したオペランドがそのまま通知されると定められています。
しかし、
どんなオペランドを通知したら、
オペレーティングシステムが何をしてくれるのか、
などはまったく決まっていません。

例えば、
COMET II シミュレータである ~comet~ プログラムでは、
SVC 命令のオペランドが 1 である (正確には、
実効アドレスの値が 1 である) 場合には、
レコードの入力 (標準入力からの文字列入力) を行います。
SVC 命令のオペランドが 2 である (正確には、
実効アドレスの値が 2 である) 場合には、
レコードの出力 (標準出力への文字出力) を行います。
ただし、
これらの動作は COMET II シミュレータが独自に (勝手に) 定めたものです。
COMET II の使用ではこれらの動作は定められていません。

IA-32 アーキテクチャと比較したときの、
COMET II の実行制御命令の特徴は以下のようなものです。
- 宛先オペランドにメモリロケーションが指定できない
- 無条件ジャンプ、条件ジャンプの命令の名前が似ているが微妙に違う
- ジャンプ命令・コール命令のジャンプ先に指定できるのは絶対アドレスのみ
  (相対ジャンプはできない)
- ジャンプ命令・コール命令のオペランドにレジスタは指定できない (実効ア
  ドレスで代用する)
- オペレーティングシステムの機能呼び出しはスーパーバイザコール命令を使
  う (ただし詳細は未定義)

** シミュレータによるトレース

*** レジスタどうしの加算

CASL II の記法および COMET II の命令セットを一通り説明したので、
COMET II シミュレータを使って実際のプログラムの動作を追いかけてみましょう。

まずは単純なレジスタどうしの加算のプログラム ~add-reg.cas~ です (図 [[fig:comet/add-reg.cas]])。
基本的に [[ch:tr-mem]] 章で示したプログラムの COMET II 版です。

#+caption: comet/add-reg.cas
#+label: fig:comet/add-reg.cas
#+include: "code/comet/add-reg.cas" src casl

COMET II ではプログラム終了時にステータスコードを返せないので、
計算結果はレジスタに残ったまま、
最後の RET 命令でプログラムは終了します。

まず、
~casl~ コマンドでアセンブルします。
~-a~ オプションを付けてアセンブル結果を表示します。
#+begin_src raw
$ casl -a add-reg.cas
CASL LISTING add-reg.cas
   2 0000 1210          LAD     GR1, 123
   2      007b
   3 0002 1211          LAD     GR1, 1, GR1
   3      0001
   4 0004 1220          LAD     GR2, 456
   4      01c8
   5 0006 2412          ADDA    GR1, GR2
   6 0007 8100          RET

DEFINED LABELS
               add-reg.cas:1    0000 MAIN
#+end_src
特にエラーも表示されることなく無事アセンブルできました。
5 命令しかないプログラムなのでトレースも簡単そうです。

~add-reg.cas~ と同じディレクトリにオブジェクトファイル ~add-reg.com~ ができているはずです。
#+begin_src raw
$ ls -l add-reg.*
-rw-r--r-- 1 asm asm 126 Mar 11 08:02 add-reg.cas
-rw-r--r-- 1 asm asm 276 Mar 11 08:07 add-reg.com
#+end_src

COMET II シミュレータを起動して、
オブジェクトファイル ~add-reg.com~ を読み込みます。
#+begin_src raw
$ comet add-reg.com
This is COMET, version 1.0.
Copyright (c) 2021, Hiroyuki Ohsaki.
All rights reserved.
Reading object from add-reg.com...done.
PR  #0000 [LAD  GR1, #007b                    ] SP  #ffff  OF 0  SF 0  ZF 0
GR0 #0000 (     0) GR1 #0000 (     0) GR2 #0000 (     0) GR3 #0000 (     0)
GR4 #0000 (     0) GR5 #0000 (     0) GR6 #0000 (     0) GR7 #0000 (     0)
comet>
#+end_src

~comet~ コマンドの出力の意味や基本的な操作法は [[sec:comet/overview]] 節で説明したので、
ここでは、
まだ説明していない使い方を中心に説明します。

disasm コマンド (省略系は di) でメモリの内容を逆アセンブルできます。
#+begin_src raw
comet> di
#0000 <MAIN>     LAD    GR1, #007b
#0002            LAD    GR1, #0001, GR1
#0004            LAD    GR2, #01c8
#0006            ADDA   GR1, GR2
#0007            RET
#0008            NOP
#0009            NOP
#000a            NOP
#000b            NOP
#000c            NOP
#000d            NOP
#000e            NOP
#000f            NOP
#0010            NOP
#0011            NOP
#0012            NOP
comet>
#+end_src
現在のプログラムカウンタ (PR レジスタ) が指すアドレスから、
32 ワードが逆アセンブルされます。
disasm コマンドにアドレスを指定すると、
逆アセンブルを開始するアドレスを指定できます。

当然ですが、
~add-reg.cas~ に記述した 5 個の命令が並んでいます。
LAD 命令の第 2 オペランドは 16 進数 (#007b、
#0001、#01c8) で表示されていますが、
これらは 10 進数でそれぞれ 123、
1、456 です。

まずはステップ実行でレジスタ GR1 および GR2 の変化を見てみましょう。
step コマンド (省略形は s) で 1 命令ずつステップ実行します。
最初に実行される命令は \inst{LAD GR1, #007b} です。
レジスタ GR1 に 0x7b (= 123) が格納されるはずです。
#+begin_src raw
comet> s
PR  #0002 [LAD  GR1, #0001, GR1               ] SP  #ffff  OF 0  SF 0  ZF 0
GR0 #0000 (     0) GR1*#007b (   123) GR2 #0000 (     0) GR3 #0000 (     0)
GR4 #0000 (     0) GR5 #0000 (     0) GR6 #0000 (     0) GR7 #0000 (     0)
comet>
#+end_src
レジスタ GR1 の値が変化し (レジスタ名の右に ~*~ が表示されています)、
確かに 123 になっています。

続けてもう 1 命令実行してみましょう。
次の命令は \inst{LAD GR1, #0001, GR} であり、
実効アドレス「#0001 + GR」をレジスタ GR1 に格納します。
これはつまり、
レジスタ GR1 に 1 を加算することと同じです。
#+begin_src raw
comet > ← エンターキーを押す (step コマンドの繰り返し)
PR  #0004 [LAD  GR2, #01c8                    ] SP  #ffff  OF 0  SF 0  ZF 0
GR0 #0000 (     0) GR1*#007c (   124) GR2 #0000 (     0) GR3 #0000 (     0)
GR4 #0000 (     0) GR5 #0000 (     0) GR6 #0000 (     0) GR7 #0000 (     0)
comet>
#+end_src
再びレジスタ GR1 の値が変化しました。
レジスタ GR1 の値が 1 増えて 124 になりました。

次の命令は \inst{LAD GR2, #01c} です。
レジスタ GR2 に 456 が格納されます。
#+begin_src raw
comet > ← エンターキーを押す (step コマンドの繰り返し)
PR  #0006 [ADDA GR1, GR2                      ] SP  #ffff  OF 0  SF 0  ZF 0
GR0 #0000 (     0) GR1 #007c (   124) GR2*#01c8 (   456) GR3 #0000 (     0)
GR4 #0000 (     0) GR5 #0000 (     0) GR6 #0000 (     0) GR7 #0000 (     0)
comet>
#+end_src
確かにレジスタ GR2 の値が変化して 456 になりました。

最後に、
\inst{ADDA GR1, GR2} によってレジスタ GR1 にレジスタ GR2 の値を加算します。
#+begin_src raw
comet > ← エンターキーを押す (step コマンドの繰り返し)
PR  #0007 [RET                                ] SP  #ffff  OF 0  SF 0  ZF 0
GR0 #0000 (     0) GR1*#0244 (   580) GR2 #01c8 (   456) GR3 #0000 (     0)
GR4 #0000 (     0) GR5 #0000 (     0) GR6 #0000 (     0) GR7 #0000 (     0)
comet>
#+end_src
レジスタ GR1 の値が 580 に変化しました。

[[ch:tr-mem]] 章で説明した IA-32 アーキテクチャの機械語プログラムのトレースと、
本質的には同じです。
またこの結果から、
COMET II は確かに少数のレジスタと、
単純な算術演算・論理演算の組み合わせで動いていることがわかります。

*** 単一ループによる順列の和の計算

もう少し複雑な例を見てみましょう。

単純なループによって 1〜100 の和を計算するプログラムです (図 [[fig:comet/sum.cas]])。

#+caption: comet/sum.cas
#+label: fig:comet/sum.cas
#+include: "code/comet/sum.cas" src casl

CPA 命令によってレジスタ GR2 のと 100 を比較し、
その結果によってフラグレジスタを設定しています。
JPL 命令は「レジスタ GR2 の値 - 100」が正 (プラス) であれば指定された実効アドレスにジャンプします。
この場合、
レジスタ GR2 の値が 101 以上のときにラベル ~DONE~ が指すアドレスにジャンプします。

このプログラムは、
ループカウンタの取る値が 1〜101 (101 のときのループを抜けます) なので、
算術比較の CPA 命令でも、
論理比較の CPL 命令でもどちらでもかまいません (まったく同じように動作します)。

ループカウンタは
#+begin_src casl
	LAD	GR2, 1, GR2	; GR1 を +1 する
#+end_src
のように LAD 命令を使って +1 しています。
もちろん、
#+begin_src casl
	ADDA	GR2, =1
#+end_src
のように書いてもかまいませんが、
ADDA 命令を使うと定数 1 を格納するメモリが別途必要ですし、
余分にメモリアクセスが発生します。
COMET II でメモリサイズや実行時間を削減する努力をする必要はありませんが、
ADDA 命令よりも LAD 命令で書いたほうが何となくスマートでしょう。

COMET II シミュレータでプログラムの動作を追いかけてみましょう。
#+begin_src raw
$ casl sum.cas
$ comet sum.com
This is COMET, version 1.0.
Copyright (c) 2021, Hiroyuki Ohsaki.
All rights reserved.
Reading object from sum.com...done.
PR  #0000 [LAD  GR1, #0000 <MAIN>             ] SP  #ffff  OF 0  SF 0  ZF 0
GR0 #0000 (     0) GR1 #0000 (     0) GR2 #0000 (     0) GR3 #0000 (     0)
GR4 #0000 (     0) GR5 #0000 (     0) GR6 #0000 (     0) GR7 #0000 (     0)
comet>
#+end_src

これまでと同じように、
step コマンドを繰り返し実行してもよいのですが、
実行される命令数が多くなってくると何度もエンターキーを押す必要があります。
そこで、
ここではブレークポイントを利用して指定したアドレスでプログラムの実行を中断するようにします。

まず、
label コマンド (省略形は l) を利用して、
ラベルの一覧を表示します。
~casl~ アセンブラはアセンブリ言語プログラム中のラベルをオブジェクトファイル中に書き出し、
~comet~ シミュレータはそれらのラベルを読み込みます。
このため、
COMET II シミュレータからアセンブリ言語のラベルを参照することができます。
#+begin_src raw
comet> l
MAIN	#0000 (     0)
LOOP	#0004 (     4)
DONE	#000d (    13)
=100	#000e (    14)
comet>
#+end_src
4 つのラベルが定義されていることがわかります。
各行は、
ラベル名と、
そのラベルに対応するアドレスの値を 16 進数と 10 進で表示しています。

ループの開始番地 (ラベル ~LOOP~ が記載されている箇所) にブレークポイントを設定します。
break コマンド (省略形は b) を使って、
ラベル ~LOOP~ の番地にブレークポイントを設定します。
#+begin_src raw
comet> b LOOP
Breakpoint 1 at #0004 <LOOP>
comet>
#+end_src
ブレークポイント番号 1 が割り当てられ、
アドレス 0x0004 にブレークポイントが設定されました。

それでは、
プログラムの実行を開始しましょう。
今回は step コマンドではなく、
continue コマンド (省略形は c) でプログラムの命令を連続的に実行します。
#+begin_src raw
comet> c
Breakpoint 1, #0004 <LOOP>
PR  #0004 [CPA  GR2, #000e <=100>             ] SP  #ffff  OF 0  SF 0  ZF 0
GR0 #0000 (     0) GR1 #0000 (     0) GR2*#0001 (     1) GR3 #0000 (     0)
GR4 #0000 (     0) GR5 #0000 (     0) GR6 #0000 (     0) GR7 #0000 (     0)
comet>
#+end_src
プログラムカウンタ (PR レジスタ) が 0x0004 番地のブレークポイントで自動的に一時停止します。

ここからまたステップ実行したり、
メモリの中身をダンプしたりすることが可能です。
ここでは再度 continue コマンドを実行します。
#+begin_src raw
comet> c
Breakpoint 1, #0004 <LOOP>
PR  #0004 [CPA  GR2, #000e <=100>             ] SP  #ffff  OF 0  SF 0  ZF 0
GR0 #0000 (     0) GR1*#0001 (     1) GR2*#0002 (     2) GR3 #0000 (     0)
GR4 #0000 (     0) GR5 #0000 (     0) GR6 #0000 (     0) GR7 #0000 (     0)
comet>
#+end_src
複数の命令を実行し、
プログラムカウンタの値が再度 0x0004 に戻った時点でブレークポイントで停止しました。

このプログラムでは、
レジスタ GR1 が合計の値、
レジスタ GR2 がループカウンタです。
レジスタ GR1 の値は最初の 1 が加算され 1 になっています。
レジスタ GR2 の値は 2 回目のループの始まりなので 2 になっています。

さらに 2 回ほど continue コマンドを実行してみます。
ループの 3 回目、
4 回目でそれぞれ停止します。
#+begin_src raw
comet> ← エンターキーを押す (continue コマンドの繰り返し)
Breakpoint 1, #0004 <LOOP>
PR  #0004 [CPA  GR2, #000e <=100>             ] SP  #ffff  OF 0  SF 0  ZF 0
GR0 #0000 (     0) GR1*#0003 (     3) GR2*#0003 (     3) GR3 #0000 (     0)
GR4 #0000 (     0) GR5 #0000 (     0) GR6 #0000 (     0) GR7 #0000 (     0)
comet> ← エンターキーを押す (continue コマンドの繰り返し)
Breakpoint 1, #0004 <LOOP>
PR  #0004 [CPA  GR2, #000e <=100>             ] SP  #ffff  OF 0  SF 0  ZF 0
GR0 #0000 (     0) GR1*#0006 (     6) GR2*#0004 (     4) GR3 #0000 (     0)
GR4 #0000 (     0) GR5 #0000 (     0) GR6 #0000 (     0) GR7 #0000 (     0)
comet>
#+end_src
ループカウンタであるレジスタ GR2 の値が 3、
4 と増えています。
また、
合計値を格納しているレジスタ GR1 の値が 1、
3 (= 1 + 2)、
6 (= 1 + 2 + 3) と正しく増えていることが確認できます。

設定したブレークポイントの一覧を見るには info コマンド (省略形は i) を使います。
#+begin_src raw
comet> i
1: #0004 <LOOP>
#+end_src
ブレークポイント 1 番が、
アドレス 0x0004 に設定されていることがわかります。
また、
0x0004 番地はラベル ~LOOP~ に対応していることもわかります。

設定したブレークポイントを削除するには delete コマンド (省略形は d) を使います。
#+begin_src raw
comet> d
Delete all breakpoints? (y or n) y
comet>
#+end_src
delete コマンドに引数を指定しなければすべてのブレークポイントを削除します。
ブレークポイント番号を指定すればそれぞれのブレークポイントを個別に削除することもできます。
このあたりのコマンドの挙動も GDB に似せてあるので、
GDB の使い方に慣れていればあまり困らないことでしょう。

最後に、
ラベル ~DONE~ にブレークポイントを設定して、
プログラムの実行を再開します。
末尾の RET 命令の直前でプログラムを停止します。
#+begin_src raw
comet> b DONE
Breakpoint 1 at #000d <DONE>
comet> c
Breakpoint 1, #000d <DONE>
PR  #000d [RET                                ] SP  #ffff  OF 0  SF 0  ZF 0
GR0 #0000 (     0) GR1*#13ba (  5050) GR2*#0065 (   101) GR3 #0000 (     0)
GR4 #0000 (     0) GR5 #0000 (     0) GR6 #0000 (     0) GR7 #0000 (     0)
comet>
#+end_src
レジスタ GR2 (ループカウンタ) の値が 101 になっていること、
レジスタ GR1 (合計値) の値が 5 050 になっていることがわかります。
$\sum_{k = 1}^N k = (N \, (N + 1)) / 2$ なので、
$100 \, (100 + 1) / 2 = 5 050$ という正しい結果が得られています。

** コードリーディング
<<sec:comet/reading>>

ここからは、
COMET II のアセンブリ言語プログラムをいくつか読んでみましょう。

*** サブルーチンコール (レジスタによる引数渡し) のサンプル

2 つの数の和を計算するだけのプログラムです (図 [[fig:comet/add-sub.cas]])。
[[sec:comet/overview]] 節で説明したプログラム ~add.cas~ と似ていますが、
数の和の計算はサブルーチン呼び出しで行っています。

#+caption: comet/add-sub.cas
#+label: fig:comet/add-sub.cas
#+include: "code/comet/add-sub.cas" src casl

サブルーチン ~ADD~ は、
レジスタ GR1 と GR2 の値の和を計算し、
計算結果をレジスタ GR1 に返します。
プログラム中の
#+begin_src casl
	LD	GR1, =123	; GR1 ← 123 (リテラルによる定数の読み込み)
#+end_src
では CASL II のリテラルを使っています。
アセンブラが \inst{DC 123} を別途生成し、
定数を格納したメモリのアドレスを LD 命令のオペランドに与えます。
オペランドとして、
123 という即値を与えているように読めますが、
実際にはメモリにあらかじめ格納しておいた定数 123 を読み込んでいます。

*** サブルーチンコール (スタックによる引数渡し) のサンプル

先ほどのプログラムを、
サブルーチンへの引数をスタック上に積んで渡すように書き換えたものです (図 [[fig:comet/add-sub-stack.cas]])。
PUSH 命令で、
スタック上に引数 (123 と 456) を積んでから、
\inst{CALL ADD} でサブルーチン ~ADD~ を呼び出しています。
サブルーチン ~ADD~ は計算結果をレジスタ GR1 に返しています。

#+caption: comet/add-sub-stack.cas
#+label: fig:comet/add-sub-stack.cas
#+include: "code/comet/add-sub-stack.cas" src casl

COMET II では、
スタックポインタ (SP レジスタ) を直接操作できません。
このため、
サブルーチン ~ADD~ 中で、
スタック上に積まれた値を取り出すためには、
リターンアドレスをいったん取り出す必要があります。
スタックの一番上に積まれているリターンアドレスをレジスタ GR3 に取り出したあと、
スタック上の引数をレジスタ GR1、
レジスタ GR2 に順番に取り出しています。
引数はスタックに積まれているので、
積んだ順番と逆の順番で取り出されることに注意してください。
つまり、
呼び出し元では 456、
123 の順番にプッシュしていますが、
サブルーチン ~ADD~ では 123、
456 の順番に取り出しています。

最後に、
#+begin_src casl
	PUSH	0, GR3		; リターンアドレスを戻す (JUMP 0, GR3 でもよい)
	RET
#+end_src
のように、
レジスタ GR3 に取り出したリターンアドレスを再度スタックに戻したあと、
RET 命令でサブルーチンの呼び出し元に戻っています。
これは、
#+begin_src casl
	JUMP	0, GR3
#+end_src
のように書いても同じ処理が実現できます。
この場合 1 命令だけで済みます。
ただし、
サブルーチンから戻る処理は、
RET 命令で書いたほうが、
後からプログラムを読んだ時により理解しやすいでしょう。

*** OUT マクロ命令による文字列表示のサンプル

CASL II アセンブラのマクロ命令 OUT を使って文字列を出力するプログラムです (図 [[fig:comet/hello.cas]])。

#+caption: comet/hello.cas
#+label: fig:comet/hello.cas
#+include: "code/comet/hello.cas" src casl

OUT 命令は、
CASL II アセンブラによって、
文字列を出力する複数の命令に展開されます。
OUT 命令は 2 つのオペランド (出力領域のアドレス, 出力文字長領域のアドレス) を取ります。
#+begin_src casl
	OUT	OBUF, OLEN	; OUT 出力領域, 出力文字長領域
#+end_src
~OBUF~ は出力する文字列が格納されているアドレス、
~OLEN~ は出力する文字数が格納されているアドレスです。

*** 二重ループのサンプル (10 進数の出力)

ここからは少しずつ複雑になってきます。

まずは 2 重ループのプログラムとして、
レジスタ GR1 に格納された値を 10 進数で表示するプログラムを見ていきます (図 [[fig:comet/prtdec.cas]])。

#+caption: comet/prtdec.cas
#+label: fig:comet/prtdec.cas
#+include: "code/comet/prtdec.cas" src casl

コンピュータが扱えるのは 2 進数だけであり、
COMET II が扱えるのも 2 進数だけです。
数値を 10 進数で表示するだけでこのくらいの手間がかかります。

このプログラムを実行すると、
レジスタ GR1 の値 (12345) が出力されます。
#+begin_src raw
$ comet prtdec.com
This is COMET, version 1.0.
Copyright (c) 2021, Hiroyuki Ohsaki.
All rights reserved.
	:
	:
comet> c
OUT> 12345
Program terminated.
#+end_src

このプログラムでは、
レジスタ GR1 の値は符号なし整数 (0〜65 535) であることを仮定しています。
レジスタ GR1 の値の最大値が 65 535 なので最大で 5 桁になり、
外側のループは、
10 000 の桁、
1 000 の桁、
100 の桁、
10 の桁、
1 の桁のように、
5 回ループしています。

10 のべき乗の値を、
大きな値から引けるだけ引くことによって 10 進数表記を求めています。

例えば、
レジスタ GR1 の値が 10 781 の場合、
以下のようにして 10 進数表記を求めます。

#+attr_latex: :environment maxtabular
| 1. | まず、10 000 を引けるだけ引く。1 回だけ引けるので、BUF の先頭に '1' を書き込む。    | 残り 781。 |
| 2. | 次に 1 000 を引けるだけ引く。1 度も引けないので、BUF の 2 文字目に '0' を書き込む。 | 残り 781。 |
| 3. | 次に 100 を引けるだけ引く。7 回引けるので、BUF の 3 文字目に '7' を 書き込む。      | 残り 81。  |
| 4. | 次に 10 を引けるだけ引く。8 回引けるので、BUF の 4 文字目に '8' を 書き込む。       | 残り 1。   |
| 5. | 次に 1 を引けるだけ引く。1 回引けるので、BUF の 5 文字目に '1' を書 き込む。        | 残り 0。   |

*** 二重ループのサンプル (挿入ソート)

さらに複雑なプログラムとして、
*挿入ソート (insertion sort)* のプログラムを見ていきます。

ソートのような、
コンピュータサイエンスにおけるアルゴリズムを実装したプログラムを読むときには、

- ソートのアルゴリズム (今の場合は挿入ソート) を正確に理解していないと
  いけない
- アルゴリズムを記述しているプログラム言語のことも知らないといけない

ために大変です。
しかも、
今回のようなアセンブリ言語プログラムの場合には、

- アセンブリ言語は低レベル (プリミティブ) すぎてプログラム全体のロジッ
  クを把握しづらい

というのも加わります。
まさに三重苦です。

また、
挿入ソートそのもののアルゴリズムにも幅があります。
どのアルゴリズムの教科書を読んでも、
同じ挿入ソートの考え方が説明されていますが、
そこに掲載されているアルゴリズムは細かな点では異なっています。

ここでは、
まず C 言語で実装した挿入ソートのプログラム ~isort.c~ を示しましょう (図 [[fig:comet/c/isort.c]])。

#+caption: comet/c/isort.c
#+label: fig:comet/c/isort.c
#+include: "code/comet/c/isort.c" src C

C 言語のプログラム ~isort.c~ と、
次の CASL II のアセンブリ言語で書かれたプログラム (図 [[fig:comet/isort.cas]]) を比べてみてください。

#+caption: comet/isort.cas
#+label: fig:comet/isort.cas
#+include: "code/comet/isort.cas" src casl

C 言語のプログラム ~isort.c~ を、
できるだけ忠実にアセンブリ言語で書き直しています。
アセンブリ言語のプログラム ~isort.cas~ はコメントや空白行を除くと 30 行程度ですが、
アセンブリ言語の場合、
このくらい短いプログラムでも読むのも書くのも大変です。

レジスタ名が GR0〜GR7 のように機械的で、
レジスタに格納されている値とレジスタ名との対応を頭の中で考えないといけないことが大変さの理由の 1 つです。

他人が書いたアセンブリ言語のプログラムを読む場合は、
以下のようにするのも 1 つの手です (図 [[fig:comet/isort-macro.S]])。

#+caption: comet/isort-macro.S
#+label: fig:comet/isort-macro.S
#+include: "code/comet/isort-macro.S" src casl

それぞれのレジスタ名を、
意味のある文字列 (変数名らしきもの) に置き換えています。
例えば、
レジスタ GR1 をループインデックスとして使っており、
~GR1~ をすべて ~i~ に置き換えています。
同様にレジスタ GR0 を一時的な値を格納するために使っており、
~GR0~ をすべて ~tmp~ に置き換えています。
「小文字の変数名らしきものは、
すべて汎用レジスタが入る」ということを頭に入れて読めば、
もともとの ~isort.cas~ よりは読みやすいと思います。

CASL II ではユーザがマクロを定義できないため、
こういった記述はできません。
ただし、
GAS などの一般的なアセンブラではマクロを定義できるので、
アセンブリ言語をこのような形で記述することが可能です。

なお、
CASL II 自体にマクロ展開の機能がなくても、
他のマクロプロセッサと組み合わせて使用することも可能です。
例えば、
上記の ~isort-macro.cas~ は C 言語のプリプロセッサを使用して、
#+begin_src sh
$ cpp isort-macro.cas | grep -v '^#' >foo.cas
$ casl foo.cas
#+end_src
のようにすれば正しくアセンブルできます。
C 言語のプリプロセッサ (~cpp~ コマンド) を通すと、
~i~、
~j~、
~j_min1~ などのマクロが以下のように展開されます。
#+begin_src raw
$ cpp isort-macro.cas
#+end_src
#+include: "code/comet/isort-macro.txt" src casl
~cpp~ コマンドを通すとインデントが崩れますが、
CASL II ではインデントは特別な意味を持たないので、
~casl~ コマンドで正しくアセンブルできます。

ただし、
~cpp~ コマンドが出力する
#+begin_src raw
# 1 "isort-macro.cas"
#+end_src
のような行は CASL II アセンブラが認識できない (エラーになる) ため、
上の例では ~grep~ コマンドを使用して番号記号 (~#~) から始まる行を取り除いています。

*** 再帰呼び出しのサンプル (フィボナッチ数)

続いて再帰呼び出しのプログラムです。
プログラミング言語のサンプルで頻出する、
フィボナッチ数を求めるプログラムです (図 [[fig:comet/fib.cas]])。
フィボナッチ数とは、
非負整数 $n$ に対して、
\begin{align}
  F_n = \left\{
  \begin{matrix}
    0 & n = 0 \\
    1 & n = 1 \\
    F_{n-1} + F_{n-2} & n > 1
   \end{matrix}
   \right.
\end{align}
で定義される数であり、
フィボナッチ数の列 $F_0, F_1, \dots, F_n, \dots$ をフィボナッチ数列と呼びます。

#+caption: comet/fib.cas
#+label: fig:comet/fib.cas
#+include: "code/comet/fib.cas" src casl

一般的なプログラミングの教科書では、
最初のほうにループ (繰り返し) を学びます。
その後、
関数呼び出しなどを学んだあとに、
再帰によるプログラミングを学びます。
そういったこともあり、
なんとなく繰り返しのほうが単純で簡単で、
再帰はより高級で複雑な概念のような印象を持ちます。

しかし実際には、
多くの場合、
繰り返しのほうが読むのも書くのも大変です。
再帰は一見難しそうですが、
非常にすっきりしており、
いったん再帰という概念を理解すれば比較的簡単に書けます。

繰り返しと再帰の特徴をまとめると以下のようになります。
- 繰り返しによるプログラミング
  - コンピュータによる実現が簡単で、実行も速い
  - 人間にとっては読むのも書くのも大変 (1 重ループくらいなら簡単だが、
    2 重ループ以上になると急に難しくなる)
- 再帰によるプログラミング
  - コンピュータによる実現は大変で、実行も遅い
  - 人間にとっては読むのも書くのも簡単

繰り返しがコンピュータにとって実現が簡単で、
実行も高速である理由は、
アセンブリ言語でどのような記述になるかを考えればわかります。
アセンブリ言語で繰り返しを記述するためには、
ループの継続・終了を判定する比較命令と、
ループを継続するときにループの先頭に戻るジャンプ命令だけがあれば実現できます。
フォン・ノイマン型のコンピュータは、
もともと繰り返し処理が得意である、
と言うこともできます。

再帰がコンピュータにとって実現が大変で、
実行も遅い理由も、
アセンブリ言語でどのような記述になるかを考えればわかります。
アセンブリ言語で再帰を記述するためには、
関数呼び出しで実現することになります。
関数呼び出しでは、
関数の呼び出し元から呼び出し先に対して、
毎回引数を渡す必要があります。
また、
関数の呼び出し元は、
関数からの返り値を毎回受け取る必要があります。
引数をスタックに積む場合は、
そのつどスタックへの書き込み (メモリへの書き込み) が発生します。
レジスタの操作と比較すると、
メモリへの書き込みは圧倒的に低速です。
呼び出し元から関数への引数をレジスタで渡す場合であっても、
CALL 命令で関数呼び出しをするため、
スタックに毎回リターンアドレスを積む必要があります。

さらに再帰呼び出しでは、
再帰呼び出しの深さに制限があります。
スタックの大きさは有限であり、
何度も何度も再帰呼び出しを繰り返すと、
スタックが不足してしまう可能性があります。

例えば、
以下のようなプログラム (図 [[fig:comet/recursion.cas]]) を実行してみます。

#+caption: comet/recursion.cas
#+label: fig:comet/recursion.cas
#+include: "code/comet/recursion.cas" src casl

#+begin_src raw
$ casl recursion.cas
$ comet recursion.com
This is COMET, version 1.0.
Copyright (c) 2021, Hiroyuki Ohsaki.
All rights reserved.
Reading object from recursion.com...done.
PR  #0000 [CALL #0003 <FUNC>                  ] SP  #ffff  OF 0  SF 0  ZF 0
GR0 #0000 (     0) GR1 #0000 (     0) GR2 #0000 (     0) GR3 #0000 (     0)
GR4 #0000 (     0) GR5 #0000 (     0) GR6 #0000 (     0) GR7 #0000 (     0)
comet> c
Stack exhasuted.  Program execution suspended.
PR  #0003 [CALL #0003 <FUNC>                  ] SP* #0005  OF 0  SF 0  ZF 0
GR0 #0000 (     0) GR1 #0000 (     0) GR2 #0000 (     0) GR3 #0000 (     0)
GR4 #0000 (     0) GR5 #0000 (     0) GR6 #0000 (     0) GR7 #0000 (     0)
comet>
#+end_src
continue コマンドを実行すると、
しばらくした後で「Stack exhasuted.」というメッセージを表示して停止します。
スタックポインタ (SP レジスタ) の値が 0x0005 になっています。
スタックが大きくなりすぎて、
プログラム領域まで侵食しかけていることがわかります。

このように、
再帰はコンピュータにとっては大変ですが、
プログラマにとっては繰り返しよりずっと簡単です。
フィボナッチ数を求めるプログラム ~fib.cas~ を読んでみてください。
アセンブリ言語のため読みづらいと思いますが、
それでも再帰のプログラムであるため読み解けると思います。

*** 再帰呼び出しのサンプル (ハノイの塔)

最後にもう 1 つ再帰のプログラムです。
これもプログラミングにおける典型的な題材である *ハノイの塔* です。
本書の読者であれば一度はハノイの塔のプログラムを見たことがあると思いますので、
ここではハノイの塔の要点をごく簡単に説明します。

ハノイの塔とは有名なパズルの一種です。
垂直に棒が 3 本立っていて、
そのうちの 1 本の棒に、
輪になった円盤が N 枚通されています。
N 枚の円盤はそれぞれ大きさ (半径) が異なっており、
大きい円盤が下に、
小さい円盤が上になるように積まれています。
この N 枚の円盤を、
あるルールに従って別の棒に移動させます。
ただし、
円盤は一度に 1 枚だけ、
ある棒から他の棒に移動させることができ、
小さい円盤の上に大きい円盤を (たとえ一時期であっても) 積むことはできません。

ハノイの塔は、
再帰によって解くことができます。

3 本の棒を A、
B、
C とし、
棒 A に N 枚の円盤が通されているとします。
N 枚の円盤を A から B に移動するという問題を hanoi(N, A, B, C) と表記します。

hanoi(N, A, B, C) は以下のように再帰的に解くことができます。

1. 上から N - 1 枚の円盤を A から C に移動する (つまり、hanoi(N - 1,
   A, C, B) を解く)
2. 一番下の (一番大きい) 円盤を A から B に移動する
3. C に通されている N - 1 枚の円盤を C から B に移動する (つまり、
   hanoi(N - 1, C, B, A) を解く)

上のアルゴリズムを素朴に実装した C 言語のプログラムを示します (図 [[fig:comet/c/hanoi.c]])。

#+caption: comet/c/hanoi.c
#+label: fig:comet/c/hanoi.c
#+include: "code/comet/c/hanoi.c" src C

このプログラムを眺めながら、
次のアセンブリ言語プログラム (図 [[fig:comet/hanoi.cas]]) を読んでみてください。

#+caption: comet/hanoi.cas
#+label: fig:comet/hanoi.cas
#+include: "code/comet/hanoi.cas" src casl

** C コンパイラを利用した CASL II プログラミング

上で示した CASL II のアセンブリ言語プログラムは、
筆者が本書のために新たに書いたものです。

筆者はそれなりにアセンブリ言語でのプログラミングには慣れているつもりですが、
それでも少し複雑なプログラムになるとアセンブリ言語で書くのは大変です。

[[sec:comet/reading]] 節で紹介したプログラムは、
C コンパイラが生成したアセンブリ言語のプログラムをもとに作成しました。
ただし、
CASL II のアセンブリ言語を出力する (なおかつ高品質なコードを生成する) C コンパイラが手に入らなかったため、
以下のような方法を採りました。

1. CASL II で書きたいプログラムを、まず C 言語で作成し、動作確認する。
2. C コンパイラがアセンブリ言語向きのコードを生成するようにプログラム
   を改変する。
3. C 言語で書かれたプログラムをコンパイルし、x86 向けのアセンブリ言語
   プログラムを生成する。
4. 簡単なフィルタを作成し、x86 向けのアセンブリ言語プログラムを CASL
   II 風に変換する。
5. 変換したプログラムを手直しして、冗長なコードを削除するなどして完成
   させる。

実際に例を示しましょう。
例は何でもいいのですが、
あまり簡単すぎないものとして、
*エラストテネスのふるい (篩)* を実装してみます。

エラストテネスのふるいとは、
ある値以下のすべての素数 (prime number) を見つける古典的なアルゴリズムです。
アルゴリズムの概要は以下のとおりです。
1. 2〜N までの数のリストを用意する (素数の候補)。
2. N 以下である、すべての 2 の倍数 (4、6、8……) をリストから削除する
   (ただし 2 は削除しない)。
3. N 以下である、すべての 3 の倍数 (3、6、9……) をリストから削除する
   (ただし 3 は削除しない)。
4. リストに残っている他の数に対して、小さな数から順番に同じ操作を繰り
   返す。

エラストテネスのふるいは、
#+begin_quote
2〜N までの数のリストから、
「素数でないもの」をどんどんふるい落としてゆき、
最後まで残ったものが素数である
#+end_quote
という考え方にもとづいています。

**** CASL II で書きたいプログラムを、まず C 言語で作成し、動作確認する。

まず、
C 言語でエラストテネスのふるいを実装します (図 [[fig:comet/c/erastos.c]])。
この段階から、
アセンブリ言語のプログラムに変換したときに、
できるだけ素直なプログラムになるように意識して書きます。
C 言語で書かれたプログラムとしての美しさではなく、
機械語に変換されたときの素直さに重点を置きます。

#+caption: comet/c/erastos.c
#+label: fig:comet/c/erastos.c
#+include: "code/comet/c/erastos.c" src C

**** C コンパイラがアセンブリ言語向きのコードを生成するようにプログラムを改変する。

コンパイルして、
正しく動作することを確認したら、
次は C コンパイラが、
より単純なアセンブリ言語のプログラムを生成するように手を加えます (図 [[fig:comet/c/erastos2.c]])。

#+caption: comet/c/erastos2.c
#+label: fig:comet/c/erastos2.c
#+include: "code/comet/c/erastos2.c" src C

上の例では、
変数宣言に register キーワードを付けて、
変数を (メモリではなく) できるだけレジスタに割り当てるように C コンパイラに指示しています。
また、
「if (A[i] == 1)」という条件判定を、
より単純な「if (A[i])」に置き換えています。

**** C 言語で書かれたプログラムをコンパイルし、x86 向けのアセンブリ言語プログラムを生成する

C コンパイラによってコンパイルし、
アセンブリ言語のプログラムを得ます。
#+begin_src raw
$ gcc -S -masm=intel -fno-pic -fomit-frame-pointer erastos2.c
#+end_src
できるだけ単純なアセンブリ言語プログラムが得られるように、
~-fno-pic~ オプション (位置依存コードを生成しない)、
~-fomit-frame-pointer~ オプション (フレームポインタを生成しない) を指定しています。
さらに、
CASL II のアセンブリ言語により近いアセンブリ言語を生成するために、
~-masm=intel~ オプションを指定してインテル構文のアセンブリ言語プログラムを生成しています。

これによって以下のような IA-32 アーキテクチャ向けのアセンブリ言語プログラム (図 [[fig:comet/c/erastos2.s]]) が得られます。

#+caption: comet/c/erastos2.s
#+label: fig:comet/c/erastos2.s
#+include: "code/comet/c/erastos2.s" src asm

このプログラムを、
CASL II のアセンブリ言語プログラムに移植します。

**** 簡単なフィルタを作成し、x86 向けのアセンブリ言語プログラムを CASL II 風に変換する

IA-32 アーキテクチャ向けの命令を 1 つずつ手作業で変換してもよいのですが、
IA-32 アーキテクチャ向けの GAS (インテル構文) のプログラムと CASL II のプログラムを見比べて、
簡単なフィルタを Perl 言語で作成しました。

#+caption: comet/c/x86-to-casl
#+label: fig:comet/c/x86-to-casl
#+include: "code/comet/c/x86-to-casl" src perl

単純な文字列のパターンマッチによって、
IA-32 アーキテクチャ向けのアセンブリ言語プログラムを、
CASL II のアセンブリ言語に近づけています。

以下のように実行すれば、
「CASL II 風」のアセンブリ言語プログラム (図 [[fig:comet/c/erastos2.ss]]) が得られます。
#+begin_src casl
$ ./x86-to-cas erastos2.s
#+end_src

#+caption: comet/c/erastos2.ss
#+label: fig:comet/c/erastos2.ss
#+include: "code/comet/c/erastos2.ss" src casl

**** 変換したプログラムを手直しして、冗長なコードを削除するなどして完成させる

ここからは手作業です。
CASL II/COMET II として正しいアセンブリ言語プログラムになるように修正します。
機械的に変換するだけでも動作するアセンブリ言語プログラムになりますが、
さらにキレイなコードになるようにあちこち手を入れました (図 [[fig:comet/erastos.cas]])。

#+caption: comet/erastos.cas
#+label: fig:comet/erastos.cas
#+include: "code/comet/erastos.cas" src casl

以下のような点を修正しています。
- 関数 ~main~ におけるスタックフレームの操作は不要なのですべて削除
- スタック上に確保した領域を一時変数として使っている箇所を、レジスタを
  使うように書き換え
- プログラムのロジックを変えずにプログラムを簡単化
  - IA-32 アーキテクチャの MOV 命令はフラグレジスタを変えないが、COMET
    II のLD 命令はフラグレジスタを変えるため、一部の (冗長な) 比較命令
    を削除
  - GCC が生成したプログラムは細かく分断されているが、元の C 言語のプ
    ログラムのロジックに沿った順番に並び換え
  - これによって、条件ジャンプ命令の数を減らした
  - 使用するレジスタ数を 4 から 2 に減らした

なお、
求まった素数の値を 10 進数で表示するために、
[[sec:comet/reading]] 節で紹介した ~prtdec.cas~ プログラムをそのまま使用しています。

当然、
ある程度の手間はかかりますが、
ゼロから CASL II のアセンブリ言語のプログラムを書くよりははるかに少ない手間で書くことができました。
実際にはどのようなプログラムなのかにもよりますが、
ゼロから CASL II のアセンブリ言語のプログラムを書く場合と比べて、
1/3 くらいの時間で書けるでしょう。

** 章末問題
<<sec:comet/quiz>>

1. COMET II の仕様書 \cite{IPA19:COMET} を入手せよ。

2. レジスタ GR1 の値を、レジスタ GR2 と GR3 の両方にコピーするアセンブ
   リ言語プログラムを示せ。

   #+begin_answer
   プログラムの例: ~copy.cas~ (図 [[fig:comet/ex/copy.cas]])
   #+caption: comet/ex/copy.cas
   #+label: fig:comet/ex/copy.cas
   #+include: "code/comet/ex/copy.cas" src raw
   #+end_answer

3. レジスタ GR1 の値の下位 8 ビットを、レジスタ GR2 の下位 8 ビットに
   コピーするアセンブリ言語プログラムを示せ。ただし、レジスタ GR2 の上
   位 8 ビットは変化させないこと。

   #+begin_answer
   COMET II には上位バイトや下位バイトを操作する命令はないため、
   AND 命令によって上位 8 ビットや下位 8 ビットを取り出し、
   OR 命令によってそれらのビットごとの論理和を計算する。

   プログラムの例: ~copy-low.cas~ (図 [[fig:comet/ex/copy-low.cas]])
   #+caption: comet/ex/copy-low.cas
   #+label: fig:comet/ex/copy-low.cas
   #+include: "code/comet/ex/copy-low.cas" src raw
   #+end_answer

4. 123 + 456 を計算するアセンブリ言語プログラムを示せ。

   #+begin_answer
   プログラムの例: ~add.cas~ (図 [[fig:comet/ex/add.cas]])
   #+caption: comet/ex/add.cas
   #+label: fig:comet/ex/add.cas
   #+include: "code/comet/ex/add.cas" src raw
   #+end_answer

5. (123 + 456) ~>>~ 3 (~>>~ は右へのビットシフト) を計算するアセンブリ
   言語プログラムを示せ。

   #+begin_answer
   プログラムの例: ~add-shift.cas~ (図 [[fig:comet/ex/add-shift.cas]])
   #+caption: comet/ex/add-shift.cas
   #+label: fig:comet/ex/add-shift.cas
   #+include: "code/comet/ex/add-shift.cas" src raw

   COMET II では SRA 命令のオペランドにシフトするビット数を指定できる。
   今回のプログラムでは、
   123 + 456 の値は正なので、
   符号なし整数のための SRL 命令でもよい。
   #+end_answer

6. レジスタ GR1 の値 (符号なし整数) が 123 以上であればレジスタ GR2 を
   1 にし、そうでなければ 0 にするアセンブリ言語プログラムを示せ。

   #+begin_answer
   プログラムの例: ~cmp.cas~ (図 [[fig:comet/ex/cmp.cas]])
   #+caption: comet/ex/cmp.cas
   #+label: fig:comet/ex/cmp.cas
   #+include: "code/comet/ex/cmp.cas" src raw

   「レジスタ GR1 の値が 123 未満であれば、
   レジスタ GR2 の値を 1 にする処理をスキップする」というロジックで書いている。
   #+end_answer

7. レジスタ GR1 の値を 4 倍するアセンブリ言語プログラムを示せ。

   #+begin_answer
   プログラムの例: ~quad.cas~ (図 [[fig:comet/ex/quad.cas]])
   #+caption: comet/ex/quad.cas
   #+label: fig:comet/ex/quad.cas
   #+include: "code/comet/ex/quad.cas" src raw

   COMET II には乗算命令はないが、
   2 のべき乗の乗算であれば左へのビットシフトで実現できる。
   #+end_answer

8. 「1 - 2 + 3 - 4 + \dots + 99 - 100」を計算するアセンブリ言語プログ
   ラムを示せ。

   #+begin_answer
   プログラムの例: ~sum.cas~ (図 [[fig:comet/ex/sum.cas]])
   #+caption: comet/ex/sum.cas
   #+label: fig:comet/ex/sum.cas
   #+include: "code/comet/ex/sum.cas" src raw

   レジスタ GR2 をループカウンタとして使用している。
   レジスタ GR2 の値が奇数か偶数かによって加算か減算かを切り替える必要がある。
   COMET II にはレジスタの特定のビットをテストする命令はないので、
   レジスタ GR2 の値をいったんレジスタ GR3 にコピーし、
   AND 命令によって最下位ビットを取り出している。
   最下位ビットがレジスタ GR2 の値の奇数・偶数を表している。
   #+end_answer
