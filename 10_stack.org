# -*- Org -*-
# 
# Copyright (c) 2021, Hiroyuki Ohsaki.
# All rights reserved.
# 

# This document is licensed under a Creative Commons
# Attribution-NonCommercial-ShareAlike 4.0 International License (CC
# BY-NC-SA 4.0).

# This document is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# Creative Commons License for more details.

# You should have received a copy of the license along with this work.
# If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

* コンピュータの構造: スタック
<<ch:stack>>

** CPU とスタック
<<sec:stack/cpu-and-stack>>

これまで説明してきたように、
フォン・ノイマン・アーキテクチャのコンピュータでは、
CPU、
メモリ、
入出力デバイスが、
バスを介して接続されています。

CPU 内部の制御装置が、
メモリの値をレジスタに読み出したり、
ALU を利用して算術演算や論理演算を行ったり、
レジスタの値を書き換えたり、
レジスタの値をメモリに書き込んだりすることで複雑な処理が実現されています。

これらの処理をうまく組み合わせれば、
(コンピュータで実現できる処理ならば) どんな処理でも実現できます。
ただし、
ここまで紹介してきたような処理はあまりにも *プリミティブ (primitive; 原始的)* であり、
現実に利用されている CPU は、
もう少し高度な処理も実行することができます。

現在の CPU の多くでは、
スタックに関する処理が 1 命令で実行できるようになっています。
まず、
スタックとは何かの説明から始めましょう。

** データ構造としての「スタック」
<<sec:stack/data-struct>>

*スタック (stack)* とは、
コンピュータサイエンスにおける代表的な *データ構造 (data structure)* の 1 つです。
コンピュータの多くは、
内部にスタックを実現する記憶装置 (= メモリの一部) を持っていて、
その記憶装置 (= メモリの一部) のことを指してスタックと呼ぶこともあります。
ただし、
本来「スタック」とは、
コンピュータサイエンスにおけるデータ構造のことを意味します。

コンピュータサイエンスにおける代表的なデータ構造としては、
配列 (array)、
リスト (list)、
ツリー (tree)、
ハッシュ (hash) などが存在します。
スタックは、
これらのデータ構造と、
同じくらい代表的で、
同じくらい重要なデータ構造です。

英語の stack には、
「積み重ねる」という意味の動詞と、
「積み重ねられたもの」という意味の名詞の両方があります。
データ構造におけるスタックとは、
「データを積み重ねたもの」という意味です (図 [[fig:stack/stack]])。

#+caption: スタックの例
#+label: fig:stack/stack
#+attr_latex: :width \textwidth
[[./figure/stack/stack.png]]

データを格納する場合は、
データを上に、
上にと順番に積み重ねてゆきます。
データを格納するほど、
スタック (データを積み重ねたもの) がどんどん高くなってゆきます。
一方、
データを取り出す場合は、
スタックの一番上のデータを取り出します。
データを取り出せば取り出すほどスタックが低くなってゆきます。

スタックの動作例を図 [[fig:stack/stack]] を用いて説明します。

まず、
初期状態でスタックは空の状態です。
最初に、
データ 0x12 を格納すると、
スタック上に 0x12 が格納されます (「0x12 がスタックに *積まれる*」とも言います)。
次に、
0x34 を格納すると、
先ほど格納した 0x12 の上に 0x34 が格納されます (0x34 がスタックに積まれます)。
さらに、
0x56 をスタックに積むと、
スタックの高さが 3 になります。

その後、
スタックの一番上の値 (0x56) を取り出しています。
これによって、
スタックの高さが一段低くなって 2 になります。
同様に、
スタックから 0x34、
0x12 が取り出されて、
スタックが空の状態に戻ります。
スタックに 0x78、
0x9a が順番に積まれて、
最後にはスタックの高さが 2 になります。

このようにスタックにデータを格納すること (データを積むこと) を *プッシュ (push)* と呼び、
スタックからデータを取り出すことを *ポップ (pop)* と呼びます。

#+begin_note
データを積むなら「スタック (stack)」で、
データをスタックから取り出すなら「アンスタック (unstack)」というのが英語としては正しい表現と思われますが、
歴史的経緯により「プッシュ」と「ポップ」と呼ばれています。

「プッシュ」と「ポップ」の由来は、
学生食堂や社員食堂などに置かれている、
「トレー用ディスペンサー」のようです (図 [[fig:stack/dispencer]])。

トレー用ディスペンサーとは、
トレーを重ねて保管・運搬するための機器です。
内部にバネが入っており、
一番上のトレーを取り出すと、
置いたトレーが上昇します。
逆に、
一番上にトレーを置くと、
置いたトレーが少し沈みます。

英語では、
トレー用ディスペンサーにトレーを置くことを「プッシュ (push)」と呼び、
トレー用ディスペンサーのトレーを取ることを「ポップ (pop)」と呼ぶそうです。
ここから、
スタックからデータを格納する操作をプッシュと呼び、
スタックからデータを取り出す操作をポップと呼ぶようになったそうです。
#+end_note

#+caption: トレー用ディスペンサーの例 (https://assets.katomcdn.com/q_auto,f_auto/products/121/121-2818/121-2818.jpg)
#+label: fig:stack/dispencer
#+attr_latex: :width .5\columnwidth
[[./figure/stack/dispencer.jpg]]

スタックでは、
データをポップする (取り出す) と、
一番最近にプッシュされた (格納された) データが得られます。
つまり、
スタックは
#+begin_quote
最後に入ったデータが最初に出てくる
#+end_quote
という性質を持っています。
この性質を、
英語で *LIFO (Last-In First-Out)* と呼びます。
LIFO は、
非常によく使われる表現なので覚えておきましょう。

LIFO の逆が、
#+begin_quote
最初に入ったデータが最初に出てくる
#+end_quote
を意味する *FIFO (First-In First-Out)* です。
FIFO の性質を持つデータ構造の代表例が *キュー (queue; 待ち行列)* です。
LIFO の性質を持つデータ構造の代表例がスタックです。

#+begin_note
上の例では簡単のため、
1 バイト (8 ビット) 単位のデータをスタックに格納する場合を示しています。
実際には、
8 ビット、
16 ビット、
32 ビット、
64 ビットなど、
さまざまな大きさのデータが混在して扱われます。

ただし、
16 ビットの値をスタックに積むことは、
8 ビットの値を 2 回スタックに積むことと基本的には同じです。
32 ビットの値をスタックに積むことは、
8 ビットの値を 4 回スタックに積むことと基本的には同じです。

例えば、
0x1234 5678 という 32 ビットの値をスタックに積む場合は、
CPU のエンディアンネスや、
スタックの伸長方向 (アドレスが小さくなる方向/アドレスが大きくなる方向) によって、
0x12、
0x34、
0x56、
0x78 の順番にスタックに積まれたり、
0x78、
0x56、
0x34、
0x12 の順番にスタックに積まれたりすることになります。
#+end_note

もう一度、
要点を整理しておきましょう。
スタックとは単なるデータ構造のことを意味します。
前述のように、
コンピュータの多くは内部にスタックを実現するための記憶装置 (メモリ) を持っています。
その記憶装置 (= メモリ) のことを差してスタックと呼ぶこともあります。
また、
以下で説明するように、
多くの CPU は、
スタックを操作するための専用のレジスタや専用の命令を持っています。

ただし、
一般的には、
コンピュータがスタックという名前のハードウェア装置を持っているのでも、
CPU の内部にスタックというハードウェア装置が入っているのでもありません。
#+begin_quote
スタックとは単なるデータ構造であり、
(ほとんどの場合) CPU とメモリを駆使してスタックを実現している
#+end_quote
という関係を正しく理解してください。

#+begin_note
数は少ないですが、
中にはスタックのためのハードウェアを持っているコンピュータや CPU もあります。
#+end_note

** CPU とメモリによるスタックの実現
<<sec:stack/realization>>

CPU はメモリの値をレジスタに読み出したり、
ALU を利用して算術演算や論理演算を行ったり、
レジスタの値を書き換えたり、
レジスタの値をメモリに書き込んだりすることができます。
これらの処理を組み合わせれば、
複雑な処理を実現することができます。

CPU の基本的な命令だけで複雑な処理が実現できるということは、
もちろんスタックも実現できます。

スタックはメモリの領域の一部を利用して実現できます (図 [[fig:stack/layout]])。

#+caption: スタックの領域確保の例
#+label: fig:stack/layout
#+attr_latex: :width .5\columnwidth
[[./figure/stack/layout.png]]

図 [[fig:stack/layout]] は、
メモリの前半に *プログラム (program)* を格納し、
メモリの中央に *データ (data)* 領域を確保し、
メモリの後半に *スタック (stack)* のための領域を割り当てた例を示しています。
このメモリマップでは、
下位アドレスが上に、
上位アドレスが下に書かれていることに注意してください。
スタックの底 (bottom) が最上位アドレス 0xffff ffff です。
スタックに値をプッシュすると、
スタックは上位アドレスから下位アドレスに向けて (0xffff ffff から 0x0000 0000 に向けて) 伸びていきます。

[[sec:mem/cpu-model]] 節で導入した、
CPU 処理の抽象モデルを用いてスタックの実現法を説明しましょう。

- スタックにレジスタ \r{i} の値をプッシュする
  #+begin_quote
  \sp   ← <-> 4 \\
  \relax [\sp] ← \r{i}
  #+end_quote

  ここで、
  \sp はスタックポインタ (スタックの先頭を表すレジスタ) です。
  ここでは、
  メモリのアドレスがバイト単位で、
  レジスタの大きさが 4 バイトの場合の例を示しています。

  スタックポインタ \sp の値を 4 バイト減少させ、
  スタックポインタが指すアドレスに、
  レジスタ \r{i} の値を格納しています。
  スタックの一番上に、
  レジスタ \r{i} の値を「積み重ねて」います。

- スタックの値をレジスタ \r{i} にポップする
  #+begin_quote
  \r{i} ← [\sp] \\
  \sp ← <+> 4
  #+end_quote

  先ほどと同様に、
  \sp はスタックポインタ (スタックの先頭を表す  レジスタ) です。
  また、
  メモリのアドレスがバイト単位で、
  レジスタの大きさが 4 バイトの場合の例を示しています。

  スタックポインタが指すアドレスに格納されている値をレジスタ \r{i} に読み込んだあと、
  スタックポインタの値を 4 バイト増加させています。
  スタックの一番上に格納されている値を「取り出し」、
  その値をレジスタ \r{i} に格納しています。

スタックの基本はこれだけです。

スタックは非常に有用なデータ構造なので、
多くの CPU は、
スタックを操作するための専用のレジスタや専用の命令を持っています。

例えば、
IA-32 アーキテクチャでは、
汎用レジスタ ESP がスタックポインタとして使用されます。
さらに、
\inst{push %eax} という一命令で、
レジスタ EAX の値をスタックにプッシュできます。
つまり、
\inst{push %eax} という一命令で、
#+begin_src asm
esp   ← <-> 4	# レジスタ ESP の値を -4 する
(esp) ← eax	# スタックのトップにレジスタ EAX の値を書き込む
#+end_src
という処理が実行できます。

同様に、
\inst{pop %eax} という 1 命令で、
スタックの値を取り出してレジスタ EAX に格納できます。
つまり、
\inst{pop %eax} という 1 命令で、
#+begin_src asm
eax   ← (esp)	# スタックのトップ (レジスタ ESP が指すアドレス) の値をレジスタ EAX に読み込む
esp   ← <+> 4	# レジスタ ESP の値を +4 する
#+end_src
という処理が実行できます。

#+begin_note
IA-32 アーキテクチャでは、
レジスタ ESP は汎用レジスタ (general-purpose register) に分類されていますが、
基本的にスタックポインタとしてのみ用いられます。
#+end_note

ただし、
フォン・ノイマン・アーキテクチャにはスタックという概念は *含まれていない* ことに注意してください。
上述のように、
フォン・ノイマン・アーキテクチャのコンピュータであればスタックを実現できますが、
もともとのフォン・ノイマン・アーキテクチャには、
スタック専用のレジスタや、
スタック専用の命令という考え方は含まれていません。

** スタックは高速ではない
<<sec:stack/not-fast>>

さて、
ここでスタックの効率性を考えてみましょう。

スタックは非常に有用なデータ構造ですし、
スタックを使えば複雑な処理を簡潔に記述することができます。
ただし、
CPU がスタックを操作するための専用レジスタや専用命令を持っている場合でも、
あくまでスタック本体は *メモリ上に確保された領域にすぎない* 点に注意が必要です。

レジスタは CPU の内部にあるため、
レジスタどうしの演算は極めて高速です。
しかし、
メモリは CPU の外部にあり、
CPU は、
バスを介してメモリと通信することでデータの読み書きを行います。

このため、
レジスタへのアクセスと比較すると、
メモリへのアクセスは *圧倒的に低速* です。
コンピュータのアーキテクチャにもよりますが、
レジスタへのアクセスと比較すると、
メモリへのアクセスは 100 倍くらい遅くなります。
スタックはメモリ上に確保されているので、
レジスタへのアクセスと比較すると、
スタックへのプッシュやポップは圧倒的に「遅い」操作です。

** スタックによる関数呼び出しの実現
<<sec:stack/funcall>>

スタックは単なるデータ構造なので、
スタックをどのように利用してもかまいません。

実際のところ、
アセンブリ言語によるプログラミングにおける、
スタックの代表的な利用法は以下の 2 つです。
- 計算結果の一時保存
- 関数呼び出しの実現

1 つ目は、
計算結果をスタックに一時保存するという用法です。

[[sec:mem/cpu-model]] 節で述べたように、
複雑な計算を行うとレジスタの数が不足してしまいます。
しかし、
スタックを利用すれば、
計算の途中結果をスタックに退避できるため、
レジスタ数の不足を回避できます。
スタックは (CPU 内部に存在するレジスタとは異なり) メモリ上に確保されるので、
広大なメモリ空間を活用することができます。

2 つ目は、
*関数 (function)* や *サブルーチン (subroutine)* と呼ばれる、
小さなひとまとまりのプログラムを実現するためにスタックを利用するという用法です。

関数やサブルーチンは、
機械語やアセンブリ言語以外のプログラム言語では、
*サブプログラム (subprogram)*、
*手続き (procedure)*、
*モジュール (module)* などと呼ばれることもあります。

アセンブリ言語プログラミングにおける「関数」は、
サブルーチン、
サブプログラム、
手続き、
モジュールなどと同じ意味で用いられます。
アセンブリ言語プログラミングにおける「関数」と数学における「関数」は、
似てはいるものの、
違うものです。
数学における関数は、
例えば以下のようなものです。
\begin{align}
  f(x) = 2 x (x - 1)^2
\end{align}
$x$ の値が決まると、
$f(x)$ の値が決まります。
例えば、
$x = 0.1$ であれば、
$f(0.1) = 0.162$ のように値が決まります。
$f(x)$ の値は、
今日計算しても、
明日計算しても、
必ず同じ値になります。
コンピュータサイエンスでは、
上記のような関数は *純粋関数 (pure function)* と呼ばれます。

プログラミングにおける関数は、
小さなひとまとまりのプログラムです。
関数 ~f(x)~ があった場合に、
~f(0.1)~ を実行すると、
数学の関数のように 0.162 のような値が返ってくるかもしれません。
ただし、
必ずしも値が返ってくる必要はなく、
~f(0.1)~ を呼び出すと、
スピーカから小さな声で「ニャー」と鳴き声がするかもしれません。
同様に、
~f(10)~ を実行するとスピーカから大きな声で「*ニャー*」と鳴き声がするかもしれません。
関数の呼び出しによって、
返り値を返す以外の処理が行われる場合、
その処理を *副作用 (side effect)* と呼びます。

このように、
プログラミングにおける関数は、
- 引数 (パラメータ) を受け取るかもしれないし、受け取らないかもしれない
- 返り値を返すかもしれないし、返さないかもしれない
- 副作用があるかもしれないし、ないかもしれない
というものです。

ところで、
英語の function には
#+begin_quote
1. [C, U] the action or purpose that sb/sth has in a particular situation; the
   ability that sb/sth has to perform a particular job or role
2. [C] function (of sth) (mathematics) a quantity whose value depends on the
   varying values of others. In the statement 2 x = y, x is a function of y.
3. [C] a part of a computer program or system that performs a basic operation
4. [C] a social event or official ceremony
#+end_quote
のような意味があります \cite{OLDA}。
数学の function は上記の 2.の意味ですが、
プログラミングにおける function は上記の 3.の意味です。
そのことから、
日本語では「関数」よりも、
「機能」や「ファンクション」などの言葉のほうが、
プログラミングにおける function のイメージに近いといえるでしょう。

では、次に関数の例を示します。

例えば、階乗
\begin{align}
  n! = n \cdot (n - 1) \cdot \dots \cdot 2 \cdot 1
\end{align}
を計算するプログラムを C 言語で書くと以下のようになります (図 [[fig:stack/fact.c]])。

#+caption: stack/fact.c
#+label: fig:stack/fact.c
#+include: "code/stack/fact.c" src C

この例では、
関数 ~fact~ が階乗を計算するひとまとまりのプログラムです。
関数 ~main~ から、
#+begin_src
n = fact(8);
#+end_src
のように、
引数 8 を与えて関数 ~fact~ を呼び出します。
関数 ~fact~ が返す値 (実行すると $8! = 40 320$ になります) を関数 ~printf~ を使って標準出力に表示しています。

機械語やアセンブリ言語でも、
C 言語と同じように、
ひとまとまりのプログラムを関数として定義し、
他のプログラムから呼び出すことができます。

#+begin_note
正確に言えば、
この説明は順序が逆です。
歴史的には、
より古くから存在する機械語やアセンブリ言語において関数やサブルーチンが先に登場し、
それと同じ概念を、
あとから登場した C 言語や Java 言語でも記述できるようになりました。
#+end_note

関数呼び出しを実現するためには、
以下の 3 つの問題を解決する必要があります。
1. 呼び出し元にどのように戻るか (*リターンアドレス (return address)*
   の管理)
2. 呼び出し元から関数に *引数 (parameter)* をどのように渡すか
3. 関数から呼び出し元に *返り値 (return value)* をどのように渡すか

コンピュータ内部で情報を保存できるのはレジスタとメモリしかありません。
したがって、
情報の受け渡しに「レジスタを使う」か、
「メモリを使う」かの二者択一になります。

レジスタを使って、
呼び出し元と関数との間で情報の受け渡しをしてもよいのですが、
レジスタの数には限りがあります。

そこで考えられる素朴な解法は、
上記の 1.および 2.にメモリを使うというものです。
上記の 3.には、
関数から返り値の数によって、
レジスタやメモリを使い分けます。

スタックを使えば、
上記の 1.および 2.を非常にスマートに実現できます (図 [[fig:stack/call]])。
関数は、
呼び出し元のプログラム P が関数 A を呼び、
そこからまた関数 A が別の関数 B を呼び、
その先でまた関数 B が別の関数 C を呼び……という入れ子の関係になります。

#+caption: スタックによる関数呼び出しの実現の例
#+label: fig:stack/call
#+attr_latex: :width \textwidth
[[./figure/stack/call.png]]

この場合、
- 関数 C の処理が完了したら、呼び出し元である関数 B に戻る
- 関数 B の処理が完了したら、呼び出し元である関数 A に戻る
- さらに、関数 A の処理が完了したら、呼び出し元であるプログラム P に戻る
といったように、
呼び出した順序とは逆の順序で、
順番に呼び出し元に戻ることになります。
#+begin_quote
最後の呼び出し元に、
最初に戻る
#+end_quote
のですから、
まさに LIFO (Last-In First-Out) になっています。

[[sec:mem/cpu-model]] 節で導入した CPU の抽象モデルで関数呼び出しの実現法を説明します。

*** 呼び出し元にどのように戻るか

まず、
呼び出し元のプログラムでは、
リターンアドレスをスタックにプッシュして、
単純に関数にジャンプすれば実現できます。
#+begin_src asm
# 呼び出し元のプログラム
        :
        :
    push    リターンアドレス # 関数呼び出し
    pc  ← 関数のアドレス
        :   # ← ここがリターンアドレス
        :
#+end_src
ここで \inst{push c} は、
定数 $c$ をスタックにプッシュする命令を意味します。
\pc はプログラムカウンタ (次に実行すべき命令を格納するレジスタ) です。
「リターンアドレス」には、
「\pc ←関数のアドレス」の次の命令が格納されているアドレスを指定します。
「関数のアドレス」には、
呼び出したい関数の開始アドレスを指定します。

関数から呼び出し元のプログラムに戻るには、
スタックからリターンアドレスを取り出して、
そのアドレスにジャンプすれば実現できます。
#+begin_src asm
# 関数のプログラム
        :
        :
    pop pc      # 呼び出し元に戻る
#+end_src

関数呼び出しは頻繁に行なわれる処理なので、
多くの CPU は関数呼び出しのための専用命令を持っています。

例えば、
IA-32 アーキテクチャでは、
#+begin_src asm
    call    アドレス
#+end_src
という 1 命令で、
リターンアドレスをスタックにプッシュし、
指定された「アドレス」にジャンプできます。
また同様に、
#+begin_src asm
    ret
#+end_src
という 1 命令で、
スタックからリターンアドレスを取り出して、
そのアドレスにジャンプできます。

#+begin_note
[[sec:cpu/ia32-register]] 節で述べたように、
IA-32 アーキテクチャでは、
プログラムカウンタはレジスタ EIP であり、
スタックポインタにはレジスタ ESP が用いられます。
#+end_note

*** 呼び出し元から関数に引数をどのように渡すか

リターンアドレスを受け渡しする時と同じように、
引数をスタックにプッシュして関数に渡せば実現できます。

これまでと同様に、
メモリのアドレスがバイト単位で、
レジスタの大きさが 4 バイトの場合の例を示します。
#+begin_src asm
# 呼び出し元のプログラム
        :
        :
    push    引数            # 引数をスタックに積む
    push    リターンアドレス # 関数呼び出し
    pc	← 関数のアドレス
    sp	← <+> 4	# ← ここがリターンアドレス
        :
        :
#+end_src
ここで \sp はスタックポインタを表しています。
また、
最後に「\sp ← <+> 4」としているのは、
スタックに積んだ引数を捨てるためです。

関数側では、
スタックから引数を取り出します。
#+begin_src asm
# 関数
    r1	← [sp + 4]  # 引数の値をレジスタ r1 に読み込む
        :
        :
    pop	pc          # 呼び出し元に戻る
#+end_src
スタックの一番上に (4 バイトの) リターンアドレスがあり、
その直後に引数が格納されています。
このため、
[\sp + 4] によってスタックに格納されている引数を取り出せます。

*** 関数から呼び出し元に返り値をどのように渡すか

関数から呼び出し元に返り値を渡す場合には、
レジスタがよく使われます。
#+begin_src asm
# 関数
    r1 ← [sp + 4]  # 引数の値をレジスタ r1 に読み込む
        :                   # レジスタ r1 に計算結果を格納する
        :
    pop pc                  # 呼び出し元に戻る
#+end_src
例えば、
「レジスタ \r{1} で値を返す」と決めておくことで、
レジスタ \r{1} に計算結果を格納した状態で呼び出し元に戻ります。

呼び出し元は先ほどとほぼ同じです。
#+begin_src asm
# 呼び出し元のプログラム
        :
        :
    push    引数               # 引数をスタックに積む
    push    リターンアドレス    # 関数呼び出し
    pc  ← 関数アドレス
    sp  ← <+> 4     # ← ここがリターンアドレス
        :           # レジスタ r1 (返り値) を使って計算を実行
        :
#+end_src

** ABI (Application Binary Interface)
<<sec:stack/abi>>

上で説明した、関数呼び出しにおける 3 つの課題
1. 呼び出し元にどのように戻るか (*リターンアドレス (return address)* の管理)
2. 呼び出し元から関数に *引数 (parameter)* をどのように渡すか
3. 関数から呼び出し元に *返り値 (return value)* をどのように渡すか
のうち、
1.は主に CPU のアーキテクチャによって決まります。

IA-32 アーキテクチャのように、
サブルーチン呼び出しから戻るための命令 (例えば RET 命令) を持っている命令セットアーキテクチャであれば、
通常はその命令を使って呼び出し元に戻ります。
その命令が、
「スタックに積まれたリターンアドレスを取り出す」という仕組みになっていれば、
スタックから取り出したアドレスにジャンプすることで呼び出し元に戻ります。

本書で紹介するアーキテクチャのうち、
IA-32 アーキテクチャに加えて、
COMET II ([[ch:comet]] 章) および AVR アーキテクチャ ([[ch:avr]] 章) は、
スタックにリターンアドレスを格納する方式を採用している一方、
Armv8-A アーキテクチャは、
スタックにリターンアドレスを格納する方式ではなく、
特定のレジスタにリターンアドレスを格納する方式を採用しています。

なお、
残りの 2 つである、
「2.呼び出し元から関数に *引数 (parameter)* をどのように渡すか」と「3.関数から呼び出し元に *返り値 (return value)* をどのように渡すか」は、
CPU や命令セットのアーキテクチャでは決まるのではなく、
オペレーティングシステムや周辺のソフトウェアの作りによって決まります。

このような、
「呼び出し元から関数に引数をどのように渡すか」や、
「関数から呼び出し元に返り値をどのように返すか」の規則を *ABI (Application Binary Interface)* と呼びます。
- 引数の値 (データ) をスタックに積んで渡すのか、それとも引数の値 (デー
  タ) を特定のレジスタに格納して渡すのか
- 関数からの返り値 (データ) をスタックに積んで返すのか、それとも関数か
  らの返り値 (データ) を特定のレジスタに格納して返すのか
- 呼び出される関数は、どのレジスタの値を変更してもよいのか、どのレジス
  タの値は変更していはいけないのか
といった、
機械語で書かれた関数 (サブルーチン) を呼び出すときの規約が ABI です。

IA-32 アーキテクチャ向けの GNU/Linux では、
32 ビット環境と 64 ビット環境において、
それぞれ異なる ABI \cite{Intel386-ABI,AMD64-ABI} が定められています。

32 ビット版の GNU/Linux の ABI では、
上の [[sec:stack/funcall]] 節で説明したような形で、
関数に引数を渡し、
また関数からの返り値を受け取ります。
つまり、
関数への引数はスタックに積んで渡し、
関数からの返り値はレジスタ経由で受け取ります \cite{Intel386-ABI}。

64 ビット版の GNU/Linux の ABI では、
IA-32 アーキテクチャの 64 ビットモード (x86-64) では 16 個の汎用レジスタが使えることもあり、
関数への引数は基本的にレジスタに値を格納して渡し、
関数からの返り値もレジスタ経由で受け取ります \cite{AMD64-ABI}。

なお、
本書で紹介する他のアーキテクチャでは、
COMET II や AVR アーキテクチャには ABI と呼べるような規約は存在しないようです。

#+begin_note
AVR アーキテクチャでも、
特定の処理系 (例えば AVR アーキテクチャ向けの GCC コンパイラ) やライブラリを使用する場合は、
関数の呼び出し規則は決まっています。
したがって、
特定の処理系やライブラリを使用する場合は、
それらの呼び出し規則にあわせてアセンブリ言語プログラムを作成する必要があります。
#+end_note

Armv8-A アーキテクチャでは、
IA-32 アーキテクチャの 64 ビットモード (x86-64) と同じように、
関数への引数は基本的にレジスタに値を格納して渡し、
関数からの返り値もレジスタ経由で受け取ります \cite{Arm:PCS}。
なお、
ARM アーキテクチャの ABI は、
PCS (Procedure Call Standard) \cite{Arm:PCS} と呼ばれています。

** 章末問題
<<sec:stack/quiz>>

1. スタック型の構造を持っている物 (例: 日用品・機器・装置・部品・デバ
   イスなど) にはどのようなものがあるかを答えよ。

   #+begin_answer
   例: 書類置き、
   押入に収納している布団、
   拳銃の弾倉
   #+end_answer

2. 空のスタックに以下の操作を行った時の、スタックの状態を図示せよ: (1)
   0x12、0x34、0x56 をプッシュし、(2) 2 要素をポップ、(3) 0x78、0x9a、
   0xbc をプッシュ、(4) 1 要素をポップ。

   #+begin_answer
   0x9a、
   0x78、
   0x12
   #+end_answer

3. スタックポインタのための専用のレジスタを持たないコンピュータで、ス
   タックを実現できるかを、その理由とともに答えよ。

   #+begin_answer
   実現できる。
   メモリ上の値をスタックポインタとして使用すればいい。
   #+end_answer

4. 1 台のコンピュータで、複数のスタックを持つことは可能かを、その理由
   とともに答えよ。

   #+begin_answer
   可能である。
   複数のスタックポインタをメモリ上に確保するか、
   スタックポインタを表すレジスタの値をその都度切り替えればよい。
   #+end_answer

5. スタックを用いて、レジスタ \r{1} と \r{2} の値を交換するにはどのよ
   うな処理を行えばよいかを答えよ。

   #+begin_answer
   | push \r{1}     |
   | \r{1} ← \r{2} |
   | pop \r{2}      |
   #+end_answer

6. x86 および x86-64 の ABI (Application Binary Interface) (文献
   \cite{Intel386-ABI} および\cite{AMD64-ABI}) を入手せよ。

7. プログラム ~fact.c~ の関数 ~fact~ を用いて $n!$ を計算する場
   合、~fact(n)~ の計算に必要なスタックの大きさを $n$ を用いて表せ。

   #+begin_answer
   1 回の関数呼び出しに使用するスタックの大きさは、
   GCC が生成したアセンブリ言語プログラムによる。
   プログラム ~fact.s~ (図 [[fig:tr-stack/fact.s]]) の場合、
   関数 ~main~ から関数 ~fact~ の呼び出しに 48 バイト、
   関数 ~fact~ から関数 ~fact~ への呼び出しに 32 バイト使用する。
   したがって、
   $48 + 32 \times (n - 1)$ バイト。
   #+end_answer

8. 自身が使用しているコンピュータのスタックの大きさ (上限) を調べよ。

   #+begin_answer
   いくつかの上限があるが、
   UNIX 系オペレーティングシステムにおけるユーザレベルの上限は、
   例えば ~ulimit~ コマンドで確認できる。

#+begin_src sh
$ ulimit -a
Maximum size of core files created                           (kB, -c) 0
Maximum size of a process’s data segment                     (kB, -d) unlimited
Maximum size of files created by the shell                   (kB, -f) unlimited
Maximum size that may be locked into memory                  (kB, -l) 2018731
Maximum resident set size                                    (kB, -m) unlimited
Maximum number of open file descriptors                          (-n) 1024
Maximum stack size                                           (kB, -s) 8192
Maximum amount of cpu time in seconds                   (seconds, -t) unlimited
Maximum number of processes available to a single user           (-u) 62950
Maximum amount of virtual memory available to the shell      (kB, -v) unlimited
#+end_src
   #+end_answer
