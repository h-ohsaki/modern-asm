# -*- Org -*-
# 
# Copyright (c) 2021, Hiroyuki Ohsaki.
# All rights reserved.
# 

# This document is licensed under a Creative Commons
# Attribution-NonCommercial-ShareAlike 4.0 International License (CC
# BY-NC-SA 4.0).

# This document is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# Creative Commons License for more details.

# You should have received a copy of the license along with this work.
# If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

* マイクロコントローラの例: Atmel AVR
<<ch:avr>>

** Atmel AVR ファミリの概要
<<sec:avr/overview>>

*** Atmel AVR

AVR とは、
Atmel 社が開発したマイクロコントローラのファミリ名です。
一言で説明すれば、
AVR とは、
(フォン・ノイマン型アーキテクチャではなく) ハーバードアーキテクチャを採用した 8 ビット RISC コンピュータのマイクロコントローラです。

#+begin_note
AVR には、
8 ビットだけでなく、
AVR32 と呼ばれる 32 ビット RISC コンピュータのマイクロコントローラもありますが、
本書では 8 ビットの AVR アーキテクチャのみを取り上げます。
#+end_note

*マイクロコントローラ (microcontroller)* とは、
コンピュータを構成する CPU、
メモリ、
入出力装置などを、
単一の IC (Integrated Circuit) チップに組み込んだものです。
日本では、
マイクロコントローラを略して *マイコン* とも呼びます。

一般的なコンピュータは、
マザーボード (motherboard) と呼ばれる基板上に、
CPU やメモリ、
周辺回路などを搭載しています。
通常、
デスクトップ型コンピュータでもラップトップ型コンピュータでも、
コンピュータの内部にある最も大きな基板がマザーボードです。
コンピュータの内部にあるマザーボードと、
電源ユニット、
キーボード、
ディスプレイなどが一揃えとなったものがコンピュータです。

一方、
マイクロコントローラでは、
CPU、
メモリ、
入出力装置などが 1 つの IC チップに組み込まれています。
AVR シリーズのマイクロプロセッサの例を図 [[fig:avr/atitiny13a]] および図 [[fig:avr/atmega328p]] に示します。

#+caption: Atmel ATtiny13A (DIP-8 パッケージ) (https://pg-cdn-a2.datacaciques.com/00/NDAy/18/12/04/l05kz7ez3atu848x/af176965d407f245.jpg)
#+label: fig:avr/atitiny13a
#+attr_latex: :width .5\columnwidth
[[./figure/avr/attiny13a.jpg]]

#+caption: Atmel ATmega328P (DIP-28 パッケージ) (https://upload.wikimedia.org/wikipedia/commons/thumb/0/0c/ATMEGA328P-PU.jpg/1200px-ATMEGA328P-PU.jpg)
#+label: fig:avr/atmega328p
#+attr_latex: :width .5\columnwidth
[[./figure/avr/atmega328p.jpg]]

図 [[fig:avr/atitiny13a]] は *ATtiny13A* です。
8 ピンの *DIP (Dual In-line Package) パッケージ* と呼ばれる、
1 cm 角程度の小さな IC チップです。
この 1 つの IC チップに、
CPU、
メモリ、
オシレータ、
デジタル入出力、
A/D コンバータ、
タイマなどが搭載されています。
もちろん、
一般的なコンピュータとマイクロコントローラは規模や性能がまったく異なりますが、
一般的なコンピュータのマザーボードに搭載されている機能の大半が、
たった 1 つの IC チップに搭載されています。

1 チップの ATtiny13A に、
電源さえ供給すれば独立した 1 つのコンピュータとして動作します。
ATtiny13A の動作電圧は 1.8〜5.5 V のため、
例えば 1.5V のアルカリ電池を 2 本直列にして ATtiny13A に接続すれば、
それだけで単体のコンピュータとして動作します。
ATtiny13A は低消費電力であり、
単三のアルカリ電池であれば 1 週間くらいは平気で動き続けます。

図 [[fig:avr/atmega328p]] は *ATmega328P* です。
28 ピンの DIP パッケージなので、
1 cm \times 3.5 cm 程度の大きさの IC チップです。
ATtiny13A と同じように、
コンピュータとして必要な装置が 1 つの IC チップに搭載されています。
ATtiny13A よりも大きく、
ピン数も多いことからわかるように、
ATmega328P は ATtiny13A よりも高機能なマイクロコントローラです。
より多くのメモリを搭載しており、
より多くのデジタル入出力、
A/D コンバータ、
タイマを搭載しています (表 [[tab:avr/comparison]])。

#+caption: ATtiny13A と ATmega328P の比較
#+label: tab:avr/comparison
|                                 | ATtiny13A | ATmega328P |
|---------------------------------+-----------+------------|
| 最大動作クロック (MHz)          |        20 |         20 |
| ピン数                          |         8 |         28 |
| フラッシュメモリ (KB)           |         1 |         32 |
| EEPROM (バイト)                 |        64 |        512 |
| SRAM (バイト)                   |        64 |      2 048 |
| 動作電圧 (V)                    |  1.8〜5.5 |   1.8〜5.5 |
| GPIO                            |         6 |         23 |
| A/D コンバータ (ビット数)       |        10 |         10 |
| A/D コンバータ (チャネル数)     |         4 |          6 |
| PWM チャネル数                  |         2 |          6 |
| 8 ビットタイマ                  |         1 |          2 |
| 16 ビットタイマ                 |      なし |          1 |
| シリアル USART                  |      なし |       あり |
| SPI シリアルインターフェース    |      なし |       あり |
| I^{2}C シリアルインターフェース |      なし |       あり |

本書の執筆時点で、
ATtiny13A は 1 個 100 円程度、
ATmega328P は 1 個 250 円程度で手に入ります。
インテルや AMD のデスクトップコンピュータ向け CPU が 1 個数万円程度なので、
おおよそ 1/100 以下の価格で手に入ります。
しかも、
デスクトップコンピュータ向け CPU は、
CPU 単体では何もできません。
一方、
マイクロコントローラは、
電源以外のほぼすべてが 1 チップに搭載されています。

以下では、
AVR ファミリの CPU と、
その CPU におけるアセンブリ言語プログラミングに焦点を当てて説明します。
そのため、
AVR ファミリのマイクロコントローラに関する以下のような話題は本書では扱いません。
- 内蔵フラッシュメモリへのプログラム書き込み方法
- ヒューズビット (fuse bit) と呼ばれる設定ビットの変更方法
- 各種デバイス (デジタル入出力、A/D コンバータ、タイマなど) の利用法
AVR の命令セットアーキテクチャやアセンブリ言語プログラミング以外の情報については、
それぞれのマイクロコントローラのデータシートや関連書籍を参照してください。

AVR ファミリには、
主に ATtiny、
ATmega、
ATxmega という 3 つのシリーズがあります。
先ほどの ATtiny13A は数十種類ある ATtiny シリーズの製品の 1 つです。
また、
ATmega328P も、
数十種類ある ATmega シリーズの製品の 1 つです。

ATtiny、
ATmega、
ATxmega というシリーズの多数のマイクロコントローラは、
それぞれピン数、
IC の形状、
CPU の動作クロック、
フラッシュメモリの大きさ、
SRAM の大きさ、
EEPROM の大きさ、
周辺回路の性能や規模などがそれぞれ異なります。
しかし、
これらの多数のマイクロコントローラの命令セットアーキテクチャはほぼ共通です。
このため、
AVR ファミリのすべてのマイクロコントローラにおいて、
命令セットやオペコードはほぼ共通です。

*** AVR シミュレータ + GDB によるトレース

AVR ファミリのアーキテクチャは後ほど [[sec:avr/arch]] 節で説明します。

ここでは、
AVR アーキテクチャや、
AVR アーキテクチャ向けのアセンブリ言語を説明する前に、
まず、
AVR ファミリの CPU の動作をシミュレータを使ってトレースしてみます。

AVR マイクロコントローラは、
それ単体で 1 つのコンピュータとして動作します。
通常は、
マイクロコントローラに実行させたいプログラムを、
あらかじめフラッシュメモリに書き込んでおきます。
その後、
マイクロコントローラに電源を供給すると、
CPU がリセットされて、
フラッシュメモリに格納されているプログラムの実行を開始します。

ATtiny13A のフラッシュメモリはたったの 1 Kbyte しかありませんし、
ATmega328P のフラッシュメモリも 32 Kbyte しかありません。
このため、
AVR ファミリのマイクロコントローラでは通常、
*オペレーティングシステムは動作しません*。
マイクロコントローラで実行したい機械語プログラムをフラッシュメモリに書き込み、
マイクロコントローラは、
その機械語プログラムだけを実行します。

したがって、
AVR マイクロコントローラ上でプログラムを動作させるためには、
通常、
以下のような手順を取ります。

1. 使用したいマイクロコントローラ (例: ATtiny13A) の IC を入手する
2. 他のコンピュータ (例: GNU/Linux) 上で AVR マイクロコントローラ向け
   の機械語プログラムを作成する
3. コンピュータに AVR 用プログラマ (ライタ) を接続する
4. AVR 用プログラマ (ライタ) にマイクロコントローラの IC を接続する
5. 作成した機械語プログラムを、マイクロコントローラのフラッシュメモリ
   に書き込む
6. AVR 用プログラマ (ライタ) からマイクロコントローラの IC を取り外す
7. マイクロコントローラの IC に電源を供給して動作させる

以下では、
実際のマイクロコントローラを使うのではなく、
*AVR シミュレータと GDB* を利用して、
GNU/Linux 上で、
AVR マイクロコントローラ向けの機械語プログラムの動作をトレースします。
実際のマイクロコントローラを使うよりもシミュレータのほうが手軽であり、
また、
デバッガを利用することで、
プログラムの内部動作を容易に分析できるからです。

AVR シミュレータを用いてプログラムを動作させる手順は以下のようになります。

1. 使用したい (シミュレートしたい) マイクロコントローラ (例:
   ATtiny13A) を決める
2. コンピュータ (例: GNU/Linux) 上で AVR マイクロコントローラ向けの機
   械語プログラムを作成する
3. GDB を起動し、AVR シミュレータ上で作成した機械語プログラムを動作する

では、
実際に AVR シミュレータ上で、
AVR アーキテクチャの機械語プログラムを実行してみます。
本書では、
ATtiny13A というマイクロコントローラ上でのプログラムの動作をシミュレートします。

まず、
以下のアセンブリ言語プログラムを ~add.s~ という名前で保存します。

#+caption: avr/add.s
#+label: fig:avr/add.s
#+include: "code/avr/add.s" src asm

このプログラム ~add.s~ は、
12 + 34 を計算し、
計算結果を ~v~ 番地に格納するだけの単純なプログラムです。
このプログラムをアセンブル、
リンクすることで、
ATtiny13A 向けの機械語プログラムに変換します。

GNU アセンブラ (GAS) や GNU binutils は、
対象となるコンピュータ機のアーキテクチャとして AVR をサポートしています。
このため、
[[ch:gas]] 章で説明した方法 (IA-32 アーキテクチャ上の Debian GNU/Linux で、
IA-32 アーキテクチャ向けのアセンブリ言語プログラムをアセンブルおよびリンクする方法) とほぼ同じ方法で、
AVR アーキテクチャ向けのアセンブリ言語プログラムを機械語に変換できます。

ただし、
IA-32 アーキテクチャのコンピュータ上で、
そのコンピュータ機のアーキテクチャとは異なるアーキテクチャ向けの機械語プログラムに変換するという点が異なります。
したがって、
[[ch:gas]] 章で説明した ~as~ コマンドや ~ld~ コマンドではなく、
対象となる計算機が AVR アーキテクチャである、
~avr-as~ コマンドや ~avr-ld~ コマンドなどを使用します。

#+begin_note
Debian GNU/Linux では、
対象となるコンピュータのアーキテクチャが AVR である GNU binutils は、
*binutils-avr パッケージ* で提供されています。
同様に、
対象となるコンピュータのアーキテクチャが AVR である GCC や GDB は、
それぞれ *gcc-avr パッケージ* および *gdb-avr パッケージ* として提供されています。
Debian GNU/Linux では、
これらのパッケージをインストールするだけで AVR アーキテクチャ向けのクロス開発が可能になります。
#+end_note

まず、
アセンブリ言語プログラム ~add.s~ をアセンブルし、
オブジェクトファイル ~add.o~ に書き出します。
#+begin_src sh
$ avr-as -mmcu=attiny13a -o add.o add.s
#+end_src

一般的な GAS の使用法とほとんど同じですが、
~as~ コマンドではなく ~avr-as~ コマンドを使っています。
また、
~-mmcu~ オプションを指定して、
*対象とするマイクロコントローラ* に ATtiny13A を指定しています。
AVR ファミリのマイクロコントローラの機械語はほとんど共通ですが、
マイクロコントローラの種類によって一部利用できる命令やレジスタが異なります。
また、
マイクロコントローラの種類によってメモリマップも異なります。
このため、
対象とするマイクロコントローラを ~-mmcu~ オプションによって指定する必要があります。
~-mmcu~ オプションで指定できるマイクロコントローラの一覧は、
GAS のドキュメント /(as)AVR Options/ にあります。

これによってオブジェクトファイル ~add.o~ が生成されます。
IA-32 アーキテクチャ向けのオブジェクトファイル ([[ch:gas]] 章) と同じ、
*ELF 形式のオブジェクトファイル* です。
ただし、
.text セクションに格納されているのは、
AVR アーキテクチャ (より正確には ATtiny13A) 向けの機械語プログラムです。
#+begin_src sh
$ file add.o
add.o: ELF 32-bit LSB relocatable, Atmel AVR 8-bit, version 1 (SYSV), not stripped
#+end_src

#+begin_note
一昔前は、
コンピュータのアーキテクチャごとにコンパイラやアセンブラなどの開発環境が異なりました。
このため、
あるアーキテクチャ A 向けの開発をしたければ、
アーキテクチャ A 用の開発環境 X に習熟する必要がありました。
同様に、
あるアーキテクチャ B 向けの開発をしたければ、
アーキテクチャ B 用の開発環境 Y に習熟する必要がありました。

例えば、
インテル 8086 向けの開発をしたければ、
インテル 8086 向けの開発環境 (例: Microsoft MASM) に習熟する必要がありました。
同様に、
Atmel AVR 向けの開発をしたければ、
Atmel AVR 向けの開発環境 (例: マイクロチップテクノロジ AVR Studio) に習熟する必要がありました。

開発環境ごとに、
アセンブリ言語の文法や、
アセンブラの使用法、
リンカの使用法、
デバッガの使用法などがそれぞれ異なるため、
学習が大変でした。

現在は、
GNU のツールチェインをマスターすれば、
多数のコンピュータアーキテクチャ向けの開発が可能です。
例えば、
IA-32 アーキテクチャと AVR アーキテクチャはまったくといっていいほど異なりますが、
同じアセンブラ (GAS)、
デバッガ (GDB)、
コンパイラ (GCC) を利用した開発が可能です。
とてもよい時代になったものだと思います。
#+end_note

[[ch:gas]] 章で学んだ、
~readelf~ コマンドや ~objdump~ コマンドなどが、
まったく同じようにそのまま使えます。
例えば、
~avr-objdump~ コマンドを使えば、
オブジェクトファイル ~add.o~ を逆アセンブルできます。
#+begin_src sh
$ avr-objdump -d add.o

add.o:     file format elf32-avr


Disassembly of section .text:

00000000 <_start>:
   0:   0c e0           ldi     r16, 0x0C       ; 12
   2:   12 e2           ldi     r17, 0x22       ; 34
   4:   01 0f           add     r16, r17
   6:   00 93 00 00     sts     0x0000, r16     ; 0x800000 <loop+0x7ffff6>

0000000a <loop>:
   a:   00 c0           rjmp    .+0             ; 0xc <loop+0x2>
#+end_src

他にも、
~avr-readelf~ コマンドを使えば、
ELF 形式のファイルに含まれているセクションの一覧を見ることができます。

#+begin_src sh
$ avr-readelf -S add.o
There are 8 section headers, starting at offset 0x110:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        00000000 000034 00000c 00  AX  0   0  1
  [ 2] .rela.text        RELA            00000000 0000c4 000018 0c   I  6   1  4
  [ 3] .data             PROGBITS        00000000 000040 000001 00  WA  0   0  1
  [ 4] .bss              NOBITS          00000000 000041 000000 00  WA  0   0  1
  [ 5] .shstrtab         STRTAB          00000000 0000dc 000031 00      0   0  1
  [ 6] .symtab           SYMTAB          00000000 000044 000070 10      7   6  4
  [ 7] .strtab           STRTAB          00000000 0000b4 00000f 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)
#+end_src

オブジェクトファイル ~add.o~ は再配置可能 (リロケータブル) な機械語プログラムなので、
実際にマイクロコントローラに書き込んで動作するためにはリンカによって絶対アドレスの機械語プログラムに変換する必要があります。

リンカも同じように、
~ld~ コマンドの代わりに ~avr-ld~ コマンドを使用します。
#+begin_src sh
$ avr-ld -m avr25 -Tdata 0x800060 -o add add.o
#+end_src

一般的な ~ld~ コマンドの使用法とほとんど同じですが、
ここではマイクロコントローラの種類を指定する ~-m~ オプションと、
.data セクションの配置アドレスを指定する ~-Tdata~ オプションを指定しています。

~-m~ オプションには、
マイクロコントローラの具体的な型番 (例: ATtiny13A) ではなく、
*マイクロコントローラの種類* を指定します。
マイクロコントローラの種類は、
~ld~ コマンドの用語では *エミュレーション (emulation)* と呼ばれています。
ATtiny13A は avr25 という種類に分類されているので、
ここでは ~-m avr25~ というオプションを指定しています。
それぞれのマイクロコントローラが、
どのような種類に分類されるのかについても、
GAS のドキュメント /(as)AVR Options/ に記載されています。

~-Tdata~ オプションは、
.data セクションをメモリのどの番地に配置するかを指定します。
後ほど [[sec:avr/arch]] 節で説明するように、
ATtiny13A の SRAM は 0x60 番地から始まります。
ここでは、
.data セクションを SRAM の先頭 (0x60 番地) に配置しています。
ただし、
AVR エミュレータでは、
データ用メモリのアドレスは便宜上 0x800000〜となっているので、
.data セクションを配置するアドレスとして 0x800060 (データ用メモリの 0x60 番地の意味) を指定しています。

マイクロコントローラが ATtiny13A の場合には、
~avr-as~ コマンドの ~-mmcu~ オプションや、
~avr-ld~ コマンドの ~-m~ オプションや ~-Tdata~ オプションは指定しなくても (たまたま) 動作します。
ただし、
マイクロコントローラによっては、
これらのオプションを指定しなければ動作しないケースもあります。
基本的には、
ターゲットとするマイクロコントローラを明示的に指定するようにしてください。

これにより、
ELF 形式の実行ファイル ~add~ が作成されます。
#+begin_src sh
$ file add
add: ELF 32-bit LSB executable, Atmel AVR 8-bit, version 1 (SYSV), statically linked, not stripped
#+end_src

当然ですが、
ELF 形式の実行ファイルであっても、
AVR アーキテクチャ向けの機械語プログラムのため、
そのままでは実行できません。
#+begin_src sh
> ./add
Failed to execute process './add'. Reason:
exec: Exec format error
The file './add' is marked as an executable but could not be run by the operating system.
#+end_src

ELF 形式の実行ファイルは直接実行できないので、
AVR シミュレータ上で実行します。
ここでは GDB に組み込まれている AVR シミュレータを使用します。

現在の作業ディレクトリに、
以下の内容を書いたファイル ~.gdbinit~ を作成します。

#+caption: avr/.gdbinit
#+label: fig:avr/.gdbinit
#+include: "code/avr/.gdbinit" src gdb

基本的に、
IA-32 アーキテクチャの機械語プログラムをトレースしたときの使い方と同じです。
ただし、
#+begin_src raw
target sim
load
#+end_src
という GDB のコマンドが新しく登場しています。

target コマンドは、
GDB がデバッグする対象のプログラムが動作しているコンピュータやプロセスを指定するためのコマンドです。
ここでは sim (simulator の意味) を指定し、
GDB に組み込まれているシミュレータを使用します。
つまり、
シミュレータ上で AVR アーキテクチャ向けの機械語プログラムを実行し、
機械語プログラムの動作を GDB でトレースします。
load コマンドはデバッグ対象のプログラムを読み込みます。

#+begin_note
なぜ、
IA-32 アーキテクチャのコンピュータ (例えば、
Debian GNU/Linux (i386)) 上で、
まったく異なる CPU である AVR アーキテクチャの機械語プログラムが実行できるのかがよくわからないかもしれません。

GDB には、
AVR アーキテクチャの CPU の動作を模擬するシミュレータ (C 言語で書かれたソフトウェア) が含まれています。
GDB は、
AVR アーキテクチャの機械語プログラムを、
IA-32 アーキテクチャの CPU で直接実行するのではなく、
C 言語で書かれたシミュレータを使って実行します。
したがって、
- AVR の機械語はシミュレータが (本物の AVR マイクロコントローラではな
  く) ソフトウェアのシミュレータが解釈する
- AVR のソフトウェアシミュレータは (C 言語からコンパイルされた) IA-32
  アーキテクチャの機械語のプログラムで、シミュレータのプログラムは
  IA-32 アーキテクチャの (本物の) CPU が解釈して実行する
という関係になっています。

このような仕組みのため、
AVR の機械語プログラムをシミュレータ上で動作させると (CPU のシミュレーションを行っているため) 非常に低速です。
#+end_note

それでは実行してみましょう。
#+begin_src sh
$ avr-gdb -q add
Reading symbols from add...
(No debugging symbols found in add)
Connected to the simulator.
Loading section .data, size 0x2 lma 0xc
Loading section .text, size 0xc lma 0x0
Start address 0x0
Transfer rate: 112 bits in <1 sec.
Breakpoint 1 at 0x0
(gdb) 
#+end_src

#+begin_note
常に、
対象とするコンピュータが AVR である binutils や GDB など使用する必要があることに注意してください。
Debian GNU/Linux の場合、
これらのコマンドは、
すべて「avr- なんとか」という名前になっています。

例えば、
誤って通常の ~gdb~ コマンドを起動すると以下のようなエラーになります。
エラーになるためすぐに誤りに気付くとは思いますが、
慣れるまでは何度も間違えるかもしれません (筆者も何度も間違いました)。

#+begin_src sh
$ gdb -q add
Reading symbols from add...
(No debugging symbols found in add)
.gdbinit:1: Error in sourced command file:
Undefined target command: "sim".  Try "help target".
(gdb) 
#+end_src
#+end_note

run コマンド (省略形は r) を実行し、
シミュレータ上でプログラム ~add~ の実行を開始します。
#+begin_src gdb
(gdb) r
Starting program: /home/ohsaki/code/avr/add 

Breakpoint 1, 0x00000000 in _start ()
1: /x $r16 = 0x0
2: /x $r17 = 0x0
3: x/4i $pc
=> 0x0 <_start>:        ldi     r16, 0x0C       ; 12
   0x2 <_start+2>:      ldi     r17, 0x22       ; 34
   0x4 <_start+4>:      add     r16, r17
   0x6 <_start+6>:      sts     0x0060, r16     ;  0x800060
4: x/8xb 0x800060
0x800060:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
(gdb) 
#+end_src
ラベル ~_start~ の差す番地にブレークポイントを設定したので、
シミュレータ上でのプログラムの実行が ~_start~ 番地で停止しています。

#+begin_note
通常、
AVR アーキテクチャのプログラミングでは、
開始アドレス (通常は 0 番地) 周辺にジャンプテーブルを記載します。
マイクロコントローラがリセットされたり、
割り込みが発生したりすると、これらのジャンプテーブルが呼び出されます。
本書のプログラムでは割り込みを使っていないため、
機械語のプログラムを 0 番地から配置しています。
#+end_note

~.gdbinit~ ファイルにいくつか display コマンドを書いておいたので、
レジスタ R16 と R17 の値と、
現在のプログラムカウンタ (~$pc~) から 4 命令の逆アセンブル結果、
0x800060 番地から 4 バイトのメモリダンプが表示されています。
IA-32 アーキテクチャのときとは異なり、
セミコロン (~;~) 以降はコメントです。
これらのコメントは (もともとのアセンブリ言語プログラム中に書かれていたコメントではなく) GDB が逆アセンブル時に生成しているコメントです。

stepi コマンド (省略形は si) を何度か実行し、
CPU の動作をトレースしてみましょう。

最初の命令は \inst{ldi r16, 0x0C} です。
LDI (Load Immediata) 命令は、
指定したレジスタに即値を読み込む命令です。
レジスタ R16 に 0x0C (= 12) が読み込まれます。
#+begin_src gdb
(gdb) si
0x00000002 in _start ()
1: /x $r16 = 0xc ← レジスタ R16の値が 0x0c (= 12) になった
2: /x $r17 = 0x0
3: x/4i $pc
=> 0x2 <_start+2>:      ldi     r17, 0x22       ; 34
   0x4 <_start+4>:      add     r16, r17
   0x6 <_start+6>:      sts     0x0060, r16     ;  0x800060
   0xa <loop>:  rjmp    .-2             ;  0xa <loop>
4: x/8xb 0x800060
0x800060:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
(gdb) 
#+end_src

次に実行される命令は \inst{ldi r17, 0x22} です。
先ほどと同じ LDI 命令です。
レジスタ R17 に、
0x22 (= 34) が読み込まれます。
#+begin_src gdb
(gdb) ← リターンキーを押す (si コマンドの繰り返し)
0x00000004 in _start ()
1: /x $r16 = 0xc
2: /x $r17 = 0x22 ← レジスタ R17 の値が 0x22 (= 34) になった
3: x/4i $pc
=> 0x4 <_start+4>:      add     r16, r17
   0x6 <_start+6>:      sts     0x0060, r16     ;  0x800060
   0xa <loop>:  rjmp    .-2             ;  0xa <loop>
   0xc: nop
4: x/8xb 0x800060
0x800060:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
(gdb) 
#+end_src

次に実行される命令は \inst{add r16, r17} です。
ADD (Add Two Registers) 命令は、
名前から想像できるように、
2 つのレジスタの値を加算する命令です。
今の場合、
レジスタ R16 に、
レジスタ R17 の値が加算されます。
レジスタ R16 の値が 12 で、
レジスタ R17 の値が 34 のため、
レジスタ R16 の値は 12 + 34 = 46 になります。
#+begin_src sh
(gdb) ← リターンキーを押す (si コマンドの繰り返し)
0x00000006 in _start ()
1: /x $r16 = 0x2e ←レジスタ R16 の値が 12 + 34 = 46 になった
2: /x $r17 = 0x22
3: x/4i $pc
=> 0x6 <_start+6>:      sts     0x0060, r16     ;  0x800060
   0xa <loop>:  rjmp    .-2             ;  0xa <loop>
   0xc: nop
   0xe: nop
4: x/8xb 0x800060
0x800060:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
(gdb) 
#+end_src

次の命令は \inst{sts 0x0060, r16} です。
STS (Store Direct to SRAM) 命令は、
レジスタの値をメモリに書き込む命令です。
この命令によって、
レジスタ R16 の値が、
メモリの 0x0060 番地 (ATtity13A の SRAM の先頭) に格納されます。
#+begin_src sh
(gdb) ← リターンキーを押す (si コマンドの繰り返し)
0x0000000a in loop ()
1: /x $r16 = 0x2e
2: /x $r17 = 0x22
3: x/4i $pc
=> 0xa <loop>:  rjmp    .-2             ;  0xa <loop>
   0xc: nop
   0xe: nop
   0x10:        nop
4: x/8xb 0x800060
0x800060:       0x2e    0x00    0x00    0x00    0x00    0x00    0x00    0x00
(gdb)           ↑ 0x0060 番地の値が 0xe2 (= 46) に変化した
#+end_src

次の命令は \inst{rjmp .-2} です。
RJMP (Relative Jump) 命令は相対ジャンプです。
0xa 番地に配置されている RJMP 命令を基準とした相対ジャンプです。
ATtiny13A 上ではオペレーティングシステムは動作していないため、
プログラムの終了時にオペレーティングシステムに制御を戻すといったことはできません。
そこでこのプログラムでは、
最後はひたすら同じ番地への RJMP 命令を繰り返すようにしています。

まだ AVR アーキテクチャや機械語の命令は説明していませんが、
IA-32 アーキテクチャや COMET II のアセンブリ言語が読める人であれば、
何がどうなっているかが「何となくわかる」のではないでしょうか。

想像のとおり、
ldi の最初の 2 文字 ld は load (ロード) の意味ですし、
sts の最初の 2 文字 st は store (ストア) の意味です。
add はそのまま add (加算) を意味します。
rjmp の最後の 3 文字 jmp は jump (ジャンプ) の意味です。

AVR アーキテクチャのアセンブリ言語は、
いわゆるインテル記法と同じオペランド順 (命令のニーモニック、
宛先オペランド、
出所オペランド) であることもわかると思います。

IA-32 アーキテクチャ、
COMET II、
AVR アーキテクチャの CPU は、
それぞれ個性があります。
それぞれの CPU を詳しく見ていくと、
設計思想の違いが随所に見受けられ、
非常に興味深いものがあります。
その一方、
それぞれの CPU の詳細はかなり異なるものの、
マクロな目で見ると、
どれも「同じような普通の CPU」です。
少数のレジスタがあって、
メモリから機械語で書かれたプログラムを読み込んで、
ALU を使って 1 つずつ演算を行って、
フラグレジスタの値を更新する、
という単純な処理を繰り返しています。

** GNU アセンブラ (AVR 固有の機能)
<<sec:avr/gas>>

IA-32 アーキテクチャ向けのプログラム作成と同じように、
AVR アーキテクチャ向けのプログラム作成にも、
同じ GNU アセンブラ (GAS) が利用できます。

対象とするコンピュータによらず、
GAS の使用方法や、
GAS が解釈するアセンブリ言語プログラムの文法は基本的に同じです。
ただし、
一部、
対象とするコンピュータごとに異なっている点もあります。

GAS における、
IA-32 アーキテクチャ向けの固有の話題は [[sec:gas/ia32-specific]] 節で説明しました。
ここでは、
AVR アーキテクチャ向けの固有の話題を説明します。
GAS の基本的な使い方や文法については [[ch:gas]] 章を参照してください。
IA-32 アーキテクチャと比較すると、
AVR アーキテクチャはずいぶん単純であり、
覚えることもそれほど多くはありません。

*** コメント

[[sec:gas/syntax]] 節で述べたように、
GAS におけるコメント文字は対象となるコンピュータごとに異なります。

IA-32 アーキテクチャにおける行単位のコメントのコメント開始文字は番号記号 (~#~) でしたが、
AVR アーキテクチャにおけるコメントの開始文字は *セミコロン (~;~)* です。
IA-32 アーキテクチャでは、
セミコロン (~;~) は行の区切りに使用されていました。
AVR アーキテクチャではセミコロン (~;~) はコメント開始文字となり、
行の区切りには、
代わりにドル記号 (~$~) を使用します。

#+begin_note
GCC のインラインアセンブラに関して、
「セミコロン (~;~) で区切ることにより、
単一の asm 文中に複数のアセンブリ言語の命令を記述できる。」
という説明を書籍等で目にします。
厳密に言えばこの説明は誤りです。

GAS は対象とするコンピュータによって行の区切り文字が異なります。
GAS が認識する区切り文字を、
GCC のインラインアセンブラでも使用する必要があります。

例えば、
IA-32 アーキテクチャ向けのインラインアセンブラでは
#+begin_src sh
asm("movl $123,%eax; movl $456, %ecx");
#+end_src
のように記述しますが、
AVR アーキテクチャ向けのインラインアセンブラでは
#+begin_src sh
asm("ldi r16, 12$ ldi r17, 34");
#+end_src
のように記述する必要があります。
#+end_note

なお、
AVR アーキテクチャでも、
行頭に番号記号 (~#~) のある行はコメントとして扱われます (2 カラム目以降の ~#~ はコメントと見なされません)。
このため、
対象とするコンピュータが (コメント開始文字が ~#~ ではない) AVR アーキテクチャであっても、
C 言語のプリプロセッサを使ったアセンブリ言語プログラムのマクロ展開が可能です。

*** レジスタの表記法

対象とするコンピュータが IA-32 アーキテクチャの場合は、
#+begin_src asm
	movl	$123, %eax
#+end_src
のように、
レジスタ名の先頭に ~%~ を付けました。
AVR アーキテクチャの場合は、
#+begin_src asm
	ldi	r16, 12
#+end_src
のように先頭に ~%~ を付けません。

IA-32 アーキテクチャの場合は、
「先頭に ~%~ が付いているものがレジスタ名である」と明確でした。
先頭に ~%~ を付けるなどしないと、
「レジスタ名とメモリのアドレスを表すラベルが区別できないのでは?」
と思うかもしれません。

IA-32 アーキテクチャの場合は、
さまざまなアドレス指定モードがあるために、
~%~ を付けてレジスタとラベルを区別します。
例えば、
#+begin_src asm
	movl $123, eax
#+end_src
の宛先オペランド ~eax~ はレジスタではなく、
「~eax~ というラベル (つまり、
メモリのアドレス)」を意味します。
IA-32 アーキテクチャでは、
MOV 命令の宛先オペランドに、
レジスタ、
即値、
メモリロケーションが指定できるので、
「このオペランドは、
レジスタなのか?
それともメモリロケーションなのか?」
を区別できるようにしておく必要があります。
このため、
レジスタには先頭に ~%~ を付ける必要があります。

一方、
AVR アーキテクチャの場合は、
アドレス指定モードが少なく、
用途ごとにニーモニックが分かれているため、
それぞれのオペランドがレジスタなのかラベルなのかを (アセンブラが) 文脈から判断できます。
そのため、
レジスタの先頭に ~%~ 等を付ける必要がありません。

このため、
例えば図 [[fig:avr/add-unreadable.s]] のような大変わかりづらいプログラムを書くことも可能です。
例えばこのプログラムでは、
~r16~ や ~r17~ は、
レジスタ名でもあり、
また同時にラベルでもあります。

#+caption: avr/add-unreadable.s
#+label: fig:avr/add-unreadable.s
#+include: "code/avr/add-unreadable.s" src raw

アセンブラは、
それぞれのオペランドが、
レジスタなのかメモリロケーションなのかをあいまいさがなく判定できるため、
これはこれで正しいプログラムではあります。
例えば、
#+begin_src asm
	ldi	r16, r16
#+end_src
の第 1 オペランド (宛先オペランド) の ~r16~ はレジスタを意味します。
LDI 命令の宛先オペランドにメモリロケーションは指定できないため、
この ~r16~ はレジスタであることがわかります。
同様に、
第 2 オペランド (出所オペランド) の ~r16~ はラベルです。
LDI 命令の出所オペランドは即値しか指定できないので、
この ~r16~ は即値 (ラベル ~r16~ のアドレスの値) であることがわかります。

もちろん、
アセンブラが一意に解釈できるとしても、
人間にとって大変読みづらいプログラムなので、
レジスタ名をラベルに使用するというのは普通は行うべきではありません。

** AVR ファミリ CPU のアーキテクチャ
<<sec:avr/arch>>

*** 概要

ここで、
AVR ファミリ CPU のアーキテクチャを説明しましょう (表 [[tab:avr/isa]])。
AVR ファミリのマイクロコントローラは、
8 ビットの RISC コンピュータです。
AVR アーキテクチャの大きな特徴は、
現在の多くのコンピュータで採用されているフォン・ノイマン・アーキテクチャではなく、
*ハーバード・アーキテクチャ (Harvard architecture)* を採用しているという点です。

#+caption: AVR アーキテクチャの概要
#+label: tab:avr/isa
#+attr_latex: :environment maxtabular
| 命令セットの種別     | RISC                                                                           |
| レジスタの大きさ     | 8 ビット                                                                       |
| 汎用レジスタ数       | 16                                                                             |
| プログラムカウンタ   | 名称なし                                                                       |
| スタックポインタ     | SPL (ATtiny の場合)                                                     |
| 特殊レジスタ         | 各種 I/O レジスタ                                                              |
| フラグレジスタ       | I ビット、T ビット、H フラグ、S ビット、V フラグ、N フラグ、Z フラグ、C フラグ |
| 命令数               | 120 (ATtiny の場合)                                                     |
| 命令語の大きさ       | ほとんどが 2 バイト                                                            |
| データサイズ         | 8 ビット (1 バイト)                                                            |
| 浮動小数点演算命令   | なし                                                                           |
| SIMD 命令            | なし                                                                           |
| メモリアドレス       | 16 ビット (ATtiny の場合)                                                  |
| エンディアンネス     | リトルエンディアン                                                             |
| メモリ保護           | なし                                                                           |
| ハードウェア割り込み | あり                                                                           |

フォン・ノイマン・アーキテクチャでは、
CPU とメモリが単一のバスで接続されており、
メモリ上にプログラムとデータの両方が格納されています ([[sec:cpu/structure]] 節)。
一方、
ハーバード・アーキテクチャでは、
CPU と 2 つのメモリ (プログラム用メモリとデータ用メモリ) が、
それぞれ独立したバスで接続されています (図 [[fig:avr/harvard]])。

#+caption: ハーバード・アーキテクチャ
#+label: fig:avr/harvard
#+attr_latex: :width \columnwidth
[[./figure/avr/harvard.png]]

フォン・ノイマン・アーキテクチャでは、
プログラムもデータも同じメモリを使用し、
CPU が実行する機械語プログラムをメモリから読み出すだけでなく、
CPU の計算結果をメモリに格納する必要があります。
単一のバスを介して、
メモリからの読み出しとメモリへの書き込みは同時に行えないため、
フォン・ノイマン・アーキテクチャではメモリの読み書きがボトルネック (bottleneck) になります (*フォン・ノイマン・ボトルネック* と呼ばれます)。

一方のハーバード・アーキテクチャでは、
*プログラムとデータがそれぞれ異なるメモリ* を使用します。
ハーバード・アーキテクチャでは、
CPU が実行する機械語プログラムは、
プログラム用メモリから読み出します。
また、
CPU の計算結果を格納する場合は、
データ用メモリに書き込みます。
プログラム用メモリとデータ用メモリが独立したバスで接続されているため、
メモリへの読み書きを同時に行えます。
このためフォン・ノイマン・ボトルネックが発生しません。

コンピュータのアーキテクチャに限らず、
アルゴリズムでも、
プロトコルでも、
複数の方式がある場合は、
それぞれに利点・欠点があります。
フォン・ノイマン・アーキテクチャとハーバード・アーキテクチャも、
どちらのアーキテクチャが優れていて、
どちらのアーキテクチャが劣っているという関係ではありません。
どちらのアーキテクチャにも、
それぞれ利点と欠点の両方があります。
どのようなアーキテクチャを採用すべきかは、
コンピュータの設計者が何を重視するかによって決まります。

先述のとおり、
フォン・ノイマン・アーキテクチャの利点は、
例えば、
- 単一のバスしか必要としないためにシステムの構成が簡単になること
- プログラムとデータが共通のメモリを使用するためメモリキャッシュの効率がよいこと
などが挙げられます。
フォン・ノイマン・アーキテクチャの欠点は、
- メモリへのアクセスがボトルネックとなること
です。

逆に、
ハーバード・アーキテクチャの利点と欠点は、
フォン・ノイマン・アーキテクチャの利点と欠点の裏返しです。
つまり、
ハーバード・アーキテクチャの利点は、
- メモリへのアクセスがボトルネックとなりづらいこと
です。
また、欠点は、
- 2つの独立したバスが必要となるためにシステムの構成が複雑になること
- プログラムとデータが別々のメモリを使用するためにメモリキャッシュの効率が低いこと
などが挙げられます。

AVR アーキテクチャは CISC ではなく *RISC (Reduced Instruction Set Computer)* です。
どんな命令セットアーキテクチャが、
それぞれ RISC や CISC に分類されるかの明確な基準はありませんが、
おおむね、
CISC と RISC はそれぞれ以下のような傾向にあります。

|                                        | CISC         | RISC                  |
|----------------------------------------+--------------+-----------------------|
| 命令数                                 | 多い         | 少ない                |
| 1 命令の実行にかかるクロックサイクル数 | 可変         | 固定                  |
| レジスタ数                             | 少ない       | 多い                  |
| 各レジスタの役割                       | 決まっている | 決まっていない (汎用) |
| 命令語の大きさ                         | 可変         | 固定                  |

AVR アーキテクチャは、
8 ビットの命令セットアーキテクチャにもかかわらず、
レジスタが 32 個もあり、
またそれらのレジスタはすべて汎用レジスタです。
また、
ほとんどの命令語の大きさが 2 バイトであるとともに、
多くの命令が 1 クロックサイクルで実行できます。
このため、
AVR アーキテクチャは「どこからどう見ても RISC」と言えます。

AVR アーキテクチャの CPU はハーバード・アーキテクチャであることもあり、
メモリの構成に特徴があります。
前述のとおり、
ハーバード・アーキテクチャなので、
プログラム用のメモリとデータ用のメモリが独立_ していて、
それぞれ異なるアドレス空間を持ちます。
このため、
「メモリの 0 番地」には、
プログラム用メモリの 0 番地と、
データ用メモリの 0 番地の 2 つが存在します。

プログラム用のメモリの実体は *フラッシュメモリ* です (図 [[fig:avr/memory-prog]])。
プログラム用メモリの大きさはマイクロコントローラの種類によりますが、
ATtiny13A のプログラム用メモリの大きさは 1 K バイトです。
1 M バイトでも、
1 G バイトでもありません。
本当に 1 K バイト (= 1 024 バイト) です。

#+caption: AVR アーキテクチャのプログラム用メモリ (ATtiny13A の場合)
#+label: fig:avr/memory-prog
#+attr_latex: :width .7\columnwidth
[[./figure/avr/memory-prog.png]]

プログラム用メモリはフラッシュメモリであり書き換えが可能ですが、
書き換えられるのは、
基本的に AVR プログラマ (ライタ) によって機械語プログラムを書き込むときだけです。
AVR アーキテクチャの CPU の実行中は、
フラッシュメモリは ROM (読み出し専用メモリ) として動作します。
したがって、
プログラムの実行中に、
誤ってプログラムの内容を破壊してしまうということが起こりません。

#+begin_note
AVR アーキテクチャのマイクロコントローラによっては、
I/O レジスタを操作することによってプログラム用メモリの一部をプログラム実行中に書き換えることができるものもあります。
#+end_note

他の命令セットアーキテクチャに慣れた目からは少し不思議に見えますが、
AVR アーキテクチャのプログラム用メモリのアドレスの単位は *ワード (16 ビット)* です。
COMET II ([[sec:comet/comet]] 節) と同じように、
例えば、
メモリの 0 番地には 16 ビット (= 2 バイト) が格納されます。
同様に、
メモリの 1 番地には別の 16 ビット (= 2 バイト) が格納されます。
ATtiny13A のプログラム用メモリは 1 K バイトなので、
プログラム用メモリのアドレスは 0〜511 (ワード) です。

COMET II では、
レジスタもアドレスもすべてワード (16 ビット) 単位なのでまだわかりやすかったと思いますが、
AVR アーキテクチャは 8 ビットの CPU にもかかわらず、
プログラム用メモリのアドレスの単位は 16 ビットです。

これは、
AVR アーキテクチャは RISC であり、
命令語の大きさが 16 ビット (2 バイト) または 32 ビット (4 バイト) のどちらかである、
というところから来ているようです。
つまり、
AVR アーキテクチャはハーバード・アーキテクチャであり、
プログラム用メモリとデータ用メモリが独立しています。
命令語の大きさが 2 バイトまたは 4 バイトのため、
プログラム用メモリへのアクセスは基本的に 2 バイト単位でしか起こりません。
2 バイト単位でしかアクセスが起きないのに、
プログラム用メモリへのアドレスをバイト単位にすると、
(値が常に 0 である) 最下位ビットが無駄になってしまいます。
アドレスの単位をワードにすることによって、
アドレスの最下位ビットが無駄になることを避けているのだと思われます。

さらに、
AVR アーキテクチャのデータ用メモリにも特徴があります。
まず、
AVR ファミリのマイクロコントローラでは、
データ用メモリの実体は *SRAM (Static Random Access Memory)* です (図 [[fig:avr/memory-data]])。

#+caption: AVR アーキテクチャのデータ用メモリ (ATtiny13A の場合)
#+label: fig:avr/memory-data
[[./figure/avr/memory-data.png]]

また、
プログラム用メモリとは異なり、
データ用メモリのアドレスの単位はバイト (8 ビット) です。
プログラム用メモリのアドレスの単位はワードですが、
データ用メモリのアドレスの単位はバイトです。

プログラム用メモリと同じく、
データ用メモリの大きさもマイクロコントローラの種類によりますが、
ATtiny13A の SRAM の大きさは、
なんと 64 バイトです。
筆者も最初に ATtiny13A のスペックを見たときは驚きましたが、
64 K バイトでも 64 M バイトでもなく、
たったの 64 バイトです。

AVR アーキテクチャの CPU も普通の CPU なので、
この 64 バイトのメモリを、
データの格納にも、
スタック領域にも使用します。
「たったの 64 バイトのデータ用メモリでは何もできないのでは?」
と思うかもしれませんが、
マイクロコントローラの用途やプログラムの作成方法によっては 64 バイトでもさまざまな処理が実現できます。

#+begin_note
ATtiny13A のメモリは 64 バイトしかありませんが、
AVR ファミリのマイクロコントローラによっては、
データ用メモリのアドレスのバス幅は 22 ビットのものもあります。
例えば、
ATxmega シリーズのマイクロコントローラには 384 K バイトの SRAM を搭載しているものもあります。
#+end_note

ATtiny13A の場合、
プログラム用メモリの SRAM の大きさは 64 バイトですが、
プログラム用メモリのアドレス空間は 32 + 64 + 64 (= 160) バイトあります。
先頭の 32 + 64 バイトには、
*汎用レジスタ* と *I/O レジスタ* が割り当てられています。
このあたり、
何のことかわかりづらいので
少し説明しておきましょう。

データ用メモリの先頭の 32 バイト (0x0000〜0x001f) は、
プログラムからは普通のメモリに見えるのですが、
実際には 32 個の汎用レジスタが割り当てられています。
つまり、
データ用メモリの 0 番地を読み出せば、
0 番目のレジスタであるレジスタ R0 の値が読み出せます。
同様に、
データ用メモリの 0 番地に値を書き込めば、
0 番目のレジスタであるレジスタ R0 の値が変化します。
AVR アーキテクチャには R0〜R31 の 32 個の汎用レジスタがあるので、
これらがデータ用メモリの 0x0000〜0x001f に割り当てられています。
AVR アーキテクチャでは、
これを *レジスタファイル (register file)* と呼んでいます。

#+begin_note
汎用レジスタの実体がデータ用メモリの先頭に置かれているのではなく、
あくまで割り当て (マッピング) されているだけです。
ですが、
プログラムからはデータ用メモリの先頭 32 バイトに汎用レジスタがあるように見えます。
#+end_note

次の 64 バイト (0x0020〜0x005f) は *I/O レジスタ (I/O register)* と呼ばれています。
いわゆるメモリマップド I/O (memory mapped I/O) と同じように、
メモリ空間の一部が I/O ポートや I/O 関係の制御レジスタに割り当てられています。
汎用レジスタのような計算結果を保存するために使用するレジスタではなく、
I/O デバイスを制御するための専用のレジスタです。

AVR アーキテクチャのマイクロコントローラには、
デジタル入出力、
A/D コンバータ、
タイマなど、
さまざまなデバイスが搭載されていますが、
これらのデバイスの制御はすべて I/O レジスタを介して行います。

#+begin_note
ちなみに、
AVR アーキテクチャはリトルエンディアンです。
#+end_note

また、
AVR アーキテクチャのマイクロコントローラには、
フラッシュメモリ (プログラム用メモリ)、
SRAM (データ用メモリ) の他に、
書き換え可能な *EEPROM (Electrically Erasable Programmable Read Only Memory)* も搭載されています。
ATtiny13A の場合、
SRAM と同じ大きさである、
64 バイトの EEPROM が搭載されています。

フラッシュメモリは実行中のプログラムからは (通常は) 書き換えできません。
SRAM は実行中のプログラムから *自由に書き換えが可能* ですが、
電源を OFF にすると *すべて消えてしまいます*。
EEPROM は実行中のプログラムから書き換え可能であり、
また SRAM とは異なり、
電源を OFF にしても消えません (書き込んだデータが保存されます)。

ただし、
EEPROM は、
フラッシュメモリや SRAM のように、
CPU からは通常のメモリとしてはアクセスできません。
I/O レジスタを、
特定の手順に従って操作しなければ EEPROM を書き換えることができないのです。
このため、
AVR アーキテクチャにおける EEPROM はメモリの一部ではなく、
外部記憶装置の 1 つとして位置付けられます。

*** レジスタ
<<sec:avr-registers>>

AVR アーキテクチャの汎用レジスタの一覧を図 [[fig:avr/register]] に示します。

#+caption: AVR アーキテクチャの汎用レジスタ
#+label: fig:avr/register
#+attr_latex: :width .7\columnwidth
[[./figure/avr/register.png]]

AVR アーキテクチャは 32 個の汎用レジスタ (すべて 8 ビット) と、
プログラムカウンタ (16 ビットまたは 22 ビット)、
スタックポインタのためのレジスタ (16 ビットまたは 8 ビット)、
フラグレジスタ (8 ビット) を持っています。

**** 汎用レジスタ

レジスタ R0〜R31 は *汎用レジスタ (general-purpose register)* です。
レジスタとメモリ間のデータ転送や、
ALU による算術演算・論理演算などに使用します。
AVR アーキテクチャは 8 ビットの命令セットアーキテクチャなので、
*すべて 8 ビットのレジスタ* です。

汎用レジスタ R0〜R31 は、
基本的にすべて汎用に使用できます (レジスタごとに特定の用途が決まっていません) が、
レジスタ R26〜R31 は、
レジスタ X、
Y、
Z と呼ばれる 16 ビットレジスタとしても使用されます。
とはいえ、
レジスタ X、
Y、
Z という 16 ビットレジスタが別途存在するのではなく、
実際には例えば、
R27:R26 という 2 つのレジスタの組み合わせを 16 ビットレジスタと見なしています。
単に、
レジスタ R26 の値を下位 8 ビットに取り、
レジスタ R27 の値を上位 8 ビットに取る 16 ビットレジスタが存在すると見なす、
という意味です。

| レジスタの組み合わせ | 16 ビットレジスタ名 |
|--------------------+---------------------|
| R27:R26            | X レジスタ          |
| R29:R28            | Y レジスタ          |
| R31:R30            | Z レジスタ          |

16 ビットのレジスタ X〜Z (実体は 8 ビットレジスタ R26〜R31 のいずれか) は間接メモリ参照に使用します。
AVR アーキテクチャのアドレス指定モードについては後ほど説明します。

また命令によっては一部の汎用レジスタしかオペランドに指定できないものもあります。
例えば、
レジスタに即値を読み込む LDI 命令は、
宛先オペランドとしてレジスタ R16〜R31 しか指定できません。

#+begin_note
AVR アーキテクチャは RISC であり、
ほとんどの命令語の大きさが 2 バイトです。
命令語を 2 バイトに収めるために、
命令語の表現に利用できるビット数が限られています。
このため命令によっては指定できる汎用レジスタを限定しています。

32 種類の汎用レジスタ R0〜R31 をすべてオペランドに指定できるようにするためには、
レジスタの指定に 5 ビット必要です。
しかし、
オペランドに指定できる汎用レジスタを R16〜R31 の 16 種類に限定すれば、
レジスタの指定が 4 ビットで収まります。
#+end_note

極めて複雑な IA-32 アーキテクチャの CPU には汎用レジスタが 8 個しかありません ([[sec:cpu/ia32-register]] 節) が、
単純な 8 ビットの AVR アーキテクチャには 32 個もの汎用レジスタがあることは対照的といえます。

**** プログラムカウンタ、スタックポインタ

AVR アーキテクチャのプログラムカウンタおよびスタックポインタは、
そのまま *プログラムカウンタ (program counter)* および *スタックポインタ (stack pointer)* と呼ばれます。
プログラムカウンタの大きさは 16 ビットまたは 22 ビットで、
スタックポインタの大きさは 16 ビットまたは 8 ビットです。
プログラムカウンタの大きや、
スタックポインタの大きさもマイクロコントローラの種類によります。

IA-32 アーキテクチャでも、
COMET II でも、
プログラムカウンタおよびスタックポインタはどちらもレジスタの一種として定義されていました。
例えば、
IA-32 アーキテクチャにおけるプログラムカウンタは EIP レジスタであり、
スタックポインタは ESP レジスタでした。

一方、
AVR アーキテクチャでは、
プログラムカウンタはレジスタとして定義されていません。
このため、
例えば「PC レジスタ」といった表現は使いません。

そういった点を除き、
AVR アーキテクチャのプログラムカウンタは、
ごく普通のプログラムカウンタです。
AVR アーキテクチャのプログラムカウンタは、
次に実行すべき命令が格納されている (プログラム用メモリの) アドレスを保持しています。
AVR アーキテクチャでは、
プログラム用メモリのアドレスの単位はワードであり、
プログラムカウンタの値もワード単位です。

AVR アーキテクチャのスタックポインタも、
ごく普通のスタックポインタです。
データ用メモリ上に確保されたスタックの一番上のアドレスを保持しています。
AVR アーキテクチャでは、
データ用メモリのアドレスの単位はバイトであり、
スタックポインタの値はバイト単位です。

プログラムカウンタはプログラム用メモリを指し、
スタックポインタはデータ用メモリを指すため、
それぞれアドレスの単位が異なることに注意してください。

なお、
AVR アーキテクチャのスタックポインタは、
独立したレジスタではなく、
多数の I/O レジスタの一部として配置されています。
スタックポインタの大きさは 16 ビットまたは 8 ビットです (マイクロコントローラの種類によります)。

データ用メモリ (SRAM) が小さいマイクロコントローラでは 16 ビットのスタックポインタは必要ないので、
スタックポインタの大きさは 8 ビットになっています。
スタックポインタの大きさが 8 ビットの場合、
8 ビットの I/O レジスタ *SPL (Stack Pointer Low)* (アドレス 0x3d) がスタックポインタです。
一方、
スタックポインタの大きさが 16 ビットの場合、
SPL レジスタに加えて、
8 ビットの I/O レジスタ *SPH (Stack Pointer High)* (アドレス 0x3e) も使用します。

**** フラグレジスタ

AVR アーキテクチャにおけるフラグレジスタは、
*ステータスレジスタ (status register; SREG)* と呼ばれる 8 ビットのフラグレジスタです (表 [[tab:avr/sreg]])。

#+caption: AVR アーキテクチャのステータスレジスタ
#+label: tab:avr/sreg
#+attr_latex: :environment maxtabular
| ビット | 略称 | 名称                           | 役割                                              |
|--------+------+--------------------------------+---------------------------------------------------|
|      7 | I    | Global Interrupt Enable        | システム全体の割り込み許可                        |
|      6 | T    | Bit Copy Storage               | BLD (Bit LoaD) / BST (Bit STore) 命令で使用       |
|      5 | H    | Half Carry Flag                | ハーフキャリーフラグ (4 ビット目の桁あふれの有無) |
|      4 | S    | Sign Bit                       | N フラグと V フラグの XOR (排他的論理和)          |
|      3 | V    | Two's Complement Overflow Flag | オーバフローフラグ                                |
|      2 | N    | Negative Flag                  | 算術演算の結果が負なら 1、そうでなければ 0        |
|      1 | Z    | Zero Flag                      | ゼロフラグ                                        |
|      0 | C    | Carry Flag                     | キャリーフラグ                                    |

AVR アーキテクチャにおけるステータスレジスタの各ビットの役割は以下のとおりです。

IA-32 アーキテクチャや COMET II のフラグレジスタと同じように、
AVR アーキテクチャのステータスレジスタも、
主に CPU による演算命令などの実行によって、
それぞれのフラグの値が設定されます。

オーバーフローフラグ、
ゼロフラグ、
キャリーフラグなどは、
IA-32 アーキテクチャや COMET II のフラグレジスタとほぼ同じ意味です。

AVR アーキテクチャのステータスレジスタは I/O レジスタ (アドレス 0x3f) に割り付けられています。
このため、
ステータスレジスタの値を直接操作することもできます。

例えば、
システム全体の割り込みを禁止するには、
0x3f 番地の I/O レジスタの 7 ビット目を 1 にします。
具体的には、
0x3f 番地の I/O レジスタの値をいったん汎用レジスタ読み込んで、
そのレジスタの 7 ビット目を 1 にしたあと、
0x3f 番地の I/O レジスタに書き込みます。
プログラムの例を示します。
#+begin_src asm
	in	r16, 0x3f	; I/O レジスタ 0x3f の読み込み
	sbr	r16, 1 << 7	; 7 ビット目を 1 にする
	out	0x3f, r16	; I/O レジスタ 0x3f に書き戻す
#+end_src

#+begin_note
上で紹介した IN 命令や OUT 命令を使わずに、
他にも以下のような方法でステータスレジスタの I ビットを変更することもできます。

- ステータスレジスタの特定のビットを変更する専用の命令を使う

  AVR アーキテクチャには、
  SEI (Global Interrupt Enable) 命令という、
  ステータスレジスタの I ビットをセットする専用の命令があります。
  これを使えば 1 命令でステータスレジスタの I ビットを 1 に変更できます。
  #+begin_src asm
  	sei		; SREG の I ビットを 1 にする
  #+end_src

- ステータスレジスタの指定したビットを変更する命令を使う

  AVR アーキテクチャには、
  ステータスレジスタの指定した単一のビットを 1 にする BSET (Flag Set) 命令があります。
  ステータスレジスタの I ビットは 7 番目のビットであり、
  この命令を使って以下のように書くこともできます。
  #+begin_src asm
  	bset	7	; SREG の 7 ビット目を 1 にする
  #+end_src

- ステータスレジスタの値をロード命令で読み込んで、ストア命令で書き戻す

  前述のように、
  ステータスレジスタは 0x3f 番地の I/O レジスタです。
  AVR アーキテクチャでは、
  I/O レジスタはデータ用メモリの 0x0020〜(汎用レジスタファイルの直後) にも配置されています。
  このため、
  ステータスレジスタは、
  データ用メモリの 0x20 + 0x3f (= 0x5f) 番地でもアクセスできます。
  データ用メモリの 0x5f 番地の値を読み込んで、
  7 ビット目を 1 にして書き戻すことにより、
  ステータスレジスタの I ビットを 1 に変更できます。
  #+begin_src asm
  	lds	r16, 0x5f	; ステータスレジスタ (0x3f) を読み込む
  	sbr	r16, 1 << 7	; 7 ビット目を 1 にする
  	sts	0x5f, r16	; ステータスレジスタ (0x3f) に書き戻す
  #+end_src

なお、
ステータスレジスタは I/O レジスタの 0x3f 番地であるため使用できませんが、
0x00〜0x1f 番地の I/O レジスタであれば、
I/O レジスタの特定のビットを変更する SBI (Set Bit in I/O Register) 命令や CBI (Clear Bit in I/O Registger) 命令も用意されています。
#+end_note

** AVR 命令セット (概要、アドレッシングモード)
<<sec:avr/inst>>

*** 命令の分類

AVR アーキテクチャの命令セットはマイクロコントローラの種類によらずほぼ共通ですが、
一部、
マイクロコントローラごとに異なった命令を持っています。

例えば、
ATtiny13A の命令数は 120 ですが、
ATmega328P の命令数は 131 です。
ATtiny13A よりも ATmega328P のほうが高機能なマイクロコントローラであり、
ATtiny13A のすべての命令に加えて、
さらに 11 個の命令が利用できます。

ここでは、
例として ATtiny13A の命令セットを説明します。

IA-32 アーキテクチャや COMET II のときと同じように、
AVR アーキテクチャの命令セット (正確には ATtiny13A の命令セット) を分類すると以下のようになります (該当する命令がない箇所は「なし」と記載しています)。

- データ転送命令
  - 汎用データ転送命令 ★: MOV, MOVW, LDI, LD, LDD, LDS, ST, STD, STS, LPM, SPM
  - 交換命令: SWAP
  - スタック操作命令 ★: PUSH, POP
  - 型変換命令: なし
- 2 進算術命令
  - 加算命令と減算命令 ★: ADD, ADC, ADIW, SUB, SUBI, SBC, SBW
  - インクリメント命令とデクリメント命令 ★: INC, DEC
  - 比較命令と符号変更命令 ★: TST, COM, NEG, CP, CPC, CPI
  - 乗算命令と除算命令 ★: なし
- 10 進算術命令
  -パックド BCD 調整命令: なし
  - アンパックド BCD 調整命令: なし
- 論理演算命令 ★: AND, ANDI, OR, ORI, EOR
- シフト命令とローテート命令
  - ビットのシフト命令 ★: LSL, LSR, ROL, ROR, ASR
  - ビットのダブルシフト命令: なし
  - ビットのローテート命令: なし
- ビット命令とバイト命令
  - ビットテストおよび変更命令: SBR, CBR, SBI, CBI
  - ビットスキャン命令: なし
  - 条件付きバイトセット命令: なし
  - テスト命令: なし
- 制御転送命令
  - 無条件転送命令 ★: RJMP, IJMP, RCALL, ICALL, RET, RETI
  - 条件付き転送命令 ★: CPSE, SBRC, SBRS, SBIC, SBIS, BRBS, BRTC, BREQ, BRNE, BRCS, BRCC, BRSH, BRLO, BRMI, BRPL, BRGE, BRLTG, BRHS, BRHC, BRTS, BRTC, BRVS, BRVC, BRIE, BRID
  - ソフトウェア割り込み命令: なし
- ストリング命令: なし
- I/O 命令: IN, OUT
- ENTER 命令と LEAVE 命令: なし
- フラグ制御命令
  - キャリーフラグおよび方向フラグ命令: SEC, CLC
  - EFLAGS 転送命令: BSET, BCLR, SEN, CLN, SEZ, CLZ, SES, CLS, SEV, CLV, SET, CLT, SEH, CLH
  - 割り込みフラグ命令: SEI, CLI
- セグメント・レジスタ命令
  - セグメント・レジスタ・ロードおよびストア命令: なし
  - far 制御転送命令: なし
  - ソフトウェア割り込み命令: なし
  - far ポインタロード命令: なし
- その他の命令
  - アドレス計算命令: なし
  - テーブル・ルックアップ命令: なし
  - プロセッサ識別命令: なし
  - ノー・オペレーション命令と未定義命令 ★: NOP
  - その他の命令: SLEEP, WDR, BREAK

#+begin_note
ATtiny13A の命令数は 120 ですが、
命令のニーモニック数は 96 です。
これは、
異なる命令に同じニーモニックが割り当てられているものがあるからです。
例えば、
\inst{LD r0, X} と \inst{LD r0, Y} はどちらも命令のニーモニックは LD ですが、
それぞれ異なる命令です (命令のオペコードが異なります)。
#+end_note

IA-32 アーキテクチャのソフトウェア開発マニュアル \cite{Intel20:IA32} における命令の分類に合わせているため、
AVR アーキテクチャにはうまく対応しない箇所もあります。

#+begin_note
本書における命令の分類は、
AVR アーキテクチャの命令セットリファレンス \cite{Microchip:AVR-ISA} や各マイクロコントローラのデータシート (例えば \cite{Microchip:ATtiny13A,Microchip:ATmega328P}) とは異なります。

例えば、
文献 \cite{Microchip:ATtiny13A} では、
AVR アーキテクチャの命令セットを以下の 5 種類に分類しています。
- 算術および論理命令 (arithmetic and logic instructions)
- 分岐命令 (branch instructions)
- データ転送命令 (data transfer instructions)
- ビットおよびビットテスト命令 (bit and bit-test instructions)
- MCU 制御命令 (MCU control instructions)
AVR アーキテクチャは RISC で、
命令数もそれほど多くないため、
上記のような単純な分類になっています。

本書では、
IA-32 アーキテクチャや COMET II の命令セットを比較して眺めることができるように、
あえて IA-32 アーキテクチャのソフトウェア開発者マニュアル \cite{Intel20:IA32} の分類に合わせて説明しています。
#+end_note

COMET II の場合と同じように、
多くの箇所が「なし」となっています。
「なし」となっている箇所を削除すると以下が残ります。

- データ転送命令
  - 汎用データ転送命令 ★: MOV, MOVW, LDI, LD, LDD, LDS, ST, STD, STS, LPM, SPM
  - 交換命令: SWAP
  - スタック操作命令 ★: PUSH, POP
- 2 進算術命令
  - 加算命令と減算命令 ★: ADD, ADC, ADIW, SUB, SUBI, SBC, SBW
  - インクリメント命令とデクリメント命令 ★: INC, DEC
  - 比較命令と符号変更命令 ★: TST, COM, NEG, CP, CPC, CPI
- 論理演算命令 ★: AND, ANDI, OR, ORI, EOR
- シフト命令とローテート命令
  - ビットのシフト命令 ★: LSL, LSR, ROL, ROR, ASR
- ビット命令とバイト命令
  - ビットテストおよび変更命令: SBR, CBR, SBI, CBI
- 制御転送命令
  - 無条件転送命令 ★: RJMP, IJMP, RCALL, ICALL, RET, RETI
  - 条件付き転送命令 ★: CPSE, SBRC, SBRS, SBIC, SBIS, BRBS, BRTC, BREQ, BRNE, BRCS, BRCC, BRSH, BRLO, BRMI, BRPL, BRGE, BRLTG, BRHS, BRHC, BRTS, BRTC, BRVS, BRVC, BRIE, BRID
- I/O 命令: IN, OUT
- フラグ制御命令
  - キャリーフラグおよび方向フラグ命令: SEC, CLC
  - EFLAGS 転送命令: BSET, BCLR, SEN, CLN, SEZ, CLZ, SES, CLS, SEV, CLV, SET, CLT, SEH, CLH
  - 割り込みフラグ命令: SEI, CLI
- その他の命令
  - ノー・オペレーション命令と未定義命令 ★: NOP
  - その他の命令: SLEEP, WDR, BREAK

これを眺めていると、
AVR アーキテクチャの命令セットの特徴が何となく見えてくると思います。

COMET II の場合と同じように、
重要な命令 ([[sec:x86regs/category]] 節において★を付けたカテゴリの命令) はほとんどそろっていることがわかります。
★を付けたカテゴリで、
ATtiny13A に対応する命令が存在しないのは

  - 乗算命令と除算命令 ★: なし

だけです。

#+begin_note
なお、
ATtiny13A には乗算命令や除算命令はありませんが、
より高機能なマイクロコントローラ (例えば ATmega328P) には乗算命令や除算命令が追加されています。
#+end_note

*** アドレス指定モード

AVR アーキテクチャの命令は、
オペランドを 0〜2 個取ります。
AVR アーキテクチャは RISC なので、
オペランドの指定方法は比較的単純です。

AVR アーキテクチャのオペランドは、
以下のいずれかの形式を取ります。
命令のニーモニックを op、
レジスタを \r{i}、
\r{j}、
定数を $c$ と表記します。
また、
特に 16 ビットレジスタ (レジスタ X、
Y、
Z) を \ri{i} のように表記します。

| オペランドなし                       | op                     |                         |
| レジスタ 1 個                        | op \r{i}               |                         |
| 定数 1 個                            | op $c$                 |                         |
| レジスタ 2 個                        | op \r{i}, \r{j}        |                         |
| レジスタと定数                       | op \r{i}, $c$          | op $c$, \r{i}           |
| レジスタ 2 個 (ポストインクリメント) | op \r{i}, \ri{j}+      | op \ri{i}+, \r{j}       |
| レジスタ 2 個 (プリデクリメント)     | op -\ri{i}, \r{j}      | op \r{i}, -\ri{j}       |
| レジスタ 2 個 (変位あり)             | op \ri{i} + $c$, \r{j} | op \ri{i}, \ri{j} + $c$ |
| 定数 2 個                            | op $c$, $c'$           |                         |

IA-32 アーキテクチャや COMET II と同じように、
オペランドにはレジスタ \r{i} や定数 $c$ が指定できます。

IA-32 アーキテクチャや COMET II には見られない、
「\ri{i}+」や「-\ri{i}」のような、
レジスタの前後にプラスやマイナスの付いたオペランドがあります。
これらは、
それぞれ *ポストインクリメント (post-increment)* および *プリデクリメント (pre-decrement)* を意味します。

#+begin_note
ポストインクリメントおよびプリデクリメントについては後ほど説明します。
#+end_note

「\ri{i} + $c$」というオペランドにおける $c$ は、
*変位 (ディスプレイスメント; displacement)* です。
IA-32 アーキテクチャの間接メモリ参照 ([[sec:gas/ia32-specific]] 節) はかなり複雑でした。
一方、
AVR アーキテクチャのオペランドは、
せいぜい「16 ビットレジスタ + 変位」という単純な形式のみです。

- オペランドなし: op

  サブルーチンから戻る RET 命令や、
  フラグレジスタを設定する SEZ 命令、
  何も処理を行わない NOP 命令などはオペランドを取りません。

  例を示します。
  #+begin_src asm
  	ret	; サブルーチンから戻る
  #+end_src

- レジスタ 1 個: op \r{i}

  オペランドとしてレジスタを 1 つ指定します。
  オペランドに指定したレジスタの値を操作する命令で用いられます。

  レジスタの値を 1 だけ増加する INC 命令や、
  レジスタの値を左に 1 ビットシフトする LSL 命令、
  レジスタの値をスタックにプッシュする PUSH 命令などで用いられます。

  例を示します。
  #+begin_src asm
  	inc	r0	; レジスタ R0 の値を +1
  	lsl	r1	; レジスタ R1 を左に 1 ビットシフト
  	push	r2	; レジスタ R2 の値をスタックにプッシュ
  #+end_src

- 定数 1 個: op $c$

  オペランドとして定数を 1 つだけ指定する命令では、
  定数は即値やアドレス、
  I/O レジスタ番号、
  ビット番号などを意味します (何を意味するかはそれぞれの命令によります)。

  現在のプログラムカウンタから相対ジャンプする RJMP 命令、
  現在のプログラムカウンタから相対アドレスをサブルーチンコールする RCALL 命令、
  特定のフラグレジスタをセットする BSET 命令などで  用いられます。

  例を示します。
  #+begin_src asm
  	rjmp	128	; PC + 128 + 1 番地へジャンプ
  	rjmp	-128	; PC - 128 + 1 番地へジャンプ
	rcall	1024	; PC + 1024 + 1 番地をコール
	rcall	-1024	; PC - 1024 + 1 番地をコール
	bset	1	; ゼロフラグを 1 にする
  #+end_src

- レジスタ 2 個: op \r{i}, \r{j}

  オペランドとしてレジスタを 2 つ指定する命令です。
  AVR アーキテクチャのアセンブリ言語では、
  IA-32 アーキテクチャの AT&T 記法とは異なり、
  2 つのオペランドは「宛先オペランド, 出所オペランド」の順番に並びます。
  
  2 つのレジスタの値を加算する ADD 命令、
  2 つのレジスタの値を比較する CP 命令、
  あるレジスタの値を他のレジスタにコピーする MOV 命令、
  インデックスレジスタが差すデータ用メモリの値をレジスタに読み込む LD 命令などで用いられます。
  
  レジスタには、
  汎用レジスタ R0〜R31 や、
  16 ビットのレジスタ X、
  Y、
  Z (実体はそれぞれ R27:R26、
  R29:R28、
  R31:R30 というレジスタペア) を指定できます。
  これも、
  オペランドにどのレジスタが指定できるかは命令ごとに  異なります。

  例を示します。
  #+begin_src asm
  	add	r0, r1	; レジスタ R1 の値をレジスタ R0 に加算
	cp	r2, r3	; (R2 - R3) に応じてフラグレジスタを設定
	mov	r4, r5	; レジスタ R5 の値をレジスタ R4 に格納
	ld	r6, X	; レジスタ X が差すデータ用メモリの値をレジスタ R6 に読み込む
  #+end_src

  最後の \inst{ld r6, X} だけは少し特殊なパターンで、
  16 ビットのレジスタ X (実体は R27:R26 レジスタ) に、
  値を読み込みたいデータ用メモリのアドレスを事前に格納しておき、
  レジスタ X が差すアドレスの値をレジスタ R6 に読み込みます。
  LD 命令の出所オペランドには、
  16 ビットレジスタである、
  レジスタ X、
  Y、
  Z のいずれかしか指定できません。

  #+begin_note
  AVR アーキテクチャでは、
  プログラム用メモリとデータ用メモリが独立しています ([[sec:avr/arch]] 節)。
  このため、
  プログラム用メモリにアクセスするための命令と、
  データ用メモリにアクセスするための命令が完全に異なっています。
  
  例えば、
  データ用メモリに格納されている値をレジスタに読み込む命令は、
  LD 命令、
  LDS 命令、
  LDD 命令ですが、
  プログラム用メモリに格納されている値をレジスタに読み  込む命令は LPM 命令です。
  
  プログラム用メモリとデータ用メモリが分かれているというのは、
  慣れるまではしばらく混乱するかもしれません (筆者も混乱しました)。
  しかも、
  プログラム用メモリのアドレスの単位は 16 ビットで、
  データ用メモリのアドレスの単位が 8 ビットと異なっているため、
  さらに混乱します。
  #+end_note

- オペランド 2 個: op \r{i}, $c$

  第 1 オペランドにレジスタ、
  第 2 オペランドに定数を指定します。
  
  AVR アーキテクチャのアセンブリ言語では、
  2 つのオペランドは「宛先オペランド、
  出所オペランド」の順番でした。
  このため、
  主に出所オペランドに指定した定数に従って、
  宛先レジスタに指定されたレジスタの値を操作する命令で用いられます。

  レジスタの値から即値を減算する SUBI 命令や、
  レジスタに格納されている値の特定のビットのみを 1 にする SBR 命令、
  レジスタの値を即値と比較する CPI 命令、
  レジスタに即値を読み込む LDI 命令などで用いられます。

  例を示します。
  #+begin_src asm
	subi	r16, 123	;レジスタ R16 から 123 を減算
	sbr	r17, 3		;レジスタ R17 の下位 2 ビットを 1 に
	cpi	r18, 45		;レジスタ R18 の値と 45 を比較
	ldi	r19, -1		;レジスタ R19 に -1 を格納
  #+end_src

  #+begin_note
  上で例に挙げた命令では、
  宛先オペランドに指定できるレジスタはレジスタ R16〜R31 のみです。
  レジスタ R0〜R15 はオペランドに指定できません。
  
  命令長を 16 ビットに抑えるために、
  オペランドの一方が定数の場合は、
  もう一方のオペランドに指定できる汎用レジスタの種類に  制限があるようです。
  #+end_note

  AVR アーキテクチャの命令の多くは 2 バイト (16 ビット) です。
  つまり、
  オペコードと 2 つのオペランドを 16 ビットで表現します。
  このため、
  多くの命令では、
  定数 $c$ にはたかだか 8 ビットの値しか指定できません。
  命令長が 4 バイト (32 ビット) の一部の命令には、
  16 ビットかそれ以上の定数 (例えばアドレス) を指定できるものもあります。

- オペランド 2 個: op $c$, \r{i}

  上の「op \r{i}, $c$」におけるオペランドが入れ替わったパターンです。
  第 1 オペランドに定数、
  第 2 オペランドにレジスタを指定します。
  
  宛先オペランドと出所オペランドが入れ替わっていること以外は、
  上の「op \r{i}, $c$」と同じです。

- オペランド 2 個: op $c$, $c'$

  第 1 オペランド、
  第 2 オペランドともに定数を指定します。
  IA-32 アーキテクチャにも、
  COMET II にもない、
  少し珍しいパターンです。
  
  フラグレジスタの特定のビットを条件として相対ジャンプする BRBS 命令や、
  指定した I/O レジスタの特定のビットをセットする SBI 命令などで  用いられます。
  
  これも例を示します。
  #+begin_src asm
  	brbs	6, 128	; フラグレジスタの 6 ビット目が 1 であれば PC + 128 + 1 にジャンプ
  	sbi	0x1c, 0	; I/O レジスタ 0x1c の 0 ビット目を 1 に
  #+end_src

- オペランド 2 個: その他のパターン

  上で説明したオペランドの組み合わせ以外にも、
  以下のような形式のオペランドがあります。
  - \ri{i}+ (ポストインクリメント)
  - -\ri{i} (プリデクリメント)
  - \ri{i} + $c$ (レジスタ + 変位)
  
  ポストインクリメントとプリデクリメントは、
  16 ビットのレジスタ X、
  Y、
  Z にのみ指定できます。
  ポストインクリメントは、
  命令で指定した処理の実行のあとにレジスタの値を 1 だけ増加させます。
  プリデクリメントは、
  命令で指定した処理の実行の前にレジスタの値を 1 だけ減少させます。
  
  例えば、
  #+begin_src asm
  	ldi	r26, 0x80	; アドレスの下位 8 ビット
  	ldi	r27, 0x01	; アドレスの上位 8 ビット
  	ld	r0, X		; 0x0180 番地の値を R0 に読み込み
  #+end_src
  は、
  データ用メモリの 0x0180 番地に格納されている、
  8 ビットの値をレジスタ R0 に読み込みます。
  レジスタ X の実体は R27:R26 レジスタなので、
  レジスタ R27 に上位アドレスの 0x01 を、
  レジスタ R26 に下位アドレスの 0x80 を格納しています。
  レジスタ X の間接アドレッシングによって 0x0180 番地の値を読み  込んでいます。
  
  ここでポストインクリメントを使用して、
  #+begin_src asm
  	ldi	r26, 0x80	; アドレスの下位 8 ビット
  	ldi	r27, 0x01	; アドレスの上位 8 ビット
  	ld	r0, X+		; 0x0180 番地の値を R0 に読み込み
  	ld	r1, X+		; 0x0181 番地の値を R1 に読み込み
  	ld	r2, X+		; 0x0182 番地の値を R2 に読み込み
  	ld	r3, X+		; 0x0183 番地の値を R3 に読み込み
  #+end_src
  のように記述すると、
  0x0180 番地〜0x0183 番地の値が、
  それぞれレジスタ R0〜R3 に格納されます。
  \inst{ld r0, X+} は、
  レジスタ X が差すデータ用メモリの値をレジスタ R0 に格納した *あと* に、
  レジスタ X の値を 1 だけ増加します。
  これにより、
  レジスタ X の値が 0x0181 に増加します。
  以降の命令では、
  レジスタ X の値を 1 つずつ増加させながらデータ用メモリの値を読み込んでいます。
  
  プリデクリメントはこの逆です。
  例えば、
  #+begin_src asm
  	ldi	r26, 0x80	; アドレスの下位 8 ビット
  	ldi	r27, 0x01	; アドレスの上位 8 ビット
  	ld	r0, -X		; 0x017f 番地の値を R0 に読み込み
  	ld	r1, -X		; 0x017e 番地の値を R1 に読み込み
  	ld	r2, -X		; 0x017d 番地の値を R2 に読み込み
  	ld	r3, -X		; 0x017c 番地の値を R3 に読み込み
  #+end_src
  のように記述すると、
  0x017c 番地〜0x017f 番地の値が、
  それぞれレジスタ R0〜R3 に格納されます。
  ポストインクリメントとは反対に、
  命令で指定した処理 (データ用メモリの値のレジスタへの読み込み) の *前* にレジスタ X の値が 1 だけ減少します。
  
  メモリ上の連続したアドレスに格納されている値を、
  順番に読み込んだり書き込んだりする処理は頻繁に行われます。
  このため、
  AVR アーキテクチャでは、
  16 ビットレジスタの増減と、
  メモリとレジスタ間のデータ転送を、
  まとめて 1 命令でできるようになっています。

  もちろん、
  ポストインクリメントやプリデクリメントを使わずに、
  #+begin_src asm
  	ldi	r26, 0x80	; アドレスの下位 8 ビット
  	ldi	r27, 0x01	; アドレスの上位 8 ビット
  	ld	r0, X		; 0x0180 番地の値を R0 に読み込み
  	adiw	r27:r26, 1	; レジスタ X を +1
  	ld	r1, X		; 0x0181 番地の値を R1 に読み込み
  	adiw	r27:r26, 1	; レジスタ X を +1
  	ld	r2, X		; 0x0182 番地の値を R2 に読み込み
  	adiw	r27:r26, 1	; レジスタ X を +1
  	ld	r3, X		; 0x0183 番地の値を R3 に読み込み
  	adiw	r27:r26, 1	; レジスタ X を +1
  #+end_src
  のように書いてもかまいません。
  ただしこの場合には、
  プログラムの大きさも、
  プログラムの実行時間もどちらも 2 倍になります。

  最後の「\ri{i} + $c$」というパターンは、
  「レジスタ + 変位」という形式で、
  レジスタの値に定数を加算した値を意味します。
  
  ただし、
  オペランドに「レジスタ + 変位」が指定できる命令はごく少数に限られます。

  オペランドに「レジスタ + 変位」が指定できるのは、
  データ用メモリに格納された値をレジスタに読み込む LDD 命令、
  レジスタの値をデータ用メモリに書き込む STD 命令くらいです。
  変位のあり/なしで、
  命令のニーモニックも異なることに注意してください。
  
  例を示します。
  #+begin_src asm
  	ld	r0, X		; X が差す番地の値を R0 に読み込み
  	ld	r1, Y		; Y が差す番地の値を R1 に読み込み
  	ldd	r2, Y+1		; (Y の値 + 1) 番地の値を R2 に読み込み
  	ld	r3, Z		; Z が差す番地の値を R3 に読み込み
  	ldd	r4, Z+16	; (Z の値 + 16) 番地の値を R4 に読み込み
  #+end_src
  
  #+begin_note
  LDD 命令の出所オペランドに指定できるのはレジスタ Y および Z のみ、
  変位に指定できるのは 0〜63 の数値のみです。
  指定できるレジスタにも、
  指定できる変位の値にもかなり強い制約があるため注意してください。
  #+end_note

** AVR 命令セット (データ転送)
<<sec:avr/trans>>

*** 汎用データ転送命令

以下では、
AVR アーキテクチャの主要な命令を順番に説明します。
ここで説明するのは、
あくまで主要な命令だけなので注意してください。
その他の命令については、
AVR アーキテクチャの命令セットマニュアル \cite{Microchip:AVR-ISA} を参照してください。

まずはデータ転送命令です。
データ転送命令とは、
汎用レジスタの間でデータをコピーしたり、
メモリと汎用レジスタの間でデータをコピーしたり、
即値 (immediate value) をレジスタに書き込むための命令でした ([[ch:x86trans]] 章)。
スタックへのプッシュやポップもデータ転送命令に含まれます。

AVR アーキテクチャのデータ転送命令は以下の 13 個です。
表の右端には、
それぞれの命令の動作を CPU の抽象モデルで記述しています。
AVR アーキテクチャにはプログラム用メモリとデータ用メモリの 2 種類がありますが、
そのうちアドレス $m$ のプログラム用メモリへのアクセスを [$m$}^P、
アドレス $m$ のデータ用メモリへのアクセスを [$m$] と表記しています。

| ニーモニック                       | 説明                                                       |
|------------------------------------+------------------------------------------------------------|
| MOV \r{i}, \r{j}                   | \r{j} の値を \r{i} に格納                                  |
| (Move between Registers)           | \r{i} ← \r{j}                                             |
| MOVW \r{i}, \r{j}                  | \r{j+1}、\r{j} の値をそれぞれ \r{i+1}、\r{i} にコピー      |
| (Copy Register Word)               | \r{i+1}:\r{i} ← \r{j+1}:\r{j}                             |
| LDI \r{i}, $c$                     | 即値 $c$ をレジスタ \r{i} に格納                           |
| (Load Immediate)                   | \r{i} ← $c$                                               |
| LD \r{i}, \ri{j}                   | \ri{j} が差すデータ用メモリの値を \r{i} に読み込み         |
| (Load Indirect)                    | \r{i} ← [\ri{j}]                                          |
| LDD \r{i}, \ri{j} + $c$            | \ri{j} + $c$ が差すデータ用メモリの値を \r{i} に読み込み   |
| (Load Indirect with Displacement)  | \r{i} ← [\ri{j} + $c$]                                    |
| LDS \r{i}, $m$                     | $m$ 番地のデータ用メモリの値を \r{i} に読み込む            |
| (Load Direct from SRAM)            | \r{i} ← [$m$]                                             |
| ST \ri{i}, \r{j}                   | データ用メモリの \ri{i} 番地に \r{j} の値を書き込む        |
| (Store Indirect)                   | [\ri{i}] ← \r{j}                                          |
| STD \ri{i} + $c$, \r{j}            | データ用メモリの \ri{i} + $c$ 番地に \r{j} の値を書き込む  |
| (Store Indirect with Displacement) | [\ri{i} + $c$] ← \r{j}                                    |
| STS $m$, \r{i}                     | データ用メモリの $m$ 番地に \r{i} の値を書き込む           |
| (Store Direct to SRAM)             | [$m$] ← \r{i}                                             |
| LPM                                | プログラム用メモリの Z 番地の値を R0 に読み込む            |
| (Load Program Memory)              | R0 ← [Z]^P                                                |
| LPM \r{i}, Z                       | レジスタ Z が指すプログラム用メモリの値を \r{i} に読み込む |
| (Load Program Memory)              | \r{i} ← [\ri{j}]^P                                        |
| SPM                                | プログラム用メモリの Z 番地にレジスタ R1:R0 の値を格納する |
| (Store Program Memory)             | [Z]^P ← R1:R0                                             |

IA-32 アーキテクチャでは、
MOV という共通のニーモニックを、
さまざまな種類のデータ転送の命令に用いていました。
レジスタに即値を格納する命令も、
あるレジスタの値を他のレジスタにコピーする命令も、
メモリに格納されている値をレジスタに読み込む命令も、
レジスタの値をメモリに格納する命令も、
すべて MOV という共通のニーモニックを使用していました。

#+begin_note
命令のニーモニックは共通ですが、
オペランドの種類 (つまり、
データ転送の種類) によって命令のオペコードの値は異なります。
機械語のオペコードは異なるのですが、
IA-32 アーキテクチャのアセンブリ言語では、
すべて共通のニーモニック MOV を使用しています。

このため、
命令セットアーキテクチャという観点では、
「IA-32 アーキテクチャも AVR アーキテクチャも、
オペランドの種別が異なるデータ転送命令には異なるオペコードを割り当てている」という意味では同じようなものだといえます。
ただし、
IA-32 アーキテクチャのアセンブリ言語では、
オペランドの種別が異なるデータ転送命令にも共通の MOV というニーモニックを割り当ててています。
一方、
AVR アーキテクチャのアセンブリ言語では、
オペランドの種別が異なるデータ転送命令には異なるニーモニックを割り当てています。

このため、
「IA-32 アーキテクチャではいろいろなデータ転送に MOV 命令が用いられる」というのは、
より厳密に言えば、
IA-32 アーキテクチャの命令セットの特徴ではなく、
IA-32 アーキテクチャ向けのアセンブリ言語の特徴であることに注意してください。
#+end_note

一方、AVR アーキテクチャでは、
1. ハーバード・アーキテクチャを採用しており、プログラム用メモリとデー
   タ用メモリが独立している
2. メモリへのアクセスには、16 ビットのレジスタ X、Y、Z を使用した間接
   アドレッシングを主に用いる
ということもあり、
データ転送の種別ごとに異なる命令が用意されているようです。

AVR アーキテクチャのデータ転送命令の特徴的な点をいくつか説明します。
それぞれの命令の詳細については、
AVR アーキテクチャの命令セットマニュアル \cite{Microchip:AVR-ISA} を参照してください。

MOVW 命令は、
レジスタのペアの値を、
別のレジスタのペアにコピーするという変わった命令です。
例えば、
#+begin_src asm
	movw	r28, r26	; R27:R26 を R29:R28 にコピー
#+end_src
では、
単一の MOVW 命令だけで、
「レジスタ R26 の値がレジスタ R28 にコピー」され、
さらに「レジスタ R27 の値がレジスタ R29 にコピー」されます。

AVR アーキテクチャの汎用レジスタ R0〜R31 はすべて 8 ビットのレジスタでした。
このため、
16 ビット以上の大きさのデータを扱う場合には、
8 ビットのレジスタを複数使用する必要があります。
例えば、
16 ビットのデータの下位 8 ビットをレジスタ R26 に格納し、
16 ビットのデータの上位 8 ビットをレジスタ R27 に格納します。
これにより、
R27:R26 というレジスタのペアを、
16 ビットのデータの格納に使用できます。
AVR アーキテクチャには、
こういったレジスタのペアの値をまとめてコピーするための命令が用意されているのです。
なお、
MOVW 命令のオペランドには、
偶数番の汎用レジスタ (R0、
R2、
R4 \dots) のみ指定できます。

LDI 命令は、
オペランドに指定した即値をレジスタに読み込む命令です。
#+begin_src asm
	ldi	r16, 123	; レジスタ R16 に 123 を格納
#+end_src
これにより、
レジスタ R16 に 123 が読み込まれます。

AVR アーキテクチャの汎用レジスタの大きさは 8 ビットです。
LDI 命令の出所オペランドには、
当然、
8 ビットの即値 (0〜255) が指定できます。
ただし、
LDI 命令の宛先オペランドに指定できる汎用レジスタは、
R16〜R31 のいずれかです。
レジスタ R0〜R15 は指定できません。

LD 命令は、
出所オペランドに指定したレジスタ (レジスタ X、
Y、
Z のいずれか) が差すデータ用メモリに格納されている値を、
宛先オペランドに指定したレジスタに読み込みます。
例えば、
#+begin_src asm
	ld	r0, X	; X が差すデータ用メモリの番地の値を読み込む
#+end_src
とすれば、
レジスタ X (実体はレジスタ R27:R26) に格納されている値をデータ用メモリのアドレスと見なし、
そのアドレスに格納されている値をレジスタ R0 に読み込みます。

出所オペランドの 16 ビットレジスタには、
以下のように、
ポストインクリメントやプレデクリメントを指定することもできます。
#+begin_quote
	ld	r0, X+	; X が指す番地の値を読み込んだあとに X を +1
	ld	r0, -X	; X を -1 したあとで、X が指す番地の値を読み込む
#+end_quote

次の LDD 命令は、
LD 命令と類似した命令ですが、
出所オペランドに *変位 (ディスプレイスメント)* を指定することができます。
例えば、
#+begin_src asm
	ldd	r0, Y+1		; (Y の値 + 1) 番地の値を読み込み
	ldd	r1, Y+16	; (Y の値 + 16) 番地の値を読み込み
#+end_src
とすれば、
「レジスタ Y の値 + 1」番地に格納されているデータ用メモリの値がレジスタ R0 に読み込まれます。
同様に、
「レジスタ Y の値 + 16」番地に格納されているデータ用メモリの値がレジスタ R1 に読み込まれます。

AVR アーキテクチャにおける変位は、
利用できる場面が限られるため、
うまく使いこなすのは難しいかもしれません。
というのも、
AVR アーキテクチャの基本命令セットにおいて、
オペランドに変位が指定できるのは LDD 命令と STD 命令の 2 つだけです。
それ以外の命令のオペランドには変位を指定できません。
また、
LDD 命令の出所オペランドに指定できるのはレジスタ Y と Z だけです (レジスタ X は指定できません)。
これに加えて、
変位には 0〜63 の値しか指定できません。
負の値も、
64 以上の値も指定できません。

LDS 命令は、
出所オペランドの値をアドレスと見なし、
データ用メモリの当該アドレスに格納されている値を、
宛先オペランドに指定されているレジスタに読み込みます。
例えば、
#+begin_src asm
	lds	r0, 0x0180	; データ用メモリの 0x0180 番地の値を読み込む
#+end_src
とすれば、
データ用メモリの 0x0180 番地に格納されている値をレジスタ R0 に読み込みます。

ST 命令、
STD 命令、
STS 命令は、
ロード命令 (LD 命令、
LDD 命令、
LDS 命令) の対になるストア命令です。
ロード命令はメモリから値を読み込みますが、
ストア命令はメモリに値を書き込みます。
出所オペランドと宛先オペランドが逆になっているという点を除き、
ストア命令のオペランドの形式は対応するロード命令と同じです。

ロード命令と、
それぞれのロード命令に対応するストア命令の例を示します。
#+begin_src asm
	; 間接メモリ参照
	ld	r0, X		; X が指す番地の値を R0 に読み込み
	st	X, r0		; R0 の値を X が差す番地に書き込み
	; 間接メモリ参照 (ポストインクリメント)
	ld	r0, X+		; X が指す番地の値を R0 に読み込んで、X を +1 する
	st	X+, r0		; R0 の値を X が指す番地に書き込んで、X を +1 する
	; 間接メモリ参照 (ディスプレイスメント付き)
	ldd	r0, Y+1		; (Y の値 + 1) 番地の値を R0 に読み込み
	std	Y+1, r0		; R0 の値を (Y の値 + 1) 番地に書き込み
	; 直接メモリ参照
	lds	r0, 0x0180	; 0x0180 番地の値を R0 に読み込み
	sts	0x0180, r0	; R0 の値を 0x0180 番地に書き込み
#+end_src
命令のニーモニックの LD が ST になり、
出所オペランドと宛先オペランドがそのまま入れ替わっていることがわかります。

LPM 命令と SPM 命令は、
IA-32 アーキテクチャや COMET II には見られない命令です。
これらの命令は、
データ用メモリではなくプログラム用メモリを読み書きするための専用の命令です。
[[sec:avr/arch]] 節で述べたように、
AVR アーキテクチャではプログラム用メモリとデータ用メモリが独立しています。
このため、
AVR アーキテクチャでは、
プログラム用メモリにアクセスするための専用の命令が用意されています。

LPM 命令では、
レジスタ Z の値が指すプログラム用メモリの値を、
宛先オペランドに指定されたレジスタに読み込みます。
出所オペランドにはレジスタ Z しか指定できません。
宛先オペランドには汎用レジスタ R0〜R31 のいずれかを指定できます。

AVR アーキテクチャでは、

- プログラム用メモリのアドレスの単位は 16 ビット (2 バイト) である
- したがって、プログラム用メモリのそれぞれのアドレスには 16 ビット (2
  バイト) が格納されている
- 汎用レジスタ R0〜R31 の大きさは 8 ビットである
- レジスタ Z の大きさは 16 ビットである
という構成になっているため、LPM 命令の動作にも少し癖があり、
- LPM 命令の 1 回の実行ではプログラム用メモリに格納されている値のうち、
  上位/下位どちらか 8 ビットを読み出す
- レジスタ Z の上位 15 ビットがプログラム用メモリのアドレスを表す
- レジスタ Z の最下位ビットが 16 ビットの値の上位バイトか下位バイトか
  を表す
というややこしい仕様になっています。

したがって、
例えば、
プログラム用メモリの 0x100 (ワード) 番地に格納されている 16 ビットの値をレジスタ R1:R0 に読み出すには、
#+begin_src asm
	ldi	r30, 0x00	; (0x0100 << 1) の下位 8 ビット
	ldi	r31, 0x20	; (0x0100 << 1) の上位 8 ビット
	lpm	r0, Z+		; r0 ← [0x0100] の下位 8 ビット
	lpm	r1, Z		; r1 ← [0x0100] の上位 8 ビット
#+end_src
のように記述します。

#+begin_note
SPM 命令は、
LPM 命令の対になる命令で、
プログラム用メモリに書き込むための命令です。
ただし、
AVR アーキテクチャのマイクロコントローラのプログラム用メモリはフラッシュメモリであり、
通常は書き込みができません。

AVR アーキテクチャのマイクロコントローラでは、
定められた手順に従って特定の I/O レジスタを操作すれば、
プログラムからフラッシュメモリを (ワード単位ではなくページ単位で) 書き換えることは可能です。
ただし、
単純に以下のような方法でプログラム用メモリを書き換えることは *できません*。
#+begin_src asm
	; 動作しないプログラム
	ldi	r30, 0x00	; (0x0100 << 1) の下位 8 ビット
	ldi	r31, 0x20	; (0x0100 << 1) の上位 8 ビット
	ldi	r15, 0x34
	ldi	r16, 0x12
	spm	r15, Z+		; [0x0100] の下位 8 ビット ← 0x34
	spm	r16, Z		; [0x0100] の上位 8 ビット ← 0x12
#+end_src
#+end_note

繰り返しになりますが、AVR アーキテクチャでは
- プログラム用メモリとデータ用メモリが独立している
- このため、プログラム用メモリとデータ用メモリへのアクセスには別の命令
  を使う
- プログラム用メモリへのアクセスは、レジスタ Z を介した間接アドレス参
  照しかできない
- プログラム用メモリのアドレスの単位はワード (2 バイト) である
- LPM 命令のレジスタ Z の最下位ビットは、読み込む値が上位バイトか下位
  バイトかを表す
という点が混乱しやすいので注意してください。

*** スタック操作命令

| ニーモニック              | 説明                                     |
|---------------------------+------------------------------------------|
| PUSH \r{i}                | スタックに \r{i} の値をプッシュ          |
| (Push Register on Stack)  | [\sp] ← \r{i}, \sp ← <-> 1             |
| POP \r{i}                 | スタックの値をポップし、\r{i} に格納する |
| (Pop Register from Stack) | \sp ← <+> 1, \r{i} ← [\sp]             |

AVR アーキテクチャのスタック操作命令はいたって標準的です。
PUSH 命令や POP 命令のオペランドに指定できるのは汎用レジスタ R0〜R31 のみです。
IA-32 アーキテクチャのように、
オペランドに即値やメモリロケーションなどは指定できません。

一点注意が必要なのは、
AVR アーキテクチャにおけるスタックポインタは、
IA-32 アーキテクチャや COMET II のスタックポインタとは意味が少し異なっているということです。

- IA-32 アーキテクチャや COMET II のスタックポインタ

  現在、
  スタックの一番上にあるデータが格納されているアドレスを表します。
  したがって、
  新しくデータをプッシュする場合は、
  スタックポインタの値を減らしてからデータを格納します。
  データをポップする場合は、
  スタックポインタが差すアドレスのデータを取得してから、
  スタックポインタの値を増やします。

- AVR アーキテクチャのスタックポインタ

  次にデータを格納すべきアドレス (スタックの一番上のデータが格納されているアドレス - 1)」を表します。
  したがって、
  新しくデータをプッシュする場合は、
  スタックポインタが差すアドレスにデータを格納したあとで、
  スタックポインタの値を -1 します。
  データをポップする場合は、
  スタックポインタの値を + 1 したあとで、
  スタックポインタが差すアドレスのデータを取得します。

このため、
例えば、
COMET II におけるスタックポインタの初期値は、
例えば 0x0000 番地になります。
COMET II では、
最初にプッシュされたデータは、
0x0000 が -1 されたあとの 0xffff 番地に格納されます。
スタックポインタの値は 0xffff となり、
直前にプッシュされたデータのアドレスを差します。

一方、
ATtiny13A におけるスタックポインタの初期値は、
通常は 0x009f 番地になります。
ATtiny13A では、
最初にプッシュされたデータが 0x009f 番地に格納されます。
その後、
スタックポインタの値が -1 されて 0x009e となり、
次にデータを格納すべきアドレスを差します。

IA-32 アーキテクチャと比較したときの、
AVR アーキテクチャのデータ転送命令の特徴は以下のようになります。

- データの大きさはほとんどが 1 バイト (8 ビット)
- 16 ビットレジスタを指定する一部の命令のオペランドでは、ポストインク
  リメントとプレデクリメントが使用できる (ものもある)
- 16 ビットレジスタ (レジスタ X、Y、Z) を使用した間接メモリ参照が中心
- ごく一部の命令でしかメモリロケーションに変位 (ディスプレイスメント)
  が指定できない
- ロード命令とストア命令にそれぞれ異なるニーモニックが用意されている
- プログラム用メモリとデータ用メモリが独立しており、それぞれへのアクセ
  スには異なる命令を使用する
- PUSH 命令、POP 命令のオペランドには汎用レジスタしか指定できない
- スタックポインタの値は、スタックのトップではなく「次に格納すべきデー
  タのアドレス」を差す

** AVR 命令セット (算術演算、論理演算)
<<sec:avr/arith>>

*** 加算命令と減算命令

| ニーモニック                             | 説明                                             |
|------------------------------------------+--------------------------------------------------|
| ADD \r{i}, \r{j}                         | \r{i} に \r{j} の値を加算する                    |
| (Add two Registers)                      | \r{i} ← <+> \r{j}                               |
| ADC \r{i}, \r{j}                         | \r{i} に \r{j} の値をキャリー付きで加算する      |
| (Add with Carry Registers)               | \r{i} ← <+> (\r{j} + \cf)                       |
| ADIW \r{i}, $c$                          | レジスタのペア \r{i+1}:\r{i} に $c$ を加算する   |
| (Add Immediate to Word)                  | \r{i+1}:\r{i} ← <+> $c$                         |
| SUB \r{i}, \r{j}                         | \r{i} から \r{j} を減算する                      |
| (Subtract two Registers)                 | \r{i} ← <-> \r{j}                               |
| SUBI \r{i}, $c$                          | \r{i} から $c$ を減算する                        |
| (Subtract Constant from Register)        | \r{i} ← <-> $c$                                 |
| SBC \r{i}, \r{j}                         | \r{i} から \r{j} をキャリー付きで減算する        |
| (Subtract with Carry two Registers)      | \r{i} ← <-> (\r{j} + \cf)                       |
| SBCI \r{i}, $c$                          | \r{i} から $c$ を減算する                        |
| (Subtract with Carry Constant from Reg.) | \r{i} ← <-> ($c$ + \cf)                         |
| SBIW \r{i}, $c$                          | レジスタのペア \r{i+1}:\r{i} から $c$ を減算する |
| (Subtract Immediate from Word)           | \r{i+1}:\r{i} ← <-> $c$                         |

AVR アーキテクチャの命令セットには、
基本的な加算および減算の算術演算命令が用意されています。

[[sec:avr/inst]] 節で述べたように、
本書では ATtiny13A の命令セットを例に挙げて説明しています。
AVR アーキテクチャのマイクロコントローラによって命令セットは一部異なりますが、
ATtiny13A には乗算や除算のための命令がありません。
ATtiny13A で、
乗算や除算を行うためには、
乗算や除算を行うプログラムを別途用意する必要があります。

汎用レジスタどうしの加算や減算は、
キャリーあり (ADD 命令および SUB 命令) とキャリーなし (ADC 命令および SBC 命令) の 2 種類が用意されています。

なお、
IA-32 アーキテクチャとは異なり、
加算命令および減算命令のオペランドには、
メモリロケーションは指定できません。
AVR アーキテクチャは RISC であるため、
メモリ上に格納されている値に対して算術演算や論理演算を直接行うことはできません。
メモリ上に格納されている値に対して演算を行う場合には、
1. メモリの値をレジスタに読み込む
2. レジスタの値に対して演算を行う
3. その後、演算結果をメモリに書き戻す
のように、必ずレジスタを介して演算する必要があります。

AVR アーキテクチャの算術命令を眺めて、
「あれ、
変だな」と思ったかもしれません。
加算命令と減算命令がそっくり (あるオペランドの組み合わせの加算命令があれば、
同じオペランドの組み合わせの減算命令がある) なのですが、
一部例外があるのです。
というのも、
レジスタから即値を減算する命令 (SUBI 命令) はあるものの、
レジスタに即値を加算する命令が存在しないのです。
つまり、
#+begin_src asm
	ldi	r16, 123	; R16 に 123 を読み込む
	subi	r16, 1		; R16 から 1 を減算する
#+end_src
のようにレジスタの値から即値 1 を減算することはできるのですが、
これに対応する
#+begin_src asm
	ldi	r16, 123	; R16 に 123 を読み込む
	addi	r16, 1		; このような命令は存在しない!
#+end_src
のような命令は存在 *しない* のです。

このため、
レジスタの値に即値を加算したい場合は、
「加算したい値の 2 の補数 ([[sec:number/binary]] 節) を SUBI 命令を使って減算する」ことで代用します。
例えば、
上記のレジスタ R16 に 1 を加算するプログラムは、
#+begin_src asm
	ldi	r16, 123	; R16 に 123 を読み込む
	subi	r16, -1		; R16 - (-1) = r16 + 1 と同じ
#+end_src
のように書きます。

#+begin_note
「即値を減算する SUBI 命令があれば、
即値を加算する ADDI 命令はなくてもよい」というのはそのとおりなのですが、
かなり思い切った設計のように感じます。

即値を加算する命令にオペコードを割り当てなくても、
そのためのニーモニック (例えば ADDI) を割り当てておいて、
アセンブラが ADDI 命令を自動的に SUBI 命令に置き換えるという方法もあるからです。
後ほど説明する Armv8-A アーキテクチャ ([[ch:arm]] 章) では、
こういった命令のエイリアスが多用されています。
#+end_note

ATtiny13A の場合には、
16 ビットの加算および減算を行う命令も用意されています (AVR アーキテクチャの初期のマイクロコントローラにはない命令です)。
ADIW 命令と SBIW 命令は、
8 ビットのレジスタを 2 つ並べて 16 ビットのレジスタと見なし、
その値に即値を加算および減算することができます。
例えば、
#+begin_src asm
	adiw	r29:r28, 12	; 16 ビットの R29:R28 に 12 を加算する
#+end_src
によって、
レジスタ R29:R28 を 16 ビットのレジスタと見なし、
その値に 12 を加算することができます。

ただし、
ADIW 命令と SBIW 命令も制約の大きい命令です。
出所オペランドの即値は 0〜63 の値しか取れません。
また、
宛先オペランドには R25:R24、
R27:R26、
R29:R28、
R31:R30 の 4 種類しか指定できません。

#+begin_note
R27:R26、
R29:R28、
R31:R30 は、
それぞれレジスタの X、
Y、
Z に対応します。
#+end_note

*** インクリメント命令とデクリメント命令

| ニーモニック | 説明                      |
|--------------+---------------------------|
| INC \r{i}    | \r{i} を 1 だけ増加させる |
| (Increment)  | \r{i} ← <+> 1            |
| DEC \r{i}    | \r{i} を 1 だけ減少させる |
| (Decrement)  | \r{i} ← <-> 1            |

INC 命令および DEC 命令は、
宛先オペランドを 1 つだけ取ります。
オペランドに指定したレジスタの値を、
それぞれ 1 だけ増加もしくは減少させます。
AVR アーキテクチャの INC 命令も DEC 命令も、
ごく普通のインクリメントおよびデクリメント命令です。

演算結果によって一部のフラグレジスタの値が変化します。
例えば、
命令の実行によってレジスタの値がゼロになれば、
ゼロフラグがセットされます。
IA-32 アーキテクチャの場合と同じように、
AVR アーキテクチャの INC 命令や DEC 命令はキャリーフラグを変化させません。

*** 比較命令と符号変更命令

| ニーモニック             | 説明                                                      |
|--------------------------+-----------------------------------------------------------|
| TST \r{i}                | \r{i} の値を 0 と比較し、フラグレジスタを設定する         |
| (Test for Zero or Minus) | \r{i} == 0?                                               |
| COM \r{i}                | \r{i} の 1 の補数を \r{i} に格納する                      |
| (One's Complement)       | \r{i} ← 0xff - \r{i}                                     |
| NEG \r{i}                | \r{i} の 2 の補数を \r{i} に格納する                      |
| (Two's Complement)       | \r{i} ← 0x00 - \r{i}                                     |
| CP \r{i}, \r{j}          | \r{i} と \r{j} を比較し、フラグレジスタを設定する         |
| (Compare)                | \r{i} == \r{j}?                                           |
| CPC \r{i}, \r{j}         | \r{i} と (\r{j} + \cf) を比較し、フラグレジスタを設定する |
| (Compare with Carry)     | \r{i} == \r{j} + \cf?                                     |
| CPI \r{i}, $c$           | \r{i} と $c$ を比較し、フラグレジスタを設定する           |
| (Compare with Immediate) | \r{i} == $c$?                                             |

AVR アーキテクチャの比較命令にはそれほど目立った特徴はありません。

比較命令は CP (Compare) 命令、
CPC (Compare with Cary) 命令、
CPI (Compare with Immediate) 命令の 3 つです。
2 つのレジスタの値の比較に用いる CP 命令および CPC 命令と、
レジスタと即値の比較に用いる CPI 命令があります。

キャリーフラグも含めて比較する命令 (CPC 命令) が用意されているところが少し珍しいかもしれません。
AVR アーキテクチャは 8 ビットなので、
2 つのレジスタを組み合わせて 16 ビットのデータを表現します。
レジスタのペアによって表現した 16 ビットのデータの比較に CPC 命令を用います。

例えば、
レジスタのペアに格納した 2 つの 16 ビットのデータ (R3:R2 と R1:R0) の比較は以下のように書けます。
#+begin_src asm
	cp	r2, r0		; 下位 8 ビットの比較
	cpc	r3, r1		; 上位 8 ビットの比較
	brne	notequal
#+end_src

他には、
レジスタの値をゼロと比較する TST (Test for Zero or Minus) 命令が用意されています。
レジスタの値をゼロと比較する処理は特に頻繁に行われるため、
そのための専用の命令が用意されています。

#+begin_note
ゼロとの比較は、
TST 命令を使わずに CPI 命令を使って、
#+begin_src asm
	cpi	r16, 0		; R16 の値に応じてフラグレジスタを設定
#+end_src
のように書くこともできます。
TST 命令も CPI 命令も、
どちらも命令語長が 2 ワードです。
しかも、
どちらの命令の実行時間も 2 クロックサイクルです。

「CPI 命令で書けるのだから、
別に TST 命令は必要ないのでは?」
という気がしますが、
TST 命令と CPI 命令では指定できるレジスタの種類が異なります。
CPI 命令のオペランドにはレジスタ R16〜R31 しか指定できません。
一方、
TST 命令のオペランドには R0〜R31 のすべての汎用レジスタが指定できます。
#+end_note

COM (One's Complement) 命令は、
オペランドに指定したレジスタの値の 1 の補数を求めます。
[[sec:number/binary]] 節で述べたように、
「正整数 $n$ の 1 の補数は $n$ の 2 進数のすべてのビットを反転したもの」でした。
したがって、
COM 命令は、
ビット単位の否定 (NOT) を求める命令でもあります。

*** 論理演算命令

| ニーモニック                 | 説明                                             |
|------------------------------+--------------------------------------------------|
| AND \r{i}, \r{j}             | \r{i} と \r{j} の論理積を \r{i} に格納する       |
| (Logical AND)                | \r{i} ← <&> \r{j}                               |
| ANDI \r{i}, $c$              | \r{i} と $c$ の論理積を \r{i} に格納する         |
| (Logical AND with Immediate) | \r{i} ← <&> $c$                                 |
| OR \r{i}, \r{j}              | \r{i} と \r{j} の論理積を \r{i} に格納する       |
| (Logical OR)                 | \r{i} ← <\vbar> \r{j}                           |
| ORI \r{i}, $c$               | \r{i} と \r{j} の論理積を \r{i} に格納する       |
| (Logical OR with Immediate)  | \r{i} ← <\vbar> $c$                             |
| EOR \r{i}, \r{j}             | \r{i} と \r{j} の排他的論理和を \r{i} に格納する |
| (Exclusive OR)               | \r{i} ← <^> \r{j}                               |

論理演算命令にも目立った特徴はありません。
前述のように、
ビット単位の否定には 1 の補数を求める COM 命令が使用できます。

*** ビットのシフト命令

| ニーモニック                 | 説明                                                            |
|------------------------------+-----------------------------------------------------------------|
| LSL \r{i}                    | \r{i} の値を左に 1 ビットシフトする                             |
| (Logical Shift Left)         | \r{i} ← < ~<<~ > 1
| LSR \r{i}                    | \r{i} の値を右に 1 ビットシフトする                             |
| (Logical Shift Right)        | \r{i} ← < ~>>~ > 1
| ROL \r{i}                    | \r{i} の値を左に 1 ビットシフトする (最下位ビットに \cf が入る) |
| (Rotate Left Through Carry)  | \r{i} ← (\r{i} << 1) \vbar \cf                                 |
| ROR \r{i}                    | \r{i} の値を右に 1 ビットシフトする (最上位ビットに \cf が入る) |
| (Rotate Right Through Carry) | \r{i} ← (\r{i} >> 1) \vbar (\cf << 7)                          |
| ASR \r{i}                    | \r{i} の値を右に 1 ビット算術シフトする                         |
| (Arithmetic Shift Right)     | \r{i} の 6〜0 ビットを右に 1 ビットシフトする                   |

ビットのシフト命令も一般的な命令がそろっています。

右シフト命令には、
符号なし整数と符号付き整数のために、
それぞれ別の命令 (LSR (Logical Shift Right) 命令と ASR (Arithmetic Shift Right) 命令) が用意されています。

ROL (Rotate Left Through Carry) 命令と ROR (Rotate Right Through Carry) 命令は、
ステータスレジスタのキャリーフラグを介したローテート命令です。
汎用レジスタの 8 ビットと、
ステータスレジスタのフラグレジスタの 1 ビットの、
合計 9 ビットでの左ローテートおよび右ローテートを行います。

前述の CPC 命令と同じように、
8 ビットのレジスタを 2 つ使って 16 ビットのデータを表現しているときに、
16 ビットのデータのビットシフトに利用できます。
例えば、
レジスタペア R19:R18 に 16 ビットのデータを格納しているときに、
この 16 ビットのデータを左に 1 ビットシフトするには、
以下のように書きます。
#+begin_src asm
	lsl	r18	; 下位バイトを左にシフト (最上位ビットが CF に入る)
	rol	r19	; 上位バイトを左にシフト (最下位ビットには CF が入る)
#+end_src

IA-32 アーキテクチャと比較したときの、
AVR アーキテクチャの算術演算および論理演算命令の特徴は以下のようになります。

- 出所オペランド、宛先オペランドともにメモリロケーションを指定できない
  (レジスタまたは即値しか指定できない)
- レジスタから即値を減算する命令 (SUBI 命令) はあるが、レジスタに即値
  を加算する命令はない
- レジスタのペアに対して即値を加算や減算を行う命令 (ADIW 命令および
  SBIW 命令)がある (ただし、マイクロコントローラの種類によっては存在し
  ない)
- 乗算や除算のための命令がない (ただし、マイクロコントローラの種類によっ
  ては存在するものもある)

** AVR 命令セット (実行制御)
<<sec:avr/ctrl>>

*** 無条件転送命令

| ニーモニック               | 説明                                                 |
|----------------------------+------------------------------------------------------|
| RJMP $c$                   | \pc + $c$ + 1 番地にジャンプする                     |
| (Relative Jump)            | \pc ← <+> ($c$ + 1)                                 |
| IJMP                       | レジスタ Z の差す番地にジャンプ                      |
| (Indirect Jump to (Z))     | \pc ← Z                                             |
| RCALL $c$                  | \pc + $c$ + 1 番地をコールする                       |
| (Relative Call Subroutine) | [\sp] ← \pc + 1, \sp ← <-> 2, \pc ← <+> ($c$ + 1) |
| ICALL                      | レジスタ Z の差す番地をコール                        |
| (Indirect Call to (Z))     | [\sp] ← \pc + 1, \sp ← <-> 2, \pc ← Z             |
| RET                        | サブルーチンからリターンする                         |
| (Subroutine Return)        | \sp ← <+> 2, \pc ← [\sp]                           |
| RETI                       | 割り込みからリターンする                             |
| (Interrupt Return)         | \sp ← <+> 2, \pc ← [\sp]                           |

無条件転送命令には、
プログラムカウンタを変化させるジャンプ命令や、
サブルーチンコールを行うコール命令、
サブルーチンから戻るリターン命令が含まれます。

AVR アーキテクチャにおける無条件転送命令の特徴は、
ジャンプ命令やコール命令の多くが相対ジャンプであるという点です。
コンピュータによっては、
#+begin_src asm
	jmp	$0x80000000	; AVR ではこのように書けない
#+end_src
や
#+begin_src asm
	call	$0x80000000	; AVR ではこのように書けない
#+end_src
のように、
ジャンプ先のアドレスやサブルーチンのアドレスのオペランドに絶対アドレスを指定できるものもあります。

一方、
AVR アーキテクチャでは、
ジャンプ命令もコール命令も、
現在のプログラムカウンタの値を基準とした相対ジャンプが中心です。
例えば、
RJMP (Relative Jump) 命令は、
現在のプログラムカウンタの値を基準として、
オペランドに指定されたオフセットだけずれた前後のアドレスにジャンプします。

RJMP 命令も RCALL (Relative Call Subroutine) 命令も、
指定できるアドレスのオフセットの範囲は -2 048〜2 047 です。
このため、
現在のプログラムカウンタの、
前後 2K ワードのアドレスにジャンプ (またはアドレスをコール) できます。
逆に言えば、
現在のプログラムカウンタを基準として、
その前後 2K ワードの範囲内にしかジャンプやコールはできません。

ただし、
AVR アーキテクチャのマイクロコントローラのプログラム用メモリは大きくないため、
相対ジャンプ命令や相対コール命令だけでも十分です。
例えば、
ATtiny13A のプログラム用メモリの大きさは 512 ワード (1 K バイト) しかなく、
アドレスのオフセットの範囲に、
すべてのプログラム用メモリのアドレスが含まれています。

#+begin_note
なお、
ATmega シリーズのような、
大容量のプログラム用メモリを搭載したマイクロコントローラでは、
22 ビットのアドレス空間に絶対ジャンプできる命令が追加されています。
#+end_note

RJMP 命令や RCALL 命令がジャンプ (またはコール) するアドレスは、
「現在のプログラムカウンタの値 + $c$ + 1」となります。
RJMP 命令や RCALL 命令の実行時点では、
プログラムカウンタの値は「これらの命令が格納されていたアドレス + 1」を差しています。
従って、
アドレスのオフセット $c$ がゼロのとき、
RJMP 命令や RCALL 命令の直後の命令が格納されているアドレス + 1 へジャンプ (またはコール) します。
つまり、
#+begin_src asm
	rjmp	0	; PC + 1 (= set_r1) へジャンプ
set_r0:	ldi	r0, 12	; r0 ← 12
set_r1:	ldi	r1, 34	; r1 ← 34
#+end_src
というプログラムでは、
LDI 命令の命令語長が 1 ワードであるため、
RJMP 命令によって ~set_r1~ 番地にジャンプします。

同様に、
アドレスのオフセットが -1 である
#+begin_src asm
	rjmp	-1	; PC -1 + 1 (= PC = set_r0) へジャンプ
set_r0:	ldi	r0, 12	; r0 ← 12
set_r1:	ldi	r1, 34	; r1 ← 34
#+end_src
というプログラムでは、
RJMP 命令によって ~set_r0~ 番地にジャンプします。
つまり、
RJMP 命令がない場合と同じように動作します。

最後に、
アドレスのオフセットが -2 である、
#+begin_src asm
	rjmp	-2	; PC -2 + 1 (= PC - 1) へジャンプ
set_r0:	ldi	r0, 12	; r0 ← 12
set_r1:	ldi	r1, 34	; r1 ← 34
#+end_src
というプログラムでは、
RJMP 命令の命令語長が 1 ワードであるため、
RJMP 命令によって RJMP 命令自身にジャンプします (無限ループになります)。

*** 条件付き転送命令

以下の表では、
これまでの命令表では使用したなかった新しい表記がいくつか登場しています。

ステータスレジスタの値を SREG と表記しています。
さらに、
ステータスレジスタの I ビット、
T ビット、
H フラグ、
S フラグ、
V フラグ、
N フラグを、
それぞれ単一の文字 (I、
T、
H、
S、
V、
N) で表記しています。
Z フラグ (ゼロフラグ) と C フラグ (キャリーフラグ) は、
これまで通り \zf および \cf と表記しています。

また、
$x$ の $b$ ビット目の値を $x.b$ と表記しています。
例えば、
\r{i}.0 は、
レジスタ \r{i} の最下位ビットの値 (0 または 1) を表します。
さらに、
$p$ 番地の I/O レジスタの値を [$p$]_{\rm I/O} と表記しています。
例えば、
ステータスレジスタの値は [0x3f]_{\rm I/O} に対応します。
なお、
表中の $\Delta$ は 2 または 3 の値を取ります (次の命令の命令語の大きさによって変化します)。

#+attr_latex: :environment longtable :align lp{25zw} :float t
| ニーモニック                          | 説明                                                            |
|---------------------------------------+-----------------------------------------------------------------|
| CPSE \r{i}, \r{j}                     | \r{i} と \r{j} を比較し、等しければ次の命令をスキップ           |
| (Compare, Skip if Equal)              | \pc ← <+> \Delta if \r{i} == \r{j}                             |
| SBRC \r{i}, $b$                       | \r{i} の $b$ ビット目が 0 であれば次の命令をスキップ            |
| (Skip if Bit in Register Cleared)     | \pc ← <+> \Delta if \r{i}.$b$ == 0                             |
| SBRS \r{i}, $b$                       | \r{i} の $b$ ビット目が 1 であれば次の命令をスキップ            |
| (Skip if Bit in Register Set)         | \pc ← <+> \Delta if \r{i}.$b$ == 1                             |
| SBIC $p$, $b$                         | I/O レジスタ $p$ の $b$ ビット目が 0 であれば次の命令をスキップ |
| (Skip if Bit in I/O Register Cleared) | \pc ← <+> \Delta if [$p$]_{\rm I/O}.$b$ == 0                   |
| SBIS $p$, $b$                         | I/O レジスタ $p$ の $b$ ビット目が 1 であれば次の命令をスキップ |
| (Skip if Bit in I/O Register is Set)  | \pc ← <+> \Delta if [$p$]_{\rm I/O}.$b$ == 1                   |
| BRBS $b$, $c$                         | フラグレジスタの $b$ ビット目が 1 であれば $c$ だけ相対ジャンプ |
| (Branch if Status Flag Set)           | \pc ← <+> ($c$ + 1) if SREG.$b$ == 1                           |
| BRBC $b$, $c$                         | フラグレジスタの $b$ ビット目が 0 であれば $c$ だけ相対ジャンプ |
| (Branch if Status Flag Cleared)       | \pc ← <+> ($c$ + 1) if SREG.$b$ == 0                           |
| BREQ $c$                              | ゼロフラグが 1 であれば $c$ だけ相対ジャンプ                    |
| (Branch if Equal)                     | \pc ← <+> ($c$ + 1) if \zf == 1                                |
| BRNE $c$                              | ゼロフラグが 0 であれば $c$ だけ相対ジャンプ                    |
| (Branch if Not Equal)                 | \pc ← <+> ($c$ + 1) if \zf == 0                                |
| BRCS $c$                              | キャリーフラグが 1 であれば $c$ だけ相対ジャンプ                |
| (Branch if Carry Set)                 | \pc ← <+> ($c$ + 1) if \cf == 1                                |
| BRCC $c$                              | キャリーフラグが 0 であれば $c$ だけ相対ジャンプ                |
| (Branch if Carry Cleared)             | \pc ← <+> ($c$ + 1) if \cf == 0                                |
| BRSH $c$                              | キャリーフラグが 0 であれば $c$ だけ相対ジャンプ                |
| (Branch if Same or Higher)            | \pc ← <+> ($c$ + 1) if \cf == 0                                |
| BRLO $c$                              | キャリーフラグが 1 であれば $c$ だけ相対ジャンプ                |
| (Branch if Lower)                     | \pc ← <+> ($c$ + 1) if \cf == 1                                |
| BRMI $c$                              | N フラグが 1 であれば $c$ だけ相対ジャンプ                      |
| (Branch if Minus)                     | \pc ← <+> ($c$ + 1) if N == 1                                  |
| BRPL $c$                              | N フラグが 0 であれば $c$ だけ相対ジャンプ                      |
| (Branch if Plus)                      | \pc ← <+> ($c$ + 1) if N == 1                                  |
| BRGE $c$                              | (符号付き整数が) 等しいかより大きければ $c$ だけ相対ジャンプ    |
| (Branch if Greater or Equal, Signed)  | \pc ← <+> ($c$ + 1) if S == 0                                  |
| BRLT $c$                              | (符号付き整数が) より小さければ $c$ だけ相対ジャンプ            |
| (Branch if Less than Zero, Signed)    | \pc ← <+> ($c$ + 1) if S == 1                                  |
| BRHS $c$                              | H フラグが 1 であれば $c$ だけ相対ジャンプ                      |
| (Branch if Half Carry Flag Set)       | \pc ← <+> ($c$ + 1) if H == 1                                  |
| BRHC $c$                              | H フラグが 0 であれば $c$ だけ相対ジャンプ                      |
| (Branch if Half Carry Flag Cleared)   | \pc ← <+> ($c$ + 1) if H == 0                                  |
| BRTS $c$                              | T フラグが 1 であれば $c$ だけ相対ジャンプ                      |
| (Branch if T Flag Set)                | \pc ← <+> ($c$ + 1) if T == 1                                  |
| BRTC $c$                              | T フラグが 0 であれば $c$ だけ相対ジャンプ                      |
| (Branch if T Flag Cleared)            | \pc ← <+> ($c$ + 1) if T == 0                                  |
| BRVS $c$                              | V フラグが 1 であれば $c$ だけ相対ジャンプ                      |
| (Branch if Overflow Flag Set)         | \pc ← <+> ($c$ + 1) if V == 1                                  |
| BRVC $c$                              | V フラグが 0 であれば $c$ だけ相対ジャンプ                      |
| (Branch if Overflow Flag is Cleared)  | \pc ← <+> ($c$ + 1) if V == 0                                  |
| BRIE $c$                              | I フラグが 1 であれば $c$ だけ相対ジャンプ                      |
| (Branch if Interrupt Enabled)         | \pc ← <+> ($c$ + 1) if I == 1                                  |
| BRID $c$                              | I フラグが 0 であれば $c$ だけ相対ジャンプ                      |
| (Branch if Interrupt Disabled)        | \pc ← <+> ($c$ + 1) if I == 1                                  |

条件付き転送命令は、
- CPSE 命令
- 「SBなんとか」というニーモニックの命令
- 「BRなんとか」というニーモニックの命令
の 3 種類に大きく分類できます。

CPSE (Compare, Skip if Equa) 命令は、
オペランドに指定された 2 つのレジスタの値を比較して、
それらの値が等しければ「CPSE 命令の直後の命令をスキップする」という少し変わった命令です。
CPSE 命令の利用例を示します。
#+begin_src asm
	ldi	r16, 0		; r16 ← 0
	cpse	r1, r0		; r1 == r0 なら次の命令をスキップ
	ldi	r16, 12		; r16 ← 12
#+end_src
\inst{cpse r1, r0} では、
2 つのレジスタ R1 と R0 の値を比較し、
値が等しければ次の命令 (\inst{ldi r16, 12}) をスキップします。
上の例では、
レジスタ R1 と R0 の値が等しければ、
\inst{ldi r16, 12} が実行されないため、
レジスタ R16 の値は 0 のままです。
レジスタ R1 と R0 の値が異なれば、
レジスタ 16 の値は 12 に変化します。

2 番目のカテゴリの「SB なんとか」というニーモニックの命令も CPSE 命令の仲間です。
ただし、
2 つのレジスタの値を比較するのではなく、
汎用レジスタや I/O レジスタの指定したビットの値が 0 か 1 かなど、
命令ごとに定められた条件に応じて、
次の命令の実行をスキップするかどうかを決定します。

3 番目のカテゴリの「BR なんとか」というニーモニックの命令も CPSE 命令や「SB なんとか」命令と似ていますが、
直後の命令をスキップするのではなく、
条件付きのジャンプを行います。
「分岐する」を意味する英単語 branch の先頭の 2 文字を取って、
これらの条件分岐命令のニーモニックは BR から始まっています。
IA-32 アーキテクチャの条件付き転送命令 ([[sec:x86ctrl/transfer]] 節) と同じように、
分岐する条件の違いによって多数の命令が用意されています。

IA-32 アーキテクチャと比較したときの、
AVR アーキテクチャの実行制御命令の特徴は以下のようになります。

- ジャンプ命令およびコール命令は、相対ジャンプが中心である (ただし、マ
  イクロコントローラによっては絶対ジャンプのための命令が追加されている)
- 条件分岐命令だけでなく、条件に従って直後の命令の実行をスキップする命
  令が存在する

** シミュレータによるトレース
<<sec:avr/trace>>

*** レジスタどうしの加算

AVR アーキテクチャの主要な命令を一通り説明したので、
実際のアセンブリ言語プログラムをいくつか見てみましょう。

まずは、
レジスタを利用した単純な加算のプログラムです (図 [[fig:avr/add-with-label.s]])。
[[sec:avr/overview]] 節で説明したプログラム (図 [[fig:avr/add.s]]) とほぼ同じプログラムです。
ただし、
GAS の疑似命令を使用して、
アセンブリ言語プログラムが読みやすくなるようにラベルを 2 つ定義しています。

#+caption: avr/add-with-label.s
#+label: fig:avr/add-with-label.s
#+include: "code/avr/add-with-label.s" src asm

ラベル ~i~ の値を 16 に、
ラベル ~tmp~ の値を 17 に定義しています。
このため、
#+begin_src asm
	ldi	i, 12
#+end_src
と記述した場合、
ラベル ~i~ が 16 に置き換えられます。
したがって、
これは
#+begin_src asm
	ldi	16, 12
#+end_src
と書いたことと同じ意味になります。
LDI 命令の第 1 オペランド (宛先オペランド) は汎用レジスタであり、
これはさらに
#+begin_src asm
	ldi	r16, 12
#+end_src
と書いたことと同じ意味になります。

上記のプログラムでは、
レジスタ R16 に計算結果を保存し、
レジスタ R17 を一時的な値の保存に使用しています。
汎用レジスタの用途を表すラベルを定義することで、
アセンブリ言語プログラムがずいぶん読みやすくなっています。

[[sec:avr/overview]] 節と同じように、
AVR シミュレータ上で動作させてみましょう。
復習も兼ねて、
アセンブリ言語プログラムのアセンブルおよびリンクから始めます。

まず、
アセンブリ言語プログラムをアセンブルして、
機械語のプログラムに変換します。
#+begin_src sh
$ avr-as -mmcu=attiny13a -o add-with-label.o add-with-label.s
#+end_src
リンカを用いて絶対アドレスの機械語プログラムに変換します。
#+begin_src sh
$ avr-ld -m avr25 -Tdata 0x800060 -o add-with-label add-with-label.o
#+end_src
~avr-as~ コマンドや ~avr-ld~ コマンドのオプションの意味については [[sec:avr/overview]] 節を参照してください。

[[sec:avr/overview]] 節と同じように、
現在の作業ディレクトリに以下の ~.gdbinit~ ファイル (図 [[fig:avr/.gdbinit]]) を作成しておきます。

AVR アーキテクチャ向けの GDB (~avr-gdb~ コマンド) を起動して、
AVR シミュレータ上で先ほどのプログラム ~add-with-label~ を実行します。
#+begin_src gdb
$ avr-gdb -q add-with-label
Reading symbols from add-with-label...
(No debugging symbols found in add-with-label)
Connected to the simulator.
Loading section .data, size 0x2 lma 0xc
Loading section .text, size 0xc lma 0x0
Start address 0x0
Transfer rate: 112 bits in <1 sec.
Breakpoint 1 at 0x0
(gdb) r
Starting program: /home/ohsaki/code/avr/add-with-label 

Breakpoint 1, 0x00000000 in _start ()
1: /x $r16 = 0x0
2: /x $r17 = 0x0
3: x/4i $pc
=> 0x0 <_start>:        ldi     r16, 0x0C       ; 12
   0x2 <_start+2>:      ldi     r17, 0x22       ; 34
   0x4 <_start+4>:      add     r16, r17
   0x6 <_start+6>:      sts     0x0060, r16     ;  0x800060
4: x/8xb 0x800060
0x800060:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
(gdb) 
#+end_src

~.gdbinit~ ファイルに必要な設定を書いておいたので、
機械語プログラムをシミュレータ上で実行し、
0x00 番地 (ラベル ~_start~) に設定したブレークポイントで一時停止しています。

~.gdbinit~ ファイル中に記述した display コマンドにより、
レジスタ R16 と R17 の値を 16 進数で表示しています。
また、
プログラムカウンタ (GDB 上ではアーキテクチャによらず ~$pc~ で参照できます) から 4 命令を逆アセンブルした結果も表示しています。

stepi コマンド (省略形は si) を実行し、
1 命令ずつステップ実行します。
最初の命令は \inst{ldi r16, 0x0C} です。
出所オペランドに指定した即値 0x0c をレジスタ R16 に読み込みます。
#+begin_src gdb
(gdb) si
0x00000002 in _start ()
1: /x $r16 = 0xc ← レジスタ R16 の値が 0x0c に変化した
2: /x $r17 = 0x0
3: x/4i $pc
=> 0x2 <_start+2>:      ldi     r17, 0x22       ; 34
   0x4 <_start+4>:      add     r16, r17
   0x6 <_start+6>:      sts     0x0060, r16     ;  0x800060
   0xa <loop>:  rjmp    .-2             ;  0xa <loop>
4: x/8xb 0x800060
0x800060:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
(gdb) 
#+end_src

次の命令は \inst{ldi r17, 0x22} です。
先ほどと同じく LDI 命令です。
即値 0x22 がレジスタ R17 に読み込まれるはずです。
1 命令だけステップ実行します。
#+begin_src gdb
(gdb) ← リターンキーを押す (stepi コマンドの繰り返し)
0x00000004 in _start ()
1: /x $r16 = 0xc
2: /x $r17 = 0x22 ← レジスタ R17 の値が 0x22 に変化した
3: x/4i $pc
=> 0x4 <_start+4>:      add     r16, r17
   0x6 <_start+6>:      sts     0x0060, r16     ;  0x800060
   0xa <loop>:  rjmp    .-2             ;  0xa <loop>
   0xc: nop
4: x/8xb 0x800060
0x800060:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00

(gdb) 
#+end_src

次の命令は \inst{add r16, r17} です。
出所オペランドが ~r17~ で、
宛先オペランドが ~r16~ であることに注意しましょう。
レジスタ R17 の値がレジスタ R16 に加算され、
さらに 1 命令ステップ実行します。
#+begin_src gdb
(gdb) ← リターンキーを押す (stepi コマンドの繰り返し)
0x00000006 in _start ()
1: /x $r16 = 0x2e ← レジスタ R16 の値が +0x22 だけ増えた
2: /x $r17 = 0x22
3: x/4i $pc
=> 0x6 <_start+6>:      sts     0x0060, r16     ;  0x800060
   0xa <loop>:  rjmp    .-2             ;  0xa <loop>
   0xc: nop
   0xe: nop
4: x/8xb 0x800060
0x800060:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
(gdb) 
#+end_src

次の命令は \inst{sts 0x0060, r16} です。

AVR アーキテクチャでは、
プログラム用メモリとデータ用メモリが独立しており、
STS 命令は、
データ用メモリの指定したアドレスにレジスタの値を書き込む命令でした。
また、
データ用メモリの先頭 0x00〜01f が汎用レジスタファイル、
それに続く 0x20〜0x5f が I/O レジスタとなり、
SRAM は 0x60〜に配置されていました。

\inst{sts 0x0060, r16} は、
レジスタ R16 の値を、
データ用メモリの 0x60 番地に書き込みます。
命令の右にあるコメントや、
メモリダンプのアドレスは 0x60 ではなく 0x800060 となっています。
これは、
GDB に組み込まれている AVR シミュレータが、
データ用メモリがアドレス 0x8000000〜に存在すると見なしているためです。

さらに 1 命令ステップ実行します。
#+begin_src gdb
(gdb) ← リターンキーを押す (stepi コマンドの繰り返し)
0x0000000a in loop ()
1: /x $r16 = 0x2e
2: /x $r17 = 0x22
3: x/4i $pc
=> 0xa <loop>:  rjmp    .-2             ;  0xa <loop>
   0xc: nop
   0xe: nop
   0x10:        nop
4: x/8xb 0x800060
0x800060:       0x2e    0x00    0x00    0x00    0x00    0x00    0x00    0x00
(gdb)           ↑ 0x60 番地にレジスタ R16 の値が書き込まれた
#+end_src
0x60 番地 (AVR シミュレータ上の番地は 0x800060) にレジスタ R16 の値が書き込まれたことがわかります。

最後の命令は \inst{rjmp .-2} です。
RJMP 命令は相対ジャンプの命令です。
ここでは、
アドレスのオフセットが -2 なので、
「プログラムカウンタの値 + (-2) + 1」、
すなわち「プログラムカウンタの値 - 1」にジャンプします。
前述のとおり、
これは RJMP 命令が配置されているアドレスへのジャンプです。
これ以降は、
RJMP 命令の実行が繰り返されます。

さて、
ここまで AVR アーキテクチャ向けのアセンブリ言語プログラムを眺めてきました。

もちろん、
AVR アーキテクチャ向けの GCC が利用できるので、
C 言語で書かれたプログラムをコンパイルし、
アセンブリ言語のプログラムに変換することができます。

一般的なプログラミングの流れ (C 言語→アセンブリ言語→機械語) とは逆に、
先ほどのアセンブリ言語プログラムを (図 [[fig:avr/add-with-label.s]]) を C 言語で書いてみました (図 [[fig:avr/c/add.c]])。

#+caption: avr/c/add.c
#+label: fig:avr/c/add.c
#+include: "code/avr/c/add.c" src C

IA-32 アーキテクチャ上でのプログラム開発 ([[sec:asm/lang-to-asm]] 節) では、
オペレーティングシステム上で動作させるユーザプログラムを C 言語で作成しました。
この場合、
オペレーティングシステムやリンカが、
必要な処理をあれこれ行ってくれるため、
プログラマはあまり細かな点を意識する必要はありません。
例えば、
C 言語で書いたプログラムをコンパイルして実行すると、
関数 ~main~ が最初に呼び出されます。
これは、
リンカが、
関数 ~main~ を呼び出すようなスタートアップルーチンをリンクすることによって実現されています。

#+begin_note
ELF 形式の実行ファイルは、
大域シンボル ~_start~ から実行を開始します。
GCC の裏側で呼び出されているリンカ ~ld~ が、
「~_start~ から実行を開始し、
さまざまな初期化を行ったあと、
関数 ~main~ を呼び出す」というプログラムを自動的にリンクします。
#+end_note

一方、
AVR アーキテクチャ向けのプログラム開発は、
オペレーティングシステム上で動作するプログラムとは異なり、
すべてをプログラマが理解したうえでプログラムを作成する必要があります。

上の例 (図 [[fig:avr/c/add.c]]) では、
関数 ~main~ ではなく、
関数 ~_start~ を定義しています。
C 言語で普通にプログラムを作成すると、
関数の終了時に (機械語の) RET 命令によってサブルーチンから呼び出し元に戻ります。
ただし、
今の場合、
関数 ~_start~ はサブルーチン呼び出し (機械語の CALL 命令) によって呼び出されたわけではないため、
RET 命令で戻ることはできません (そもそもスタックポインタが初期化されていません)。
そこで上のプログラムでは、
インラインアセンブラを使って、
関数 ~_start~ の終了直前に、
自分自身にジャンプする RJMP 命令を埋め込んでいます。

C 言語で書いたプログラムも、
アセンブリ言語プログラム (図 [[fig:avr/add-with-label.s]]) の場合と同様に、
#+begin_src sh
$ avr-gcc -fno-pic -fomit-frame-pointer -mmcu=attiny13a -O -c -o add.o add.c
$ avr-ld -m avr25 -Tdata 0x800060 -o add add.o
$ avr-gdb add
#+end_src
のようにすることで、
GDB のシミュレータ上で実行できます。

ここでは、
GCC によって生成されたアセンブリ言語プログラムを眺めてみます。
#+begin_src sh
$ avr-gcc -fno-pic -fomit-frame-pointer -mmcu=attiny13a -O2 -S add.c
#+end_src
によって ~add.c~ をコンパイルし、
アセンブリ言語プログラム ~add.s~ (図 [[fig:avr/c/add.s]]) を得ます。

#+caption: avr/c/add.s
#+label: fig:avr/c/add.s
#+include: "code/avr/c/add.s" src asm

#+begin_note
AVR アーキテクチャ向けの GCC が生成したアセンブリ言語プログラムを読む場合には、

1. GCC がきれいなアセンブリ言語にコンパイルしてくれるように、C 言語の
   プログラムを作成しておく
2. GCC がきれいなアセンブリ言語にコンパイルしてくれるように、GCC のコ
   ンパイル時オプションを適切に設定する

というのがポイントです。
素朴に C 言語でプログラムを書いて、
そのプログラムを GCC でアセンブリ言語に変換すると、
かなり冗長で読みづらいアセンブリ言語プログラムになってしまいます。
#+end_note

一部、
見慣れない表記もありますが、
本書をここまで読んだ方であれば、
おおよそ読めるのではないでしょうか。

アセンブリ言語で書いたプログラム (図 [[fig:avr/add-with-label.s]]) と、
GCC が生成したアセンブリ言語プログラム (図 [[fig:avr/c/add.s]]) を比較すると、
後者のほうがかなり複雑です。

2 つのプログラムの最大の違いは、
アセンブリ言語で書いたプログラム (図 [[fig:avr/add-with-label.s]]) のデータの大きさは 8 ビットですが、
GCC が生成したアセンブリ言語プログラム (図 [[fig:avr/c/add.s]]) のデータの大きさが 16 ビットであるという点です。
AVR アーキテクチャ向けの GCC では、
~int~ 型の大きさは 16 ビットです。
8 ビット CPU である AVR 上で、
16 ビットのデータを扱っているため、
GCC が生成したアセンブリ言語プログラムは複雑になっています。

プログラム ~add.c~ (図 [[fig:avr/c/add.c]]) の ~int~ (16 ビット) を手作業で ~char~ (8 ビット) に書き換えてもよいのですが、
AVR アーキテクチャ向けの GCC では ~-mint8~ オプションによって、
~int~ の大きさを強制的に 8 ビットに変更することができます。

GCC のコンパイル時オプションに ~-mint8~ を追加して、
再度コンパイルします。
#+begin_src sh
$ avr-gcc  -fno-pic -fomit-frame-pointer -mmcu=attiny13a -O2 -mint8 -S add.c
#+end_src

これにより、
以下のようなアセンブリ言語プログラムが得られます (図 [[fig:avr/c/add-mint8.s]])。

#+caption: avr/c/add-mint8.s
#+label: fig:avr/c/add-mint8.s
#+include: "code/avr/c/add-mint8.s" src asm

これでもまだアセンブリ言語で書いたプログラム (図 [[fig:avr/add-with-label.s]]) と比べると冗長で読みづらいですが、
かなり単純なプログラムになりました。

それでは、
このアセンブリ言語プログラムを詳しく見ていきましょう。

#+begin_src asm
        .file   "add.c"
__SP_L__ = 0x3d
__SREG__ = 0x3f
__tmp_reg__ = 0
__zero_reg__ = 1
#+end_src
GAS の疑似命令を使用して、
いくつかのラベルを定義しています。
~__SP_L__~ はスタックポインタ (SPL) の I/O レジスタです。
~__SREG__~ はステータスレジスタ (SREG) の I/O レジスタです。

また、
~__tmp_reg__~ は一時的な演算に使用するレジスタを意味します。
~__tmp_reg__~ のラベルの値が 0、
つまり一時的な演算にレジスタ R0 を使用することを意味しています。

同様に、
~__zero_reg__~ はゼロレジスタを意味します。
~__zero_reg__~ のラベルの値が 1、
つまりレジスタ R1 をゼロレジスタとして使用することを意味します。
GCC が生成するアセンブリ言語プログラムでは、
レジスタ R1 の値が常にゼロであることを前提としたコードになっているようです。

#+begin_src asm
        .text
.global _start
        .type   _start, @function
_start:
/* prologue: function */
/* frame size = 0 */
/* stack size = 0 */
.L__stack_usage = 0
#+end_src
このあたりは特に目新しい箇所はありません。
この直後に、
12 + 34 を計算するプログラムの本体が続きます。

次の 2 行が、
C 言語で書かれたプログラムの「~i = 12~」に対応します。
#+begin_src asm
        ldi r24,lo8(12)
        sts i,r24
#+end_src
LDI 命令によってレジスタ R24 に即値 12 を読み込み、
レジスタ R24 の値をデータ用メモリの ~i~ 番地に書き込んでいます。

lo8() は AVR アーキテクチャ向け GAS の *修飾子 (modifier)* です。
lo8() は、
括弧の中の数値の下位 8 ビットを取り出すことを意味します。
今の場合、
定数 12 は 8 ビットに収まっているので、
lo8() を使わずに
#+begin_src asm
        ldi r24,12
#+end_src
と書いても同じ意味です。

次の 3 行が、
C 言語で書かれたプログラムの「~i = i + 34~」に対応します。
#+begin_src asm
        lds r24,i
        subi r24,lo8(-(34))
        sts i,r24
#+end_src
IA-32 アーキテクチャや COMET II では 1 命令で書けるような処理ですが、
AVR アーキテクチャは RISC なので 3 命令が必要です。

まず、
LDS 命令によって、
データ用メモリの ~i~ 番地に格納されている値をレジスタ R24 に読み込んでいます。

次の \inst{subi r24,lo8(-(34))} は一見すると何のことかわからないかもしれません。
これは、
「レジスタ R24 に 34 を加算」しています。
前述のとおり、
AVR アーキテクチャには、
即値を減算する SUBI 命令はありますが、
即値を加算する命令が存在しません。
そのため、
「34 を加算する」場合は、
「-34 を減算する」という命令で代用します。

最後の \inst{sts i,r24} は、
レジスタ R24 の値を、
データ用メモリの ~i~ 番地に格納しています。

この次は、
インラインアセンブラで記述した、
RJMP 命令自身への相対ジャンプです。
#+begin_src asm
/* #APP */
 ;  8 "add.c" 1
        loop: rjmp loop
 ;  0 "" 2
/* #NOAPP */
        ret
        .size   _start, .-_start
#+end_src

RJMP 命令の直後に、
GCC によって生成された RET 命令がありますが、
この RET 命令が呼び出されることはありません。

最後は、
.bss セクション中に、
変数 ~i~ のための領域を 1 バイト確保しています。
#+begin_src asm
        .comm   i,1,1
        .ident  "GCC: (GNU) 5.4.0"
.global __do_clear_bss
#+end_src

オペレーティングシステム上で動作するユーザプログラムでは、
.bss セクションの初期化はオペレーティングシステムが行ってくれます。
しかし、
AVR アーキテクチャの機械語プログラムでは、
.data セクションの配置や、
.bss セクションの配置や初期化は、
すべてプログラマ側で行う必要があります。

#+begin_note
こうやって、
低レベルの機械語プログラミングを行うことは、
コンピュータやオペレーティングシステムの仕組みを理解するうえで非常に役立ちます。

普段から、
アセンブリ言語でプログラムを作成したり、
C コンパイラが生成するアセンブリ言語のプログラムを読んだりしていれば、
コンピュータやオペレーティングシステムが何を行っているのかを詳細に理解できます。

しかし、
高級言語だけを使ってプログラムを作成していて、
そのプログラムが、
アセンブリ言語や機械語にどのように変換されて実行されているのを知らなければ、
何か予想外のことがあったときに対処するのは困難でしょう。
#+end_note

#+begin_note
GDB 上の AVR シミュレータでは、
シミュレータの起動時に SRAM の状態はゼロクリアされています。
つまり、
データ用メモリの SRAM の値はすべてゼロで初期化されています。
しかし、
実際のマイクロコントローラでは、
電源投入時の SRAM の状態は不定です。

したがって、
初期状態において SRAM の値がゼロであることを前提としたプログラムを書いてはいけません。
自身でプログラムを作成する場合は、
プログラムの冒頭で (必要に応じて) SRAM の値を初期化する必要があります。

他にも、
マイクロコントローラの種類にもよりますが、
スタックポインタを自分で初期化する必要があります。

ATtiny13A では、
パワーオン・リセット時に、
スタックポインタ (SPL I/O レジスタ) の値は初期化されません。
スタックを使用する場合は、
プログラムの冒頭でスタックポインタを初期化する必要があります。
#+end_note

*** 単一ループによる順列の和の計算

さらにいくつかプログラムを見てみましょう。
次は、
繰り返しを使ったプログラムです。
1 から 10 までの和を計算します (図 [[fig:avr/sum-10.s]])。

#+caption: avr/sum-10.s
#+label: fig:avr/sum-10.s
#+include: "code/avr/sum-10.s" src asm

AVR アーキテクチャは 8 ビットなので、
計算結果が 8 ビットに収まるように、
1 から 10 までの和 1 + 2 + \dots + 10 (= 55) を計算するために、
レジスタ R16 に合計を格納し、
レジスタ R17 をループカウンタとして使用しています。
アセンブリ言語プログラムの可読性を高めるため、
2 つのラベル (~sum~ と ~i~) を定義しています。
レジスタ名も、
命令のニーモニックも、
オペランドも異なりますが、
IA-32 アーキテクチャや COMET II のアセンブリ言語プログラムとよく似ていることがわかります。

プログラムをアセンブルおよびリンクし、
AVR シミュレータ上で実行しましょう。
先ほどの ~.gdbinit~ ファイル (図 [[fig:avr/.gdbinit]]) がある作業ディレクトリで、
以下のように実行します。

#+begin_src gdb
$ avr-as -mmcu=attiny13a -o sum-10.o sum-10.s
$ avr-ld -m avr25 -Tdata 0x800060 -o sum-10 sum-10.o
$ avr-gdb -q sum-10
Reading symbols from sum-10...
(No debugging symbols found in sum-10)
Connected to the simulator.
Loading section .text, size 0xe lma 0x0
Start address 0x0
Transfer rate: 112 bits in <1 sec.
Breakpoint 1 at 0x0
(gdb) r ← run コマンド (省略形は r) を実行
Starting program: /home/ohsaki/code/avr/sum-10 

Breakpoint 1, 0x00000000 in _start ()
1: /x $r16 = 0x0
2: /x $r17 = 0x0
3: x/4i $pc
=> 0x0 <_start>:        ldi     r16, 0x00       ; 0
   0x2 <_start+2>:      ldi     r17, 0x01       ; 1
   0x4 <loop>:  add     r16, r17
   0x6 <loop+2>:        inc     r17
4: x/8xb 0x800060
0x800060:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
(gdb) 
#+end_src

stepi コマンド (省略形は si) を繰り返し実行し、
ループカウンタであるレジスタ R17 の値が 1 から 1 つずつ増えること、
また、
合計値であるレジスタ R16 の値が順番に増えていく様子を確認してみてください。

stepi コマンドを 4 回実行する (つまり 4 命令を実行する) と以下のような状態になっているはずです。
#+begin_src gdb
(gdb) si 4 ← stepi 命令を 4 回実行
0x00000008 in loop ()
1: /x $r16 = 0x1
2: /x $r17 = 0x2
3: x/4i $pc
=> 0x8 <loop+4>:        cpi     r17, 0x0B       ; 11
   0xa <loop+6>:        brcs    .-8             ;  0x4 <loop>
   0xc <done>:  rjmp    .-2             ;  0xc <done>
   0xe: nop
4: x/8xb 0x800060
0x800060:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
(gdb) 
#+end_src
レジスタ R16 に 1 が加算され、
値が 1 になっています。
ループカウンタであるレジスタ R17 は INC 命令によって値が +1 されて、
値が 2 になっています。

次の命令は、
比較命令である CPI 命令です。
レジスタ R17 の値を、
オペランドに指定した即値 0x0b (= 11) と比較します。
1 命令だけステップ実行してみます。
#+begin_src gdb
(gdb) si
0x0000000a in loop ()
1: /x $r16 = 0x1
2: /x $r17 = 0x2
3: x/4i $pc
=> 0xa <loop+6>:        brcs    .-8             ;  0x4 <loop>
   0xc <done>:  rjmp    .-2             ;  0xc <done>
   0xe: nop
   0x10:        nop
4: x/8xb 0x800060
0x800060:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
(gdb) 
#+end_src
汎用レジスタ R16 や R17 の値は変化していませんが、
CPI 命令の実行によってステータスレジスタが変化しているはずです。

AVR アーキテクチャ向けの GDB では、
ステータスレジスタの値は ~$SREG~ によって確認できます。
早速、
ステータスレジスタの値を 2 進数で表示してみましょう。
#+begin_src gdb
(gdb) p/t $SREG
$1 = 110101 ← ステータスレジスタの下位 6 ビットが表示されている
(gdb) 
#+end_src
ステータスレジスタの値から、
各ビットやフラグの状態がわかります (図 [[fig:avr/sreg]])。
今の場合、
レジスタ R17 (= 2) と 0x0b (= 11) を比較しているので、
S ビット、
N ビット、
C ビットが 1 になっています。

#+caption: ステータスレジスタの値と各ビットの対応
#+label: fig:avr/sreg
#+attr_latex: :width .5\columnwidth
[[./figure/avr/sreg.png]]

次の命令は、
条件付き分岐命令の \inst{brcs .-8} です。
今、
キャリーフラグ (C フラグ) は 1 になっているため、
現在のプログラムカウンタの値から -8 バイト (-4 ワード) だけ相対ジャンプします。
#+begin_src gdb
(gdb) si
0x00000004 in loop ()
1: /x $r16 = 0x1
2: /x $r17 = 0x2
3: x/4i $pc
=> 0x4 <loop>:  add     r16, r17
   0x6 <loop+2>:        inc     r17
   0x8 <loop+4>:        cpi     r17, 0x0B       ; 11
   0xa <loop+6>:        brcs    .-8             ;  0x4 <loop>
4: x/8xb 0x800060
0x800060:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
(gdb) 
#+end_src
プログラムカウンタの値が 0x4 に変化しました。

#+begin_note
アセンブリ言語のプログラム (図 [[fig:avr/sum-10.s]]) では BRLO (Brach if Lower) 命令を使用していましたが、
逆アセンブル結果では BRCS (Branch if Carry Set) 命令が表示されています。

BRLO 命令も BRCS 命令も、
直前の演算結果が負の場合にジャンプする命令です。
どちらの命令もステータスレジスタのキャリーフラグが 1 であればジャンプします。
2 つの命令のオペコードは同じです (したがって同じ命令です)。
プログラマが覚えやすいように 2 種類のニーモニックが利用できるようになっています。
#+end_note

最後に、
0x10 番地 (ラベルは ~done~) にブレークポイントを設定して、
プログラムを最後まで実行してみます。
#+begin_src gdb
(gdb) b done ← break done の省略形 (ラベル done のアドレスにブレークポイントを設定)
Breakpoint 2 at 0xc
(gdb) c ← continue の省略形 (プログラムの実行を継続)
Continuing.

Breakpoint 2, 0x0000000c in done ()
1: /x $r16 = 0x37
2: /x $r17 = 0xb
3: x/4i $pc
=> 0xc <done>:  rjmp    .-2             ;  0xc <done>
   0xe: nop
   0x10:        nop
   0x12:        nop
4: x/8xb 0x800060
0x800060:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
(gdb) 
#+end_src
ブレークポイントに到達して一時停止します。
このときのレジスタ R16 の値が、
正しく 0x37 (= 55 = 1 + 2 + \dots + 10) となっていることが確認できます。

次のプログラム ~sum.c~ は (図 [[fig:avr/sum.s]])、
先ほどのプログラム ~sum-10.s~ (図 [[fig:avr/sum-10.s]]) と同じロジックですが、
1〜100 の和を計算します。
1〜100 の和は 5 050 であり、
8 ビットのレジスタには収まりません。
そこで、
ループカウンタと合計値を、
8 ビットのレジスタペア (R19:R18 および R17:R16) に格納しています。

#+caption: avr/sum.s
#+label: fig:avr/sum.s
#+include: "code/avr/sum.s" src asm

合計値の下位 8 ビットをレジスタ R16 に、
上位 8 ビットをレジスタ R17 に格納しています。
これらのレジスタ用に、
ラベル ~suml~ および ~sumh~ を定義しています。
同様に、
ループカウンタの下位 8 ビットをレジスタ R18 に、
上位 8 ビットをレジスタ R19 に格納しています。
これらのレジスタ用に、
ラベル ~il~ および ~ih~ を定義しています。

16 ビットの加算や減算を行うためには、
基本的には、
下位バイトおよび上位バイトそれぞれに対して加算や減算を行う必要があります。
「8 ビットの加算や減算を 2 回繰り返すだけでよい」とも言えますし、
「8 ビットの加算や減算を、
毎回、
毎回、
2 回も繰り返さないといけない」とも言えます。

#+begin_note
このプログラムでは、
ループカウンタの値が 8 ビットに収まることを前提としており、
ループカウンタの下位バイトしか変更していません (手抜きプログラムです)。
\inst{cpi il, 101} の 101 という数値を書き換えれば、
1〜255 までの総和は計算できますが、
それを超える数までの和は (このままのプログラムでは) 計算できません。
#+end_note

プログラム ~sum.s~ をアセンブルし、
AVR エミュレータ上で実行します。
先ほどの ~sum-10.s~ (図 [[fig:avr/sum-10.s]]) とほぼ同じなので、
ここでは実行結果のみを示します。

#+begin_src gdb
$ avr-as -mmcu=attiny13a -o sum.o sum.s
$ avr-ld -m avr25 -Tdata 0x800060 -o sum sum.o
$ avr-gdb -q sum
Reading symbols from sum...
(No debugging symbols found in sum)
Connected to the simulator.
Loading section .text, size 0x14 lma 0x0
Start address 0x0
Transfer rate: 160 bits in <1 sec.
Breakpoint 1 at 0x0
(gdb) b done ← ラベル done のアドレスにブレークポイントを設定
Breakpoint 2 at 0x12
(gdb) r ← プログラムの実行を開始
Starting program: /home/ohsaki/code/avr/sum

Breakpoint 1, 0x00000000 in _start () ← アドレス _start でいったん停止
1: /x $r16 = 0x0
2: /x $r17 = 0x0
3: x/4i $pc
=> 0x0 <_start>:        ldi     r16, 0x00       ; 0
   0x2 <_start+2>:      ldi     r17, 0x00       ; 0
   0x4 <_start+4>:      ldi     r18, 0x01       ; 1
   0x6 <_start+6>:      ldi     r19, 0x00       ; 0
4: x/8xb 0x800060
0x800060:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
(gdb) c ← プログラムの実行を継続
Continuing.

Breakpoint 2, 0x00000012 in done () ← アドレス done で再度停止
1: /x $r16 = 0xba
2: /x $r17 = 0x13 ← 総和 R17:R16 の値は 0x13ba (= 5050)
3: x/4i $pc
=> 0x12 <done>: rjmp    .-2             ;  0x12 <done>
   0x14:        nop
   0x16:        nop
   0x18:        nop
4: x/8xb 0x800060
0x800060:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
(gdb) 
#+end_src

上記のプログラム ~sum.s~ は直接アセンブリ言語で書いたプログラムですが、
同じようなプログラムを C 言語で書いてみます (図 [[fig:avr/c/sum.c]])。

#+caption: avr/c/sum.c
#+label: fig:avr/c/sum.c
#+include: "code/avr/c/sum.c" src C

平凡なプログラムですが、
先ほどの ~add.c~ (図 [[fig:avr/c/add.c]]) と同様に、
関数 ~_start~ の最後に自分自身への RJMP 命令を埋め込んでいます。

また、
関数 ~_start~ の冒頭に
#+begin_src C
  asm ("eor __zero_reg__, __zero_reg__");	// R1 をゼロで初期化
#+end_src
という命令をインラインアセンブラで記述しており、
レジスタ R1 の値をゼロで初期化しています。

先ほど述べたように、
AVR アーキテクチャのマイクロコントローラでは、
電源投入後のレジスタの値や SRAM の値は不定です。
このため、
すべてのレジスタや SRAM の値は、
必ず初期化してから使用する必要があります。

GCC によって、
どのようなアセンブリ言語のプログラムに変換されるかを見てみましょう。
AVR アーキテクチャ向けの GCC では、
最適化オプション (~-O~ や ~-O2~ など) を有効にしないと、
かなり冗長なアセンブリ言語プログラムにコンパイルされるようです。
ここでは、
~-O2~ オプションを指定して、
最適化を有効にします。
#+begin_src sh
$ avr-gcc -fno-pic -fomit-frame-pointer -mmcu=attiny13a -O2 -S sum.c
#+end_src

#+begin_note
最適化を有効にしないと、
スタックを利用する (PUSH 命令や POP 命令を使用する) アセンブリ言語プログラムを生成します。
ATtiny13A はパワーオン・リセット時にスタックポインタを初期化しないため注意が必要です。

スタックを使用する場合は、
関数 ~_start~ の冒頭に
#+begin_src C
  asm ("ldi r16, 0x9f\n\t"	// スタックポインタを初期化
       "out __SP_L__, r16");
#+end_src
のようなコードを挿入するなどして、
スタックポインタの初期化を行う必要があります。
#+end_note

生成されたアセンブリ言語のプログラム ~sum.s~ を以下に示します (図 [[fig:avr/c/sum.ss]])。

#+caption: avr/c/sum.ss
#+label: fig:avr/c/sum.ss
#+include: "code/avr/c/sum.ss" src asm

アセンブリ言語で記述したプログラム (図 [[fig:avr/sum.s]]) とよく似たコードが生成されていることがわかります。

** コードリーディング
<<sec:avr/reading>>

*** 二重ループのサンプル (挿入ソート)

さらにいくつか AVR アーキテクチャ向けのアセンブリ言語プログラムを読んでみましょう。

まず、
挿入ソートのプログラムです (図 [[fig:avr/c/isort.c]])。
COMET II の章で示したプログラム (図 [[fig:comet/c/isort.c]]) と同じようなプログラムです。
ただし、
AVR アーキテクチャ向けに、
以下のような変更を加えています。
- 変数の型を ~int~ から ~char~ に変更 (AVR アーキテクチャは 8 ビット
  CPUのため)
- 関数 ~_start~ の冒頭で配列 ~a[]~ の値を初期化 (.data セクションに初
  期化済みデータがあっても SRAM 上に配置されないため)
- 変数宣言に ~register~ キーワードを追加 (自動変数をスタック上に確保す
  ると生成されるアセンブリ言語プログラムが複雑になるため)
- 関数 ~_start~ の末尾に自分自身への RJMP 命令を追加

#+caption: avr/c/isort.c
#+label: fig:avr/c/isort.c
#+include: "code/avr/c/isort.c" src C

C 言語で書かれたプログラム ~isort.c~ をコンパイルし、
アセンブリ言語のプログラム ~isort.s~ を生成します。
#+begin_src sh
$ avr-gcc -fno-pic -fomit-frame-pointer -mmcu=attiny13a -O2 -S isort.c
#+end_src

#+caption: avr/c/isort.s
#+label: fig:avr/c/isort.s
#+include: "code/avr/c/isort.s" src asm

GCC が生成したアセンブリ言語プログラム ~isort.s~ はそのままでは読みづらいため、
読みやすくなるように手を加えたものを図 [[fig:avr/isort.s]] に示します。

#+caption: avr/isort.s
#+label: fig:avr/isort.s
#+include: "code/avr/isort.s" src asm

GAS の疑似命令を一部削除するとともに、
C 言語で書かれたプログラムを元にいくつかラベルを定義しています。
C 言語におけるそれぞれの変数が、
アセンブリ言語におけるどのレジスタに対応しているかがわかるでしょうか。
ここではさらにプログラムの理解を助けるため、
コメントを追加してあります。

また、
プログラムの意図が明確になるように、
\inst{subi r19,lo8(-(1))} を \inst{inc r19} に置き換えています。
さらに、
GCC が生成した余分な (挿入ソートの実行には必要のない) 命令は削除しています。

これまでの知識でおおよそ読めるのではないでしょうか。

いくつかわかりづらそうな箇所にコメントします。
まず、
#+begin_src asm
        mov     r30, j          ; Z ← j (Z の下位バイト)
        ldi     r31, 0		;        (Z の上位バイト)
        movw    r26, r30        ; X ← Z
#+end_src
は、
16 ビットレジスタ (レジスタ Z ) に変数 ~j~ の値をコピーしています (レジスタ Z の実体は R31:R30 です)。
その後、
MOVW 命令によって、
レジスタ Z の値をレジスタペア R27:R26 にコピーしています。

その直後の、
#+begin_src asm
        subi    r26, lo8(-(a-1)); X ← a + X - 1
        sbci    r27, hi8(-(a-1))
        ld      r18, X          ; r18 ← a[j-1]  
#+end_src
も読みづらいですが、
これは ~a[j-1]~ の値をレジスタ R18 に格納しています。

~a[j-1]~ の値を取得するためには、
データ用メモリの ~a + j - 1~ 番地の値を読み出す必要があります。
そこで、
まず、
レジスタ X の値を ~a + j - 1~ に設定しています。
ここでは、
\begin{align}
  a + j - 1 = j + (a - 1) = j + (- (a - 1))
\end{align}
という関係が成り立つことを利用しています。

というのも、
今、
レジスタ X (実体は R27:R26) には変数 ~j~ の値が格納されています。
そこで、
レジスタ X の値から ~-(a - 1)~ を減算することにより、
レジスタ X の値が ~(a + j - 1)~ となります。
最後の \inst{ld r18, X} によって、
~a[j-1]~ の値 (レジスタ X が指すデータ用メモリの値) をレジスタ R18 に読み込んでいます。

AVR アーキテクチャでは、
アドレス指定モードの種類が少なく、
メモリアクセスには間接メモリ参照を多用します。
また、
レジスタにオペランドに指定した即値を加算する命令がないため、
即値の 2 の補数を減算 (SUBI 命令) することで代用しています。
こういった理由のため、
AVR アーキテクチャのアセンブリ言語プログラムは少しわかりづらいものになっています。
 
*** 再帰呼び出しのサンプル (フィボナッチ数)

最後に、
これも COMET II の場合 ([[sec:comet/reading]] 節) と同じように、
フィボナッチ数を求めるプログラムです。

まず、
C 言語で書かれたフィボナッチ数を求めるプログラムを示します (図 [[fig:avr/c/fib.c]])。

#+caption: avr/c/fib.c
#+label: fig:avr/c/fib.c
#+include: "code/avr/c/fib.c" src C

プログラムの先頭に
#+begin_src C
asm ("rjmp _start");    // リセット時のジャンプテーブル
#+end_src
を記述し、
AVR アーキテクチャの機械語プログラムの作法に従って、
0 番地にリセット時のジャンプテーブルを配置しています。

また、
関数 ~_start~ の冒頭に、
スタックポインタを初期化する
#+begin_src asm
asm ("ldi r16, 0x9f\n\t"        // スタックポインタを初期化
     "out __SP_L__, r16");
#+end_src
という命令を書いています。

先ほどのプログラム ~isort.s~ と同じように、
#+begin_src sh
$ avr-gcc -fno-pic -fomit-frame-pointer -mmcu=attiny13a -O  -S fib.c
#+end_src
によって、
C 言語で書かれたプログラムをコンパイルし、
アセンブリ言語のプログラムを生成します (図 [[fig:avr/c/fib.s]])。

#+caption: avr/c/fib.s
#+label: fig:avr/c/fib.s
#+include: "code/avr/c/fib.s" src asm

先ほどと同じように、
可読性を高めるよう変更したプログラムを以下に示します (図 [[fig:avr/fib.s]])。

#+caption: avr/fib.s
#+label: fig:avr/fib.s
#+include: "code/avr/fib.s" src asm

C 言語で書かれたプログラム (図 [[fig:avr/c/fib.c]]) とアセンブリ言語に変換されたプログラム (図 [[fig:avr/c/fib.s]]、
図 [[fig:avr/fib.s]]) をじっくり比較して読んでみてください。

** 章末問題
<<sec:avr/quiz>>

1. AVR マイクロコントローラのデータシートを入手せよ。もし AVR マイクロ
   コントローラを所有していれば、そのマイクロコントローラのものを、所
   有していなければ本書で扱った ATtiny13a のデータシート
   \cite{Microchip:ATtiny13A} を入手せよ。

2. AVR アーキテクチャの命令セットマニュアル \cite{Microchip:AVR-ISA}
   を入手せよ。

3. 1. で入手したマイクロコントローラのデータシートにおいて、キャリーフ
   ラグ (CF) の役割が説明されている箇所を特定して読んでみよ。

   #+begin_answer
   ATtiny13A のデータシート \cite{Microchip:ATtiny13A} では、
   「4.3.1 SREG -- Status Register」に説明がある。
   #+end_answer

4. レジスタ R16 の値を、レジスタ R17 と R18 の両方にコピーするアセンブ
   リ言語プログラムを示せ。

   #+begin_answer
   プログラムの例: ~copy.s~ (図 [[fig:avr/ex/copy.s]])
   #+caption: avr/ex/copy.s
   #+label: fig:avr/ex/copy.s
   #+include: "code/avr/ex/copy.s" src raw
   #+end_answer

5. レジスタ R16 の値の下位 4 ビットを、レジスタ R17 の下位 4 ビットに
   コピーするアセンブリ言語プログラムを示せ。ただし、レジスタ R17 の上
   位 4 ビットは変化させないこと。

   #+begin_answer
   プログラムの例 : ~copy-low.s~ (図 [[fig:avr/ex/copy-low.s]])
   #+caption: avr/ex/copy-low.s
   #+label: fig:avr/ex/copy-low.s
   #+include: "code/avr/ex/copy-low.s" src raw
   #+end_answer

4. 12 + 34 を計算するアセンブリ言語プログラムを示せ。

   #+begin_answer
   12 + 34 であれば 8 ビットのレジスタで計算できる。
   AVR アーキテクチャでは、
   即値の加算に SUBI 命令を使うことに注意。

   プログラムの例 : ~add.s~ (図 [[fig:avr/ex/add.s]])
   #+caption: avr/ex/add.s
   #+label: fig:avr/ex/add.s
   #+include: "code/avr/ex/add.s" src raw
   #+end_answer

5. 1234 + 567 を計算するアセンブリ言語プログラムを示せ。

   #+begin_answer
   8 ビットのレジスタでは計算できないため、
   8 ビットのレジスタのペア (計 16 ビット) を使って計算する。
   定数の上位 8 ビットおよび下位 8 ビットの取り出しには、
   GAS の修飾子 (lo8 および hi8) が使える。

   プログラムの例 : ~add16.s~ (図 [[fig:avr/ex/add16.s]])
   #+caption: avr/ex/add16.s
   #+label: fig:avr/ex/add16.s
   #+include: "code/avr/ex/add16.s" src raw
   #+end_answer

6. 1234 + 56 を計算するアセンブリ言語プログラムを示せ。

   #+begin_answer
   5.と同じプログラムでも計算できるが、
   加算する数が 0〜63 の範囲に収まる場合は、
   レジスタペアに対して即値を加算する ADIW 命令が利用できる。

   プログラムの例 : ~add16-adiw.s~ (図 [[fig:avr/ex/add16-adiw.s]])
   #+caption: avr/ex/add16-adiw.s
   #+label: fig:avr/ex/add16-adiw.s
   #+include: "code/avr/ex/add16-adiw.s" src raw
   #+end_answer

7. (123 + 45) ~>>~ 3 (~>>~ は右へのビットシフト) を計算するアセンブリ
   言語プログラムを示せ。

   #+begin_answer
   123 + 45 を計算した後、
   右に 3 回ビットシフトするだけだが、
   AVR アーキテクチャでは 1 ビットシフトしかないため、
   1 ビットシフトを 3 回繰り返す必要がある。

   プログラムの例 : ~add-shift.s~ (図 [[fig:avr/ex/add-shift.s]])
   #+caption: avr/ex/add-shift.s
   #+label: fig:avr/ex/add-shift.s
   #+include: "code/avr/ex/add-shift.s" src raw
   #+end_answer

8. レジスタ R16 の値 (符号なし整数) が 123 以上であればレジスタ R17 を
   1 にし、そうでなければ 0 にするアセンブリ言語プログラムを示せ。

   #+begin_answer
   比較命令でステータスレジスタを設定し、
   ステータスレジスタの値に応じて条件分岐命令で分岐する。
   比較するレジスタが R16 と即値 123 であれば、
   CPI 命令が使用できる。

   プログラムの例 : ~cmp.s~ (図 [[fig:avr/ex/cmp.s]])
   #+caption: avr/ex/cmp.s
   #+label: fig:avr/ex/cmp.s
   #+include: "code/avr/ex/cmp.s" src raw
   #+end_answer

9. レジスタ R16 の値が奇数であればレジスタ R17 を 1 にし、そうでなけれ
   ば 0 にするアセンブリ言語プログラムを示せ。

   #+begin_answer
   AVR アーキテクチャにはビットテストと条件分岐を 1 命令でできる命令があるため非常に簡潔に書ける。
   SBRC 命令は、
   汎用レジスタの特定のビットが 0 かどうかをチェックし、
   0 であれば次の命令の実行をスキップするという命令である。

   プログラムの例 : ~is-odd.s~ (図 [[fig:avr/ex/is-odd.s]])
   #+caption: avr/ex/is-odd.s
   #+label: fig:avr/ex/is-odd.s
   #+include: "code/avr/ex/is-odd.s" src raw
   #+end_answer

10. レジスタ R16 の値を 16 倍にするアセンブリ言語プログラムを示せ。

   #+begin_answer
   16 = 2^4 であるため、
   レジスタ R16 の値を左方向に 4 回ビットシフトすればよい。
   LSL 命令を 4 回繰り返してもよいが、
   4 ビットシフトの場合は SWAP 命令を使うとより簡潔に書ける。
   SWAP 命令は、
   レジスタの値の上位 4 ビットと下位 4 ビットを交換する命令である。

   プログラムの例 : ~quad.s~ (図 [[fig:avr/ex/quad.s]])
   #+caption: avr/ex/quad.s
   #+label: fig:avr/ex/quad.s
   #+include: "code/avr/ex/quad.s" src raw
   #+end_answer

11. 「1 - 2 + 3 - 4 + \dots + 99 - 100」を計算するアセンブリ言語プログ
   ラムを示せ。

   #+begin_answer
   プログラムの例 : ~sum.s~ (図 [[fig:avr/ex/sum.s]])
   #+caption: avr/ex/sum.s
   #+label: fig:avr/ex/sum.s
   #+include: "code/avr/ex/sum.s" src raw
   #+end_answer
