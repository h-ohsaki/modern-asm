# -*- Org -*-
# 
# Copyright (c) 2021, Hiroyuki Ohsaki.
# All rights reserved.
# 

# This document is licensed under a Creative Commons
# Attribution-NonCommercial-ShareAlike 4.0 International License (CC
# BY-NC-SA 4.0).

# This document is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# Creative Commons License for more details.

# You should have received a copy of the license along with this work.
# If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

* アセンブラとアセンブリ言語
<<ch:asm>>

** アセンブリ? アセンブル? アセンブラ?
<<sec:asm/terminlogy>>

まず、
アセンブリ言語プログラミングで利用される専門用語 (テクニカルターム) を説明します。
「同じようで、
微妙に意味の異なる」用語がたくさんありますが、
これらの違いを理解し、
区別できるようになることが重要です。

*** 日本語訳はわかりづらい

コンピュータ関係の用語は、
「カタカナで覚えるのではなく、
もともとの英語表記で覚える」ことをおすすめします。
日本語を母語とする人は、
カタカナを見ても語感が働かないからです。

例えばみなさんは、
*オペレータ* や *オペランド* という文字の列を見るだけで、
それぞれの意味の違いを感じられるでしょうか?
(図 [[fig:asm/operator]])

#+caption: オペレータ (演算子) とオペランド (被演算子)
#+label: fig:asm/operator
#+attr_latex: :width .5\columnwidth
[[./figure/asm/operator.png]]

コンピュータサイエンスの世界では、
- オペレータの日本語訳は *演算子*
- オペランドの日本語訳は *被演算子*
となります。
同じ概念でも、
漢字で表記されるとまた違って感じられることでしょう。

「演算子」と「被演算子」でもまだわかりづらいですが、
日本語が母語の方で、
漢字に慣れ親しんだ人であれば、
「子」や「被」という漢字から
- 「演算子」は演算 *する* 側
- 「被演算子」は演算 *される* 側
という判別はできるでしょう。

しかし、
「オペレータ」と「オペランド」という文字の列を見ても、
おそらく頭の中には何もイメージが湧かないでしょう。
「オペレータって、
エレベーターとか機械を操作する人のこと?」
とか、
「オペランドって、
オペラが観られるテーマパークのこと?
(オペラランド?)」
のような (見当違いの) 想像しかできないかもしれません。

日本語を母語とする人は、
カタカナ語を見ても、
その単語が意味する概念をイメージすることが困難です。

日本語を母語とする人は、
カタカナ語を見ても、
その単語が意味する概念をイメージすることが困難です。
もともとの英語表記を見れば (英語が母国語でなくても、
多少なりとも英語が理解できる人なら) 単語が意味する概念のイメージを持つことができます。

一方、
英語を母語とする人は、
- operator: operate + or → operate する人や物
- operand: ラテン語の operandum が由来
のように、
字面を見るだけでおおよそのイメージが得られます。
通常、
英語を母語とする人には、
「operator と operand、
どっちがどっちだったっけ?」
のようにわからなくなることはありません。

*** 専門用語がわからない (1つの) 理由

外国で生まれて日本に入ってきた概念は、
(日本に入ってくるときに名付けられた) 日本語の名前で考えるのではなく、
(概念が生まれたときに名付けられた) 英語の名前で考えましょう。
なぜなら翻訳者が付けた日本語の名前ではなく、
考案者・発明者が付けた英語の名前のほうが、
ほとんどの場合、
より適切な名前が付けられているからです。

わかりづらいのはカタカナ語だけに限りません。
コンピュータサイエンスに限らず、
数学などでも同じことがいえます。

例えば、
数学を学ぶ際には、
- 正則行列
- べき級数
- 線形回帰分析
- 行列式
- 正規分布
- 検定
などの概念が、
「よくわからない」と思わなかったでしょうか?

50〜100 年前の日本人であれば、
英語の名前よりも、
漢字で表記された名前のほうが理解しやすかったのかもしれませんが、
少なくとも現代では「正則」、
「級数」、
「回帰」、
「正規」などの言葉は日常ではほとんど使用しません。
このため、
漢字で表記されたこのような名前から、
それぞれの名前が表す概念をイメージするのは困難です。

一方、これらの単語のもともとの英語名は以下のようになっています。
- regular matrix: 正則行列
- power series: べき級数
- linear regression analysis: 線形回帰分析
- determinant: 行列式
- normal distribution: 正規分布
- test: 検定

このうち「regression」や「determinant」は見慣れない単語かもしれませんが、
それ以外は平易な単語ばかりです。
例えば「正則行列」よりも「regular (規則的な) matrix」のほうが意味を理解しやすいと思います。
また同じく、
「正規分布」よりも「normal (普通の) distribution」のほうが意味を理解しやすいことでしょう。

他にも「行列式」だと何のことかわかりませんが、
元の英語名は「determinant」つまり「決定付けるもの」です (図 [[fig:asm/det]])。
おそらく、
先人たちが苦心の末、
determinant に「行列式」という訳語を付けたのでしょうが、
訳語が元の英語名からずれているため、
日本人が determinant という概念を理解する妨げになっているともいえます。

#+caption: 行列 (matrix) と行列式 (determinant)
#+label: fig:asm/det
#+attr_latex: :width .5\columnwidth
[[./figure/asm/det.png]]

Oxford Learner's Dictionary of Academic English \cite{OLDA} によれば、
determinant の意味は
#+begin_quote
(mathematics) a quantity obtained by the addition of products of the elements
of a square matrix according to a given rule
#+end_quote
です。
このように determinant がそもそも quantity (量) を表しているにもかかわらず、
その訳語が行列「式」 (expression) となっているために、
「行列式は、
名前は『式』だが、
実際には『量』を意味する」ことは容易には想像できないでしょう。

このように、
その概念をより正しく、
簡単に理解するためにも日本語の名前で考えるのではなく、
もともとの英語の名前で考えることが重要なのです。

*** アセンブリ言語プログラミングに関する用語

以下では、
アセンブリ言語プログラミングに関連する用語の中で、
特に混同しやすいと思われるものを説明します。
なおここでは先ほど述べたように、
カタカナ表記だけでなく、
理解を進めるためにも英語表記もあわせて記します。
もしどちらか一方だけを覚えるのであれば、
ぜひ英語表記のほうを覚えるようにしてください。

コンピュータサイエンスの世界における外来語 (カタカナ語) には耳慣れないものも多く、
非常にわかりづらいのも事実ですが、
一つ一つの言葉の意味を理解して、
正しく使えるようになることが大切です。
言葉を正しく使うことができれば、
他の人とのコミュニケーションも容易になりますし、
何よりも、
みなさん自身がものごとを正しく理解する助けになります。

**** ソースコード (source code)

日本語に訳すと「元符号」です。
ソフトウェアの「元」となる「符号 (コード = 命令の列)」という意味です。

一般には、
C 言語や Java 言語など、
何らかのプログラミング言語で記述されたプログラムのことを意味します。
C 言語や Java 言語のようなコンパイル型言語では、
ソースコードをコンパイルして、
実行形式のプログラムを得ることになります (図 [[fig:asm/flow]])。
また Python 言語のようなインタプリタ型言語では、
ソースコードを解釈しながら処理を実行していきます。
インタプリタ型言語のプログラムもソースコードと呼ばれますが、
主にコンパイル型言語のプログラムをソースコードと呼ぶことが多いようです。

#+caption: ソースコードとコンパイラ、インタプリタ、アセンブラの関係
#+label: fig:asm/flow
#+attr_latex: :width \columnwidth
[[./figure/asm/flow.png]]

**** 機械語 (machine language)

*CPU (Central Processing Unit)* が直接理解できる命令のことで、
「マシン語」とも呼ばれます。

例えば、
インテル IA-32 アーキテクチャの CPU では、
16 進数で「0x83、
0xc0、
0x01」という命令は、
「EAX レジスタに 1 を加えよ」ということを意味します。
また、
「0x31、
0xc0」という命令は、
「EAX レジスタに 0 を代入せよ」を意味します。

上で説明した「ソースコード」は、
多くの場合、
C 言語や Java 言語などの *高級言語 (high-level language)* で書かれます。
高級言語では、
- 人間にとって書きやすいこと
- 人間にとって読みやすいこと
が特に重視され、
機械語はこうした高級言語と対比して *低級言語 (low-level language)* と呼ばれます。

特に注意しておきたいのは、
低級言語が決して「程度が低く劣っている言語」なのではなく、
「抽象度が低い言語」というニュアンスである点です。
機械語は、
人間にとって書きやすくも読みやすくもない言語であり、
もちろん機械語を人間が直接書くことも可能ですが、
膨大な (通常、
不要な) 時間と労力がかかります。

**** アセンブリ言語 (assembly language)

日本語に訳すと「組み立て言語」です。
英語の assembly は「組み立てること」を意味します (図 [[fig:asm/flow]])。

アセンブリ言語とは、
「機械語にほぼ 1 対 1 で対応する命令を並べることによってプログラムを記述する」プログラミング言語です。
例えば、
インテル IA-32 アーキテクチャの CPU において、
「EAX レジスタに 1 を加えよ」という機械語の命令である
#+begin_quote
0x83, 0xc0, 0x01
#+end_quote
を、
アセンブリ言語では
#+begin_src asm
	add	$0x1, %eax
#+end_src
のように記述します。
アセンブリ言語の詳細を知らなくても、
#+begin_quote
add $0x1 to %eax. ($0x01 を %eax に加えよ)
#+end_quote
という命令文として (何となく) 読めると思います。

一般的なプログラマにとって、
0x83 のような 16 進数で表記された機械語から、
それらの命令によって行われる処理を把握するのは容易ではありません。
一方、
アセンブリ言語のプログラムであれば、
「EAX レジスタに 1 を加えよ (add せよ)」ということを (少し学習するだけで) 読み取ることができます。

このように、
人間にとっては意味不明な数字の列である機械語と比較すると、
アセンブリ言語は、
はるかに人間にとって書きやすく読みやすい言語だといえます。

ただし、
「アセンブリ言語の命令と機械語がほぼ 1 対 1 に対応する」ということは、
「CPU やコンピュータのアーキテクチャが異なると、
アセンブリ言語で書くプログラムも異なる」ということも意味します。
例えば、
IA-32 アーキテクチャの CPU を搭載したコンピュータ上で動作するプログラムをアセンブリ言語で記述したい場合は、
IA-32 アーキテクチャのアセンブリ言語を習得するとともに、
そのコンピュータのハードウェア構成も理解する必要があるのです。

アセンブリ言語では、
機械語の *命令コード (operation code; opcode)* に付けられた識別子 (= 名前) のことを *ニーモニック (mnemonic; 記憶を助けるもの)* と呼びます。
上の例では、
add が、
命令コード 0x83 (加算命令) に対応するニーモニックです。
英語の mnemonic は「記憶を助けるもの」という意味です。

#+begin_note
コンピュータサイエンスの世界では、
*識別子 (identifier)* という用語が頻繁に登場します。

識別子と聞くと、
何だか高級で難しい概念に聞こえますが、
ほとんどの場合、
「識別子 = 名前」と機械的に読み替えても問題ありません。
マニュアルや専門書などを読んでいるときに、
識別子という (一見すると難解そうな) 専門用語が出てきたら「識別子 (identifier) と名前 (name) は同じ意味」であることを思い出してください。
#+end_note

**** アセンブル (assemble)

日本語に訳すと「組み立てる」です。
英語の assemble は動作を表す *動詞* であることに注意してください。

アセンブルとは、
アセンブリ言語で書かれたプログラムを、
機械語に変換するという操作のことを意味します (図 [[fig:asm/flow]])。
先ほどの例では、
アセンブリ言語で書かれた
#+begin_src asm
	add	$0x1, %eax
#+end_src
というプログラムを、
0x83、
0xc0、
0x01 という、
CPU が直接理解できる機械語に変換することを意味します。

アセンブリ言語で書かれたプログラムを機械語に変換するソフトウェアが、
この次に説明する *アセンブラ* です。

**** アセンブラ (assembler)

日本語に訳すと「組み立てる人」です。
通常、
アセンブラとは、
アセンブリ言語で書かれたプログラムを機械語に変換する (アセンブルする) ための *処理系 (ソフトウェア)* を意味します (図 [[fig:asm/flow]])。

英語では assembler であり、
assemble (組み立てる) の語尾に -er が付け加わった単語です。
「-er」という語尾は、
例えば
- プロデューサ: producer = produce + er → プロデュースする人
- マネージャ: manager = manage + er → 管理する人
- ドライバ: driver = drive + er → 運転する人
などのように、
行為を行う人や物を表します。
このため、
英語の assembler も、
「組み立てる *人や物*」を意味します。

先ほど紹介した「C 言語で書かれたソースコードを機械語に変換するもの」は *コンパイラ (compiler = コンパイルする人や物)* であるように、
「アセンブリ言語で書かれたプログラムを機械語に変換するもの」がアセンブラです。
つまりアセンブラとは、
「アセンブリ言語で書かれたプログラムを入力し、
機械語で書かれたプログラムを出力するソフトウェア」を意味します。

*** 正しい用語? 間違った用語?

ここまで説明してきたことからわかるように、
「アセンブリ言語のプログラムを、
アセンブラを使ってアセンブルする」というのが正しい用法になります。
- アセンブ _リ_ 言語
- アセンブ _ル_
- アセンブ _ラ_
という用語で異なっているのは最後の 1 文字だけですが、
- アセンブ _リ_ : 組み立てるという「行為」
- アセンブ _ル_ : 組み立ての「動作」
- アセンブ _ラ_ : 組み立てる「人や物」
と、
それぞれ異なる意味を持ちます。

つまり、
アセンブリ言語によるプログラミングのことを、
- アセンブラのプログラム
- アセンブラプログラミング
などと呼ぶのは論理的には間違っています。
同様に、
- プログラムをアセンブリする
- アセンブル言語
なども論理的に間違っているといえます。

これらの言葉を字句どおりに (ある意味無理やりにでも) 解釈すれば以下のような意味になります。

**** アセンブラのプログラム?

この言葉は、
アセンブラ (アセンブリ言語から機械語へと変換する処理系) そのものの実行ファイルやソースコードを意味します。

「コンパイラのプログラム」は、
GCC (GNU Compiler Collection) や Clang のような「コンパイラ」のプログラムそのもの (実行ファイルやソースコード) を意味し、
同様に「アセンブラのプログラム」は、
GAS (GNU Assembler) や MASM (Microsoft Macro Aassembler) のような「アセンブラ」のプログラムそのものを意味します。

**** アセンブラプログラミング?

この言葉は、
「アセンブラ (アセンブリ言語から機械語へと変換する処理系) そのものを、
プログラミング言語を用いて開発・実装すること」という意味になります。

残念ながら、
すでに日本国内では、
「アセンブラプログラミング」という表現が、
「アセンブリ言語プログラミング」の意味で広く使われてしまっています。

#+begin_note
外国人の方に英語で、
「アセンブリ言語によるプログラミングを学んでいます」と言うつもりで、
#+begin_quote
I have been learning assembler programming.
#+end_quote
と言うと、
相手の方は
#+begin_quote
アセンブラという処理系の設計・実装方法を学んでいる (君は新しい CPU でも設計しているのかね?)
#+end_quote
などと思うでしょう (もちろん文脈から理解してもらえるかもしれませんが)。
#+end_note

**** プログラムをアセンブリする?

この言葉を元の言葉の定義どおり解釈すると、
何を意味しているか解釈するのは困難です。

**** アセンブル言語?

これも解釈は容易ではありませんが、
何らかの組み立て工程を記述するための形式言語 (例えば、
ソフトウェアのビルド手順を記述した XML (Extensible Markup Language) といった意味になるでしょう。

**** アセンブラ言語?

「アセンブラ言語」を文字通り解釈すれば、
- アセンブラ (アセンブリ言語から機械語へと変換する処理系) を記述するた
  めの専用のプログラミング言語
- アセンブラに組み込まれている独自のマクロ言語
などの意味になり、
コンパイラを開発するための「コンパイラコンパイラ」に相当するような、
アセンブラを開発するための専用のプログラミング言語のように聞こえます。
つまり、
アセンブリ言語のことを「アセンブラ言語」と呼ぶのは論理的に変です。

ただし、
アセンブリ言語を「アセンブラ言語」と呼ぶのは、
必ずしも間違いとは言えない状況になっています。
英語圏では assembler language ではなく、
assembly language と呼ぶのが一般的ですが、
少なくとも IBM は、
アセンブリ言語のことを「assembler language」と呼んでいたようです。
これは、
「アセンブラ (assembler) が解釈する言語 (language)」という意味だと考えられます。
また、
独立行政法人情報処理推進機構 IPA (Information-technology Promotion Agency) が実施している国家資格試験、
「情報処理技術者試験」でも、
アセンブリ言語のことを「アセンブラ言語」と呼んでいます。

** プログラムの表現
<<sec:asm/representation>>

*** プログラムとは何か?

コンピュータにおける *プログラム (program)* とは、
コンピュータに対する命令の列 (a series of instruction) です。
例えば JIS X0001-1994 「情報処理用語 - 基本用語」では、
プログラムとは
#+begin_quote
アルゴリズムの記述に適した人工言語の規則に従った構文上の単位であって，
ある機能若しくは仕事の遂行又は問題の解決のために必要な宣言と文若しくは命令とから構成されるもの．
#+end_quote
と定められています。
コンピュータに実行させたい *計算手順 (アルゴリズム)* を、
「プログラミング言語」と呼ばれる人工言語によって記述したもの、
という意味です。

#+begin_note
*JIS (Japanese Industrial Standards; 日本産業規格)* とは、
日本の産業製品に関する規格や測定法などを定めている日本の規格であり、
従来は「日本工業規格」と呼ばれていました。
私も「JIS = 日本工業規格」と覚えていたのですが、
2019 年 7 月に「日本産業規格」に名前が変更されました。

当初「日本工業規格」と呼ばれていたように、
もともとは鉱工業品の種類・形状・寸法・構造などを定めた規格でした。
身近なものでは、
ネジの形状や寸法、
コネクタの形状や寸法などが JIS で定められています。

現在は、
コンピュータのハードウェアやソフトウェアに関する規格もあります。
JIS の規格には、
分野ごとに記号 (表 [[tab:jis-category]]) が割り当てられていますが、
コンピュータに関連する規格には、
*X (情報処理)* という分野記号が付いています。
コンピュータ関連の規格を探す場合は、
X から始まる規格をチェックしてください。

なお、
JIS 規格は日本産業標準調査会の Web ページで閲覧することができます \cite{JISC:View}。
2020 年 12 月から閲覧にはユーザ登録が必要となりましたが、
無料で閲覧できます。
#+end_note

#+caption: JIS (日本産業規格) の分野記号
#+label: tab:jis-category
| 分野記号 | 分野               |
|----------+--------------------|
| A        | 土木及び建築       |
| B        | 一般機械           |
| C        | 電子機器及び電気機 |
| D        | 自動車             |
| E        | 鉄道               |
| F        | 船舶               |
| G        | 鉄鋼               |
| H        | 非鉄金属           |
| K        | 化学               |
| L        | 繊維               |
| M        | 鉱山               |
| P        | パルプ及び紙       |
| Q        | 管理システム       |
| R        | 窯業               |
| S        | 日用品             |
| T        | 医療安全用具       |
| W        | 航空               |
| X        | 情報処理           |
| Z        | その他             |

*** 抽象度の異なるさまざまなプログラム

コンピュータのプログラムといっても、
コンピュータに対する命令の抽象度の違いによってさまざまな形態のプログラムがあり、
JIS の「情報処理用語 - 基本用語」で言うところの人工言語 (プログラミング言語) にどのような言語を用いるかによって、
プログラムの表現が大きく異なります。

最も低レベルな (原始的な) プログラムは、
コンピュータの CPU が直接理解できる機械語で書かれたものです。

機械語で書かれたプログラムよりも、
少しだけ抽象度が上がったものが、
アセンブリ言語で書かれたプログラムです。
機械語で書かれたプログラムは単なるビット列ですので、
そのままでは読むのは非常に困難です。
一方、
アセンブリ言語で書かれたプログラムは、
それぞれの命令をニーモニックで記述しています。
アセンブリ言語で書かれたプログラムは、
機械語と比較すると、
はるかに読みやすくなっています。

アセンブリ言語で書かれたプログラムよりも、
さらに抽象度が上がったものが、
*中間表現 (intermediate representation)* や *バイトコード (bytecode)* と呼ばれるプログラムです。
高級言語のコンパイラ / インタプリタの内部形式や、
仮想マシンで実行されるバイトコードです。
一般のプログラマが中間表現やバイトコードのプログラムを書くことはなく、
高級言語とアセンブリ言語/機械語の橋渡しに使われています。

さらに抽象度が上がったものが、
C 言語や Java 言語のような高級言語で書かれたプログラムです。
C や Java に限らず、
Fortran、
Basic、
Pascal、
Algol、
Python、
Perl、
Ruby、
awk、
sed、
Lisp、
Go、
Forth、
Prolog など、
さまざまなプログラミング言語が存在します。
これらはすべて高級言語に分類されます。

#+begin_note
現在、
世界中に何種類のプログラミング言語が存在しているのでしょうか?

数十でしょうか?
それとも数百でしょうか?
それとも、
数千のプログラミング言語が存在しているでしょうか?

世界中のプログラミング言語を集めて掲載している辞典があります \cite{Pigott:HOPL}。
ここには、
2021 年 1 月の時点で 8 945 種類のプログラミング言語が掲載されています。
他にも、
マイナーなものまで含めると世界中にはもっと多くのプログラミング言語が存在すると考えられます。
正確な推計は困難ですが、
数万種類くらいのプログラミング言語が存在するのではないでしょうか。
#+end_note

機械語のプログラムも、
アセンブリ言語で書かれたプログラムも、
高級言語で書かれたプログラムも、
すべてコンピュータのプログラムです。

ただし、
コンピュータの CPU は、
C 言語や Java 言語で書かれたプログラムをそのままでは解釈できません。
あらゆるプログラムは、
最終的にすべて機械語に変換され、
そのあと CPU によって実行されます。

例として、
C 言語で書かれたプログラムを考えてみましょう。

C コンパイラは、
このプログラムのソースコードをコンパイルし、
オブジェクトファイル (中身は主に機械語のプログラム) を生成します。
C コンパイラは、
以下のような手順で、
C 言語で書かれたプログラムを機械語のプログラムにコンパイルします (図 [[fig:asm/compile]])。

1. C 言語で書かれたプログラムを解釈し、コンパイラの内部形式で表現する
2. コンパイラの内部形式の状態で、プログラムの最適化を行う
3. 最適化されたコンパイラの内部形式のプログラムをアセンブリ言語のプロ
   グラムに変換する
4. アセンブリ言語で書かれたプログラムを (アセンブラによって) 機械語に
   変換する

#+caption: C コンパイラによる C 言語から機械語へのコンパイルの流れ
#+label: fig:asm/compile
#+attr_latex: :width \columnwidth
[[./figure/asm/compile.png]]

** 高級言語からアセンブリ言語へ
<<sec:asm/lang-to-asm>>

*** 高級言語によるプログラムの記述

[[sec:asm/terminlogy]] 節で述べたように、
アセンブリ言語と機械語はほぼ 1 対 1 で対応しています。
アセンブリ言語で記述する命令の *粒度 (granurality)* は非常に小さいものです。
したがって、
コンピュータにあるまとまった処理を実行させるためには、
アセンブリ言語で多数の命令を記述する必要があります。

このため、
プログラムを作成する場合は、
アセンブリ言語ではなく、
(抽象度が高い、
つまり命令の粒度が大きい) 高級言語が広く用いられています。
高級言語は命令の粒度が大きいため、
コンピュータにあるまとまった処理を実行させるプログラムを、
アセンブリ言語よりもはるかに少ない命令数で記述できます。

ここで、
高級言語とアセンブリ言語の対応関係を少し眺めてみましょう。
C 言語で書かれた、
以下のプログラム ~add.c~ (図 [[fig:asm/add.c]]) を使います。

#+caption: asm/add.c
#+label: fig:asm/add.c
#+include: "code/asm/add.c" src C

2 つの整数 (123 と 456) を加算するだけの単純なプログラムです。
*大域変数 (global variable)* として変数 ~i~ を宣言し、
123 で初期化しています。
関数 ~main~ では、
変数 ~i~ に 456 を加算しています。

#+begin_note
大域変数の宣言時に
#+begin_src C
volatile int i = 123;
#+end_src
のように ~volatile~ キーワードを付与しています。

volatile は、
英語で「変わりやすい、
不安定な」という意味を持つ形容詞です。
C 言語の ~volatile~ は、
変数宣言時に付与できるキーワードであり、
宣言した変数が「変わりやすい」ことを C コンパイラに伝えます。
C コンパイラに対して、
#+begin_quote
~volatile~ を付けた変数は、
C 言語で書かれたプログラム以外から値を操作することがあるよ。
そのことを知っておいてね。
#+end_quote
ということを伝えます。

本書では、
~volatile~ を「C コンパイラによる最適化を抑制する」ために使用しています。
上の ~add.c~ プログラムで、
変数宣言に volatile を付けない場合、
C コンパイラは
#+begin_quote
変数 ~i~ を宣言して、
関数 ~main~ で 456 を加算してるけど、
結局、
計算結果を使ってないよね。
じゃあ、
そもそも変数 ~i~ も、
関数 ~main~ で 456 を加算することも無駄だね。
余計なコードはこちらで全部カットしよう。
#+end_quote
と判断して、
中身がほぼ空の機械語に変換してしまいます。
~volatile~ キーワードを付けておくと、
C コンパイラは
#+begin_quote
変数 ~i~ を宣言して、
関数 ~main~ で 456 を加算してるけど、
結局、
計算結果を使ってないよね。
ああ、
でも変数 ~i~ は ~volatile~ だから、
勝手にコードを省略したらまずいのか。
変数 ~i~ に関連するコードはそのまま生成しよう。
#+end_quote
と判断して、
C 言語で記述したプログラムをのまま機械語に変換します。
#+end_note

C コンパイラが、
どのように高級言語 (C 言語) からアセンブリ言語へと変換するかを見てみましょう。
なお、
ここでは代表的な C コンパイラである GCC (GNU Compiler Collection) を使います。

** C 言語から機械語へのコンパイル
<<sec:asm/c-to-machine>>

C 言語で書かれたプログラム ~add.c~ を機械語にコンパイルするには、
#+begin_src sh
$ gcc -c add.c
#+end_src
というコマンドをシェルから実行します。
これにより、
~add.c~ を機械語にコンパイルした *オブジェクトファイル (object file)* ~add.o~ が生成されます。
なお本書では、
特に断りのない限り、
#+begin_src sh
$ gcc -fno-pic -fomit-frame-pointer -c add.c
#+end_src
のように、
コンパイル時に ~-fno-pic~ オプションと ~-fomit-frame-pointer~ オプションを指定します。

#+begin_note
~-fno-pic~ オプションは、
GCC に *位置非依存のコード (PIC; Position-Independent Code)* を生成 *しない* ことを指示するオプションです。

機械語のプログラムは、
通常は配置されたアドレスに依存したプログラムになります。
0x4000 番地に配置するように作られたプログラムは、
0x8000 番地にロードしても実行できません (動作しません)。
というのも、
プログラムが配置されるアドレスに依存した機械語になっているからです。

位置非依存のコード (PIC) とは、
メモリのどこにロードしても動作するような機械語のプログラムであり、
0x4000 番地にロードしても、
0x8000 番地にロードしても正常に動作します。
つまり、
プログラムが配置されたアドレスに依存しないような (ある意味特殊な) 機械語になっているのです。

~-fno-pic~ オプションを使用すると、
リンカによっては以下のような警告が出ることがありますが、
本書の内容を学ぶ上では気にしなくて構いません。
#+begin_src sh
$ gcc -fno-pic -fomit-frame-pointer add.c -o add
/usr/bin/ld: /tmp/cckhJitR.o: warning: relocation against `i' in read-only section `.text'
/usr/bin/ld: warning: creating DT_TEXTREL in a PIE
#+end_src

また、
~-fomit-frame-pointer~ オプションは GCC に *フレームポインタ (frame pointer)* を管理するコードを生成 *しない* ことを指示するオプションです。

C 言語のような高級言語では、
スタック上に *スタックフレーム (stack frame)* と呼ばれるデータ構造を確保することで関数呼び出しを実現していますが、
GCC は通常、
デバッガの監視下でプログラムを実行したときに、
スタックフレームの状態を把握できるようにするためにフレームポインタを管理するコードを生成します。
~-fomit-frame-pointer~ オプションでその生成が抑制されますが、
フレームポインタは主にデバッグのために使用するものなので、
フレームポインタがなくてもプログラムは問題なく動作します。

本書では、
C コンパイラに素直なコードを生成させるために、
~-fno-pic~ オプションおよび ~-fomit-frame-pointer~ オプションを指定しています。
#+end_note

~-c~ オプションを指定せずに、
#+begin_src sh
$ gcc -fno-pic -fomit-frame-pointer -o add add.c
#+end_src
を実行すれば、
*実行ファイル (executable file)* ~add~ が生成されます。
~-o~ オプションは、
生成する実行ファイルのファイル名を指定するオプションです。

生成した実行ファイルは以下のように実行できます。

#+begin_src sh
% ./add
#+end_src

ただし、
~add.c~ は、
内部で 123 と 456 を加算するだけで、
何も出力しません。
そのため、
実行ファイル ~add~ を実行しても何も表示されません。

*** gcc コンパイラの内部動作

実際には、
~gcc~ コマンドそのものは C コンパイラの本体ではなく、
C コンパイラの *フロントエンド (font end)* になっています。

~-v~ (verbose: 冗長) オプションを指定して ~gcc~ コマンドを実行すると、
~gcc~ コマンドがコンパイル時に内部的に行っている処理を標準出力に (冗長に) 表示します。

早速見てみましょう。

#+caption: GCC がコンパイル時に行っている処理
#+label: fig:asm/gcc.log-short
#+include: "code/asm/gcc.log-short" src raw

#+begin_note
実行する環境 (オペレーティングシステム、
コンピュータのアーキテクチャ、
ソフトウェアのバージョンの違い) によって、
~-v~ オプションによって出力されるメッセージは変化します。
#+end_note

冗長オプションを有効にしたため、
さまざまな情報が出力されていますが、
情報が多くわかりづらいので、
特に重要な箇所だけを抜き出してみましょう。

すると、
#+include: "code/asm/gcc.log-summary" src raw
のように、
gcc コマンドは ~cc1~、
~as~、
~collect2~ という別々のプログラムを、
それぞれ順番に起動していることがわかります。

1 行ずつ順番に見ていきましょう。
まず、
gcc が第 1 ステージのコンパイラ ~cc1~ を起動しています。
#+begin_src sh
 /usr/lib/gcc/i686-linux-gnu/10/cc1 -quiet -v -imultiarch i386-linux-gnu add.c -quiet -dumpbase add.c -mtune=generic -march=i686 -auxbase add -version -fno-pic -fomit-frame-pointer -fasynchronous-unwind-tables -o /tmp/ccV7NJVF.s
#+end_src

~cc1~ は、
C 言語で書かれたソースコードをアセンブリ言語に変換しています。
この例では、
C 言語で書かれたソースコード ~add.c~ をコンパイルし、
~tmp~ という作業用のディレクトリ (テンポラリディレクトリ; temporary directory) に、
アセンブリ言語のプログラム ~/tmp/ccV7NJVF.s~ を生成しています。
なお、
生成されたファイルが ~ccV7NJVF.s~ という不思議な名前になっているのは、
コンパイラが機械的に生成した、
一時的なファイル名だからです。

GCC は次に、
アセンブラ ~as~ を起動しています。
#+begin_src sh
 as -v --32 -o /tmp/ccq78mRF.o /tmp/ccV7NJVF.s
#+end_src
~as~ はアセンブリ言語のプログラムを機械語にアセンブルしています。
この例では、
アセンブリ言語のプログラムをアセンブルし、
機械語のオブジェクトファイル ~/tmp/ccq78mRF.o~ を生成しています。
オブジェクトファイルも一時ファイルなので、
コンパイラが機械的に生成したファイル名が付いています。

そして最後に、
GCC は *リンカ* ~collect2~ を起動しています。
#+begin_src sh
 /usr/lib/gcc/i686-linux-gnu/10/collect2 -plugin /usr/lib/gcc/i686-linux-gnu/10/liblto_plugin.so -plugin-opt=/usr/lib/gcc/i686-linux-gnu/10/lto-wrapper -plugin-opt=-fresolution=/tmp/cc1lLmvG.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -m elf_i386 --hash-style=gnu --as-needed -dynamic-linker /lib/ld-linux.so.2 -pie /usr/lib/gcc/i686-linux-gnu/10/../../../i386-linux-gnu/Scrt1.o /usr/lib/gcc/i686-linux-gnu/10/../../../i386-linux-gnu/crti.o /usr/lib/gcc/i686-linux-gnu/10/crtbeginS.o -L/usr/lib/gcc/i686-linux-gnu/10 -L/usr/lib/gcc/i686-linux-gnu/10/../../../i386-linux-gnu -L/usr/lib/gcc/i686-linux-gnu/10/../../../../lib -L/lib/i386-linux-gnu -L/lib/../lib -L/usr/lib/i386-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/i686-linux-gnu/10/../../.. /tmp/ccq78mRF.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/i686-linux-gnu/10/crtendS.o /usr/lib/gcc/i686-linux-gnu/10/../../../i386-linux-gnu/crtn.o
#+end_src
~collect2~ は、
機械語のオブジェクトファイル ~/tmp/ccq78mRF.o~ をその他のオブジェクトファイルやライブラリファイルと *リンク (link; 結合)* しています。

以上の流れで、
最終的に実行ファイル ~add~ が生成されます。

ここからわかるのは、
~gcc~ コマンドは
#+begin_quote
C 言語 (ソースコード) → 機械語 (実行ファイル)
#+end_quote
のように、
C 言語で書かれたソースコードを直接機械語にコンパイルしているわけではなく、
#+begin_quote
C 言語 (ソースコード) → アセンブリ言語 (ソースコード) → 機械語 (オブジェクトファイル) → 機械語 (実行ファイル)
#+end_quote
のように、
段階的にコンパイル・アセンブル・リンクを行っているということです。

*** C 言語からアセンブリ言語へのコンパイル

それでは、
C 言語で書かれたプログラム ~add.c~ から、
どのようなアセンブリ言語のプログラムが作成されたのかも見てみましょう。

以下のように、
~gcc~ コマンドに ~-S~ オプションを指定すれば、
C 言語で書かれたソースコードをアセンブリ言語に変換した状態でコンパイルが停止します。
この例では、
C 言語で書かれたソースコード ~add.c~ が、
アセンブリ言語のプログラム ~add.s~ にコンパイルされます。

#+begin_src sh
$ gcc -S -fno-pic -fomit-frame-pointer add.c
#+end_src

アセンブリ言語から機械語へのアセンブルや、
オブジェクトファイルや実行ファイルの生成は行われません。

*** アセンブリ言語のプログラムを眺めてみる

早速、
C 言語で書かれたプログラム ~add.c~ から変換された、
アセンブリ言語のプログラム ~add.s~ (図 [[fig:asm/add.s]]) を眺めてみましょう。

#+caption: asm/add.s
#+label: fig:asm/add.s
#+include: "code/asm/add.s" src asm

アセンブリ言語のプログラムを読んだことがない人にとっては、
見慣れない命令が並んでいて、
どのように読めばいいのかわからないかもしれません。
ただし、
ここで「アセンブリ言語は知らないから、
よくわからない」と諦めないでください。
C 言語で書かれたソースコード ~add.c~ と、
C コンパイラによってコンパイルされたアセンブリ言語のプログラム ~add.s~ をじっくり比較してみることにしましょう。

以下の点に注意しながら、
アセンブリ言語のプログラム ~add.s~ の中で、
C 言語で書かれたソースコード ~add.c~ 中に記述されていた ~i~、
~main~、
~123~、
~456~ などの名前や数値を探してみてください。

- C 言語で書かれたソースコード中の変数 ~i~ は、アセンブリ言語のプログ
  ラムの、どこに、どのように表れているか
- C 言語で書かれたソースコード中の数値 ~123~ や ~456~ は、アセンブリ言
  語のプログラムの、どこに、どのように表れているか
-  C 言語で書かれたソースコード中の関数名 ~main~ は、アセンブリ言語の
  プログラムの、どこに、どのように表れているか

アセンブリ言語のプログラムだけを見てもよくわからないかもしれませんが、
アセンブリ言語のプログラムの元となった、
C 言語で書かれたプログラムのソースコードと一緒に見れば、
何となく読めそうな気がしてきたと思います。

ここではまだ、
アセンブリ言語のプログラムの詳細は説明しませんが、
本書を読み進めていけば少しずつアセンブリ言語のプログラムが読めるようになります。

** アセンブリ言語から機械語へ
<<sec:asm/asm-to-machine>>

最後に、
アセンブリ言語で書かれたプログラム ~add.s~ を、
アセンブラによってアセンブルし、
機械語のプログラムへと変換してみましょう。

*** アセンブラによるアセンブル

ここでは、
アセンブリ言語で書かれたプログラム ~add.s~ を、
先ほどの例でも ~gcc~ プログラムの内部で起動されていた、
GNU アセンブラ (~as~) を使ってアセンブルしていきます。

アセンブリ言語で書かれたプログラム ~add.s~ を機械語に変換 (アセンブル) するには以下のコマンドを実行します。

#+begin_src sh
$ as -o add.o add.s
#+end_src

これにより、
アセンブルされた機械語のプログラムがオブジェクトファイル ~add.o~ に保存されます。

*** 機械語のプログラムを眺めてみる

次のように GNU アセンブラに ~-a~ オプションを指定すると、
アセンブル結果を標準出力に表示してくれます。

#+begin_src sh
$ as -a -o add.o add.s
#+end_src

これを使って、
アセンブリ言語で書かれたプログラム ~add.s~ のアセンブル結果を眺めてみましょう。

#+caption: GNU アセンブラの出力
#+label: fig:asm/add.lst
#+include: "code/asm/add.lst" src asm

GAS LISTING と表示された箇所に、
アセンブリ言語のプログラムをどのような機械語に変換したかが表示されています。
例えば、
#+begin_src asm
  17 0005 05C80100 		addl	$456, %eax
  17      00
#+end_src
は、
アセンブリ言語のプログラム ~add.s~ の 17 行目の ~addl $456, %eax~ のアセンブル結果です。
これは、
メモリの 0005 番地に、
16 進数で 0x05、
0xc8、
0x01、
0x00、
0x00 という 5 バイトの機械語を生成したことを意味します。

こうしてアセンブル結果を眺めると、
例えば以下のようなことがわかります。
- 1つのアセンブリ言語の命令につき 1 バイト (~ret~) から 5 バイト
  (~movl~、~add~) の機械語が生成されている
- ドット (~.~) から始まる命令に対しては機械語が生成されていない

16 進数やメモリのアドレス (番地) は後ほど説明するので、
今はよくわからなくてもかまいません。
ここでは、
C 言語で書かれたプログラムが、
C コンパイラによってどのようにコンパイルされ、
アセンブラによってどのようにアセンブルされるかのイメージをつかんでください。

** 章末問題
<<sec:asm/quiz>>

1. 国語辞典 (中規模以上のものが望ましい) で「オペレータ」、「オペラン
   ド」、「演算子」、「被演算子」の項をそれぞれ調べよ。また、プログラ
   ミング言語における「オペレータ (演算子)」、「オペランド (被演算子)」
   に該当する解説を (解説の有無も含めて) 確認せよ。

2. 英英辞典 (中規模以上のものが望ましい) で「operator」および「operand」
   の項をそれぞれ調べよ。また、プログラミング言語における「オペレータ
   (演算子)」、「オペランド (被演算子)」に該当する解説を (解説の有無も
   含めて) 確認せよ。

3. コンピュータサイエンスにおける専門用語のうち、英語表記を正確に理解
   していないものを 10 個列挙せよ。また、それらの英語表記を、信頼でき
   る情報源を用いて調べよ。

4. 「コード」、「ソフトウェア」、「命令」、「プログラム」の違いは何か。

   #+begin_answer
   文脈にもよるが、
   コンピュータに特定の操作を指示するものが「命令 (instruction)」であり、
   命令が一揃えになったものが「プログラム (program)」である。
   「コード (code)」はプログラムと同じ意味で用いられることが多い。
   複数のプログラムが集まったものが「ソフトウェア (software)」である。
   #+end_answer

5. バイナリファイルを 16 進数でダンプできるプログラム (例: ~hd~ コマン
   ド) を入手せよ。GPL ライセンスで公開されている実行形式のプログラム
   を 1 つ選び、そのプログラムの中身を 16 進数でダンプせよ。ダンプした
   結果から何がわかるかを説明せよ。

6. JIS X0001-1994 を入手し、「ソフトウェア」、「メモリ」、「ビット」、
   「バイト」、「オクテット」、「CPU」、「コンピュータ」、「ファイル」
   の意味を確認せよ。

   #+begin_answer
   以下、JIS X0001-1994 より抜粋:

   - 01.01.08 ソフトウェア (software)
   
     情報処理システムのプログラム，
     手続き，
     規則及び関連文書の全体又は一部分。
     
     備考: ソフトウェアは，
     それを記録した媒体とは無関係な知的創作物である。
   
   - 01.01.11 メモリ (memory)
   
     処理装置及び他のすべての内部記憶装置において，
     命令を実行するために使用するアドレスを付けることのできる記憶空間のすべて。
     
   - 01.02.08 ビット， 2進数字 (bit, binary digit)
   
     2 進記数法で用いられる 0 又は 1 のいずれかの数字。
   
   - 01.02.09 バイト (byte)
   
     一つの単位として扱われる複数のビットからなる列。
     通常，
     1 文字又は文字の一部分を表現するもの。
     
     備考 1. 1 バイト中のビット数は，データ処理システムごとに一定である。\\
     \quad 2. 1バイト中のビット数は，通常，8である。 
   
   - 01.02.10 8 ビットバイト，オクテット (8-bit byte, octet)
   
     8 ビットからなるバイト。
   
   - 01.03.01 処理装置，中央処理装置，CPU （省略形） (processing unit, central processing unit, CPU)
   
     一つ以上の処理機構と内部記憶装置とからなる機能単位。
     備考処理機構と処理装置は，
     同義に使用されることがある。
   
   - 01.03.03 計算機，コンピュータ (computer)
   
     算術演算及び論理演算を含む大量の計算を，
     人手の介入なしに遂行することのできる機能単位。
     
     備考 1. 計算機は，
     独立した単体であっても，
     相互に接続された幾つかの装置で構成されていてもよい。\\
     \quad 2. 情報処理の分野では，
     計算機は，
     ディジタル計算機のことをいう。
   
   - 01.08.06 ファイル (file)
   
     一つの単位として記憶又は処理される，
     レコードからなる名前の付いた集合。
   #+end_answer

7. C 言語で書かれた単純なプログラムを作成または入手し、~gcc~ コマンド
   に ~-S~ オプションを付与することでアセンブリ言語のプログラムに変換
   せよ。また、C 言語とアセンブリ言語のプログラムを比較し、C 言語とア
   センブリ言語がどのように対応しているかを考察せよ。

8. C コンパイラが、C 言語で書かれたプログラムを機械語のプログラムに直
   接コンパイルしないことの利点、および欠点は何か。

   #+begin_answer
   利点: 処理系の構造が単純になる (KISS の原則 ([[sec:inline/overview]] 節))。
   コンピュータのアーキテクチャの違いを吸収できる

   欠点: コンパイルが遅くなる、
   中間ファイル保存のための余分なディスク領域が必要となる。
   #+end_answer

9. C 言語で書かれた以下のプログラム (図 [[fig:asm/hello.c]]) をコンパイル
   し、実行ファイルを作成せよ。さらにバイナリファイルを編集できるツー
   ル (バイナリエディタ) を入手し、実行ファイルを直接書き換えることに
   より、「Hello, World!」というメッセージが表示されないように改変せよ。

   #+caption: asm/hello.c
   #+label: fig:asm/hello.c
   #+include: "code/asm/hello.c" src raw

   #+begin_answer
   いくつかの方法があるが、
   「Hello, World!」のバイト列 48 65 6c 6c 6f 2c 20 57 6f 72 6c 64 21 において、
   先頭の 0x48 を 0x00 (ヌル文字) に置き換えればよい。
   #+end_answer
